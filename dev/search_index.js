var documenterSearchIndex = {"docs":
[{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"EditURL = \"<unknown>/fdtd/create_snaps.jl\"","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"We aim to save the snapshots, at given time steps in SeisForwExpt.","category":"page"},{"location":"generated/fdtd/create_snaps/#Loading-some-packages-1","page":"Generate snaps","title":"Loading some packages","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"using GeoPhyInv\nusing Statistics","category":"page"},{"location":"generated/fdtd/create_snaps/#Setting-up-the-variables-necessary-to-create-the-Expt-1","page":"Generate snaps","title":"Setting up the variables necessary to create the Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"model=Medium(:acou_homo1); # load a simple homogeneous acoustic model from the gallery\nupdate!(model, [:vp,:rho], randn_perc=0.1); # add some random noise to the model\nageom=AGeom(model.mgrid,:xwell, SSrcs(2)); # load a simple acquisition ageometry using `mgrid` of the seismic model\ntgrid = range(0.0,stop=2.0,length=2000) # generate a time grid\nwav = ricker(10.0, tgrid, tpeak=0.25,); # ricker wavelet\n\nsrcwav = SrcWav(tgrid, ageom, [:P])\nupdate!(srcwav, [:P], wav)\n@info \"We are ready for the modeling.\"","category":"page"},{"location":"generated/fdtd/create_snaps/#Final-step-1","page":"Generate snaps","title":"Final step","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"One can plot the model, source and receivers using these commands: using Plots; p1=JP.seismic(model); JP.ageom!(ageom); plot(p1); Now we have all the required variables to create SeisForwExpt object and prepare the forward modelling. While creating, we switched the snaps_flag on, and instructed recording field at tsnaps. Once the Expt object is created, do the modelling \"without approximately any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"paE=SeisForwExpt(Fdtd(),model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsnaps_flag=true,\n\ttsnaps=[0.3, 0.4, 0.5],\n\ttgridmod=tgrid, verbose=true);\n\n@time update!(paE);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Extracting-snaps-from-Expt-1","page":"Generate snaps","title":"Extracting snaps from Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"snaps=paE[:snaps,1]; # extracting snaps of the first supersource\nsnaps=paE[:snaps,2]; # second supersource\n@info string(\"The dimensions of the snaps are (nz,nx,nt)=\", size(snaps))","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"We can now plot snapshots using these commands:","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"Generate snaps","title":"Generate snaps","text":"p=[]\n#Gadfly.set_default_plot_size(20cm, 5cm)\nfor ii in 1:3\n#\tpush!(p, spy(snaps[:,:,ii], Guide.xlabel(\"x\"), Guide.ylabel(\"z\")))\nend\n#hstack(p...)","category":"page"},{"location":"contributing/#Coding-Conventions-1","page":"-","title":"Coding Conventions","text":"","category":"section"},{"location":"contributing/#","page":"-","title":"-","text":"This software is organised into various modules. Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  distance = velocity * time is prefered over using  a = b * c in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation (Image: guide)","category":"page"},{"location":"contributing/#","page":"-","title":"-","text":"The methods ending with ! ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"EditURL = \"<unknown>/Poisson/forw.jl\"","category":"page"},{"location":"generated/Poisson/forw/#Loading-some-packages-1","page":"Record data","title":"Loading some packages","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus","category":"page"},{"location":"generated/Poisson/forw/#Solve-for-ψ-in-a-PoissonExpt-1","page":"Record data","title":"Solve for ψ in a PoissonExpt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"Consider the following Poisson experiment:","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"We start with the dimensions and spatial grids are allocated as follows.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"Now lets allocate the inputs for a toy experiment. These medium parameters are used to generate the observed field ψ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n@info \"Medium parameters allocated.\"","category":"page"},{"location":"generated/Poisson/forw/#Acquisition-1","page":"Record data","title":"Acquisition","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"Now, we will generate an acquisition ageometry and allocate a projection matrix ACQ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"ageom=AGeom(mgrid, SSrcs(1), Srcs(1), Recs(30))\nupdate!(ageom, SSrcs(), [0,0], 5, [0,2π])\nupdate!(ageom, Recs(), [0,0], 5, [0,2π])\nACQ=SparseMatrixCSC(ageom[1],mgrid);\n@info \"ACQ will be used to project ψ onto receivers.\"","category":"page"},{"location":"generated/Poisson/forw/#Generate-PoissonExpt-and-then-applying-mod!-1","page":"Record data","title":"Generate PoissonExpt and then applying mod!","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"This will first","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"apply operator A=(Q(xz)) on a field p;\nthen apply ((σ(xz)))^-1 in order to solve for ψ;\nfinally, records ψ at the receiver locations to generate data.","category":"page"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ)\nGeoPhyInv.mod!(paE)","category":"page"},{"location":"generated/Poisson/forw/#Extracting-data-from-Expt-1","page":"Record data","title":"Extracting data from Expt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"Record data","title":"Record data","text":"data=paE[:data]\n@info string(\"The dimensions of data are (nt,nr)=\",size(data))","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"EditURL = \"<unknown>/ageom/doc.jl\"","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"using GeoPhyInv\nusing Test\nusing SparseArrays","category":"page"},{"location":"generated/ageom/doc/#Intro-1","page":"AGeom","title":"Intro","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"AGeom","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.AGeom","page":"AGeom","title":"GeoPhyInv.AGeom","text":"AGeom=Vector{AGeomss,1}\n\nAn acquisition geometry, bundled into the mutable AGeom type, has to be specified in order to create any Expt variable. Acquisition has supersources, sources and receivers. For AGeom is a mutable type to define source-receiver geometry.  Each supersource has ns sources that are injected (or active) simultaneously, and  a set of nr receivers to  record.  AGeomss is a subtype for each supersource, therefore: This package provides tools to easily create commonly-used AGeom instances,  after deciding on a spatial grid mgrid for the experiment.\n\nIndexing and Fields\n\nLet ageom be an instance of this type, then fields  can be accessed using:\n\nageom[i] : acquisition for ith supersource\nageom[i].sx : x positions of sources\nageom[i].sz : z positions of sources\nageom[i].rx : x positions of receivers\nageom[i].rz : z positions of receivers\nageom[i].ns : number of sources \nageom[i].nr : number of receivers\n\nageom=AGeom(mgrid, attrib, SSrcs(10), Recs(20))\n\nReturn pre-defined acquisition geometries (with 10 sources and 20 receivers), based on attrib, on an input mesh mgrid. The sources and receivers positions are same for all supersources, and are not placed on the edges of the mesh. Choose attrib::Symbol\n\n=:xwell cross-well acquisition;\n=:surf surface acquisition;\n=:vsp vertical seismic profiling;\n=:rvsp  reverse vertical seismic profiling;\n=:downhole downhole sources and receivers.\n\n\n\n\n\n","category":"type"},{"location":"generated/ageom/doc/#Examples-1","page":"AGeom","title":"Examples","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Lets create a mgrid for the experiment.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Then initialize an acquisition on mgrid.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Otherwise, initialize with one of the predefined acquisitions.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom=AGeom(mgrid, :xwell, SSrcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"By default, the sources and receivers are randomly placed on the grid. If unsure, test it.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"@test (ageom ∈ mgrid)","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"The source and receiver positions can be updated as desired.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"update!(ageom[1], Srcs(), [0,1], [10,20],);\nupdate!(ageom[1], Recs(), [0,0], [10,20],);\nupdate!(ageom, SSrcs(), [0,1], [10,20], );\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"It is easy to combine supersources. Now ageom2 has 20 supersources.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom2=vcat(ageom, ageom);\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#Methods-1","page":"AGeom","title":"Methods","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"update!(::AGeomss, ::Srcs)\nupdate!(::AGeomss, ::Recs)\nupdate!(::AGeom, ::SSrcs)\nupdate!(::AGeom, ::Recs)\nBase.in(::AGeom, ::AbstractVector{StepRangeLen})\nBase.isequal(::AGeom, ::AGeom)\nSparseArrays.SparseMatrixCSC(::AGeomss,::AbstractVector{StepRangeLen})","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss,Srcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Srcs(10), p1, p2)\n\nUpdate source geometry for the first supersource, with 10 sources placed regularly between p1=[z1,x1] and p2=[z2,x2]\n\nupdate!(ageom[2], Srcs(10), p0, rad, angles)\n\nUpdate source geometry for the second supersource, with 10 sources placed equidistant from p0=[z0,x0] given radius rad and angles angles=[0,2pi].\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss,Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Recs(10), args...)\n\nSimilar to updating source positions, but for receivers.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Array{AGeomss,1},SSrcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, SSrcs(), p1, p2)\nupdate!(ageom, SSrcs(), p0, rad, angles)\n\nUpdate source positions for all supersources. \n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Array{AGeomss,1},Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, Recs(), p1, p2)\nupdate!(ageom, Recs(), p0, rad, angles)\n\nUpdate receiver positions for all supersources.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.in-Tuple{Array{AGeomss,1},AbstractArray{StepRangeLen,1}}","page":"AGeom","title":"Base.in","text":"ageom ∈ mgrid\nin(ageom, mgrid)\n\nAssert if all the sources and receivers in AGeom are within bounds of mgrid.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.isequal-Tuple{Array{AGeomss,1},Array{AGeomss,1}}","page":"AGeom","title":"Base.isequal","text":"isequal(ageom1, ageom2)\n\nAssert if ageom1 equals ageom2.\n\n\n\n\n\n","category":"method"},{"location":"generated/fdtd/doc/#","page":"Introduction","title":"Introduction","text":"EditURL = \"<unknown>/fdtd/doc.jl\"","category":"page"},{"location":"generated/fdtd/doc/#","page":"Introduction","title":"Introduction","text":"A forward experiment, where the seismic data are generated using some models and acquisition parameters from our gallery. Forward modeling consists of a finite-difference simulation of the acoustic wave-equation.","category":"page"},{"location":"generated/fdtd/doc/#","page":"Introduction","title":"Introduction","text":"b=4","category":"page"},{"location":"generated/Poisson/doc/#","page":"Introduction","title":"Introduction","text":"EditURL = \"<unknown>/Poisson/doc.jl\"","category":"page"},{"location":"generated/Poisson/doc/#","page":"Introduction","title":"Introduction","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"generated/Poisson/doc/#","page":"Introduction","title":"Introduction","text":"Consider the following Poisson experiment:","category":"page"},{"location":"generated/Poisson/doc/#","page":"Introduction","title":"Introduction","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"generated/Poisson/doc/#","page":"Introduction","title":"Introduction","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"EditURL = \"<unknown>/Poisson/test_born.jl\"","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"The linearized forward modeling operator F and its adjoint (aka Migration operator) are the building blocks of iterative optimization schemes. For the PoissonExpt, we have the functionality to compute F*x without explicitly storing the operator matrix (see LinearMaps.jl). The perturbed field δψ due to a perturbation in σ is given by","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"δψ=-A¹(σ₀)A(δσ)ψ₀","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"where","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"(σ₀(xz)) ψ₀(t)=A(σ₀)ψ₀(t)=f(t)","category":"page"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"Lets start a tutorial.","category":"page"},{"location":"generated/Poisson/test_born/#Load-some-packages-1","page":"Born map","title":"Load some packages","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing ProgressMeter\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus\nusing LinearMaps","category":"page"},{"location":"generated/Poisson/test_born/#Setting-up-the-spatial-and-temporal-grids-1","page":"Born map","title":"Setting up the spatial and temporal grids","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/test_born/#Allocating-medium-parameters-1","page":"Born map","title":"Allocating medium parameters","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n\nσobs=abs.(randn(nz,nx))\nQobs=abs.(randn(nz,nx))\nnr=10 # number of abstract receivers\nACQ=sprandn(nr,nz*nx,0.6); # choose a random acquisition operator\n@info \"We are ready for the PoissonExpt.\"","category":"page"},{"location":"generated/Poisson/test_born/#Create-an-Expt,-and-then-extract-a-linear-forward-map-out-of-it-1","page":"Born map","title":"Create an Expt, and then extract a linear forward map out of it","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ, σobs=σobs, Qobs=Qobs,)\nF=LinearMap(paE, σ); # extract the linearized forward operator from `Expt`\nGeoPhyInv.Utils.test_linearmap(F) # finally do some tests on the linearmap","category":"page"},{"location":"generated/Poisson/test_born/#Usage-1","page":"Born map","title":"Usage","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"Born map","title":"Born map","text":"δx=randn(size(F,2)) # random model pertubation\nδd=F*δx # corresponding pertubation in data\n@info string(\"Length of data: (nt*nr)=\",length(δd))","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"EditURL = \"<unknown>/data/doc.jl\"","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"using GeoPhyInv\nusing Test\nusing Random","category":"page"},{"location":"generated/data/doc/#Intro-1","page":"Data","title":"Intro","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Data","category":"page"},{"location":"generated/data/doc/#GeoPhyInv.Data","page":"Data","title":"GeoPhyInv.Data","text":"A mutable type that bundles multi-component records at multiple receivers.\n\ndata=Data(tgrid, ageom, [:P, :Vx])\n\n\nHere, we initialized records, of :P and :Vx fields, in time domain for receivers and supersources in ageom.\n\nIndexing\n\ndata[i] : the records due to ith supersource of all fields\ndata[i][:P] : extract field :P \ndata[i][:nr] : number of receivers (same as in ageom)\ndata.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, data can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/data/doc/#Examples-1","page":"Data","title":"Examples","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Need a time grid.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Lets initialize records for :P and :Vz fields.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"data=Data(tgrid, ageom, [:P,:Vz]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Random.randn!(data[3][:P]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#Methods-1","page":"Data","title":"Methods","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Methods listed for SrcWav can used on instances of Data too.","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"EditURL = \"<unknown>/fdtd/reuse_expt.jl\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"This tutorial first creates a variable pa, i.e. allocates necessary memory to perform SeisForwExpt. Then, we perform forward modeling using an in-place function mod!. Finally, we will update pa with a different subsurface model and re-run the modeling task with no additional memory allocation. The ability to iteratively run the forward modeling task on various subsurface models is necessary while implementing inversion algorithms.","category":"page"},{"location":"generated/fdtd/reuse_expt/#Load-packages-1","page":"Basic usage","title":"Load packages","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"using GeoPhyInv\nusing Statistics\nusing Plots\nusing Test","category":"page"},{"location":"generated/fdtd/reuse_expt/#Setup-a-spatial-grid-1","page":"Basic usage","title":"Setup a spatial grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"zgrid=range(-1000.0,stop=1000.0,length=201)\nxgrid=range(-1000.0,stop=1000.0,length=201)\nmgrid = [zgrid, xgrid]\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))","category":"page"},{"location":"generated/fdtd/reuse_expt/#Allocate-a-Seismic-model,-and-adjust-bounds-1","page":"Basic usage","title":"Allocate a Seismic model, and adjust bounds","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"vpb = [1500., 3500.] # bounds for vp\nrhob = [1500., 3500.] # density bounds\n\nmodel=Medium(mgrid)\nupdate!(model, [:vp,:rho], [vpb,rhob])\nfill!(model)\n@info \"a seismic model is created\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#Add-some-noise-to-the-model-(optional)-1","page":"Basic usage","title":"Add some noise to the model (optional)","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"update!(model, [:vp,:rho], randn_perc=0.01); # add some random noise\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#A-surface-acquisition-ageometry-1","page":"Basic usage","title":"A surface acquisition ageometry","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"ageom=AGeom(model.mgrid,:surf, SSrcs(3), Recs(30));\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Plot-the-model-and-source,-receivers-1","page":"Basic usage","title":"Plot the model and source, receivers","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"p1=heatmap(model, :vp)\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\nplot(p1)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Generate-a-temporal-grid-1","page":"Basic usage","title":"Generate a temporal grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"tgrid = range(0.0,stop=2.0,length=1000)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Choose-a-source-wavelet-1","page":"Basic usage","title":"Choose a source wavelet","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"wav = ricker(10.0, tgrid, tpeak=0.25,);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Distribute-the-same-source-wavelet-to-all-the-supsersources-1","page":"Basic usage","title":"Distribute the same source wavelet to all the supsersources","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"srcwav = SrcWav(tgrid, ageom, [:P])\nupdate!(srcwav, [:P], wav)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"create Fdtd.Param object to prepare forward modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"npw corresponds to the number of independently propagating wavefields (1 in most cases)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"Once the Param object is created, do the modelling \"without any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"pa=SeisForwExpt(Fdtd(),npw=1,model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsflags=[2], rflags=[1],\n\ttgridmod=tgrid, verbose=true);\n\n@time update!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"pdata=heatmap(pa[:data])\nplot(pdata)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"create new seismic model","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"model_new=Medium(:acou_homo1) # prepare another model\nupdate!(model_new, [:vp,:rho], randn_perc=0.01)\nupdate!(model_new, [:vp,:rho], constant_pert=0.03) # perturb the model\np2=heatmap(model_new, :vp) # plot new model\nscatter!(ageom, SSrcs())\nscatter!(ageom, Recs())\nplot(p2)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"Now, we the change the model in the Param object without memory allocation This routine can be used during FWI, where medium parameters are itertively updated in the same Fdtd.Param object","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"update!(pa, model_new)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"run modelling now and plot data again","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"@time update!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"Basic usage","title":"Basic usage","text":"heatmap!(pdata, pa[:data])\nplot(pdata)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"EditURL = \"<unknown>/media/doc.jl\"","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"using BenchmarkTools\nusing GeoPhyInv\nusing Test\nusing Plots\ngr()","category":"page"},{"location":"generated/media/doc/#Intro-1","page":"Medium","title":"Intro","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"GeoPhyInv.Medium\nMedium(::Symbol, ::Real)","category":"page"},{"location":"generated/media/doc/#GeoPhyInv.Medium","page":"Medium","title":"GeoPhyInv.Medium","text":"Mutable type for storing medium parameters.\n\nmod=Medium(mgrid, names=[:vp,:rho])\n\nThis initializes a subsurface model with :vp and :rho parameters. Print the names of the medium parameters stored in mod.\n\nnames(mod)\n\nIndexing\n\nmod.mgrid : returns the spatial-grid bundle\nmod[:vp] : P-wave velocity\nmod[:rho] : mass density\nmod[:Zp] : P-wave impedance \nmod[:K] : bulk modulus \nmod.ref : reference medium parameters \nmod.bounds : bounds of medium parameters\n\n\n\n\n\n","category":"type"},{"location":"generated/media/doc/#GeoPhyInv.Medium-Tuple{Symbol,Real}","page":"Medium","title":"GeoPhyInv.Medium","text":"mod=Medium(attrib)\n\nAs of now, only seismic models are predefined in this package. Choose attrib::Symbol\n\n=:acou_homo1 : a test homogeneous acoustic model\n=:acou_homo2 : a test homogeneous acoustic model, but with coarser spatial sampling (faster testing)\n=:marmousi2 : marmousi2 model with lower resolution; useful for surface seismic experiments\n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Examples-1","page":"Medium","title":"Examples","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Load a predefined model.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod=Medium(:marmousi2);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Get the medium parameters that are stored.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"names(mod)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Look at the reference values.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod.ref","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Inspect the bounds.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod.bounds","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To construct an instance of Medium, we need a 2-D grid.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Allocate basic medium parameters on the grid.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod = Medium(mgrid, [:vp,:rho,:vs]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Bounds for these parameters should be input for modeling or inversion. Use update!","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"vpb=[2100.,2200.]; vsb=[1500, 1700]; rhob=[2100., 2300.];\nupdate!(mod, [:vp,:vs,:rho], [vpb, vsb, rhob]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Just fill mod with average (reference) values.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"fill!(mod);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Once the basic medium parameters are input, we can access some other derived parameters.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod[:Zp];\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Otherwise, we can manually update parameters of mod.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod[:vp].=3000.;\nmod[:vs].=2000.;\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"A model can be also be updated by adding random noise.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"update!(mod, [:vp,:rho], randn_perc=1.);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #1","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"p1=heatmap(mod, :vp); plot(p1)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #2","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"p2=heatmap(mod, :vs); plot(p2)","category":"page"},{"location":"generated/media/doc/#Methods-1","page":"Medium","title":"Methods","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Base.getindex(::Medium, ::Symbol)\nGeoPhyInv.update!(::GeoPhyInv.Medium, ::Vector{Symbol},)\nBase.copyto!(x::AbstractArray, mod::Medium, fields::Vector{Symbol})\nBase.vec(mod::Medium, ::Symbol)","category":"page"},{"location":"generated/media/doc/#Base.getindex-Tuple{Medium,Symbol}","page":"Medium","title":"Base.getindex","text":"Get other dependent model parameters of a seismic model that are not present in Seismic.\n\n:rhoI : inverse of density\n:Zp : P-wave impedance\n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#GeoPhyInv.update!-Tuple{Medium,Array{Symbol,1}}","page":"Medium","title":"GeoPhyInv.update!","text":"In-place method to add features to the input model.\n\nArguments\n\nmod::Medium : model that is modified\n\nKeyword Arguments\n\npoint_loc::Vector{Float64}=[0., 0.,] : approx location of point pert\npoint_pert::Float64=0.0 : perturbation at the point scatterer\nellip_loc::Vector{Float64}=nothing : location of center of perturbation, [z, x]\nellip_rad::Float64=0.0 : size of elliptic perturbation\nellip_pert::Float64=0.1 : perturbation inside the ellipse\nellip_α=0.0 : rotate the ellipse\nrect_loc::Array{Float64}=nothing : rectangle location, [zmin, xmin, zmax, xmax]\nrect_pert::Float64=0.1 : perturbation in a rectangle\nconstant_pert::Float64=0.0 : constant perturbation \nrandn_pert::Float64=0.0 : percentage of reference values for additive random noise\nfields::Vector{Symbol}=[:χvp,:χrho,:χvs] : which fields are to be modified?\nonlyin : mod is modified only when field values are in these ranges \n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Base.copyto!-Tuple{AbstractArray,Medium,Array{Symbol,1}}","page":"Medium","title":"Base.copyto!","text":"Copy medium parameters from Medium mod, to vector x. Return x. copyto!(x,mod,[:vp])\n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Base.vec-Tuple{Medium,Symbol}","page":"Medium","title":"Base.vec","text":"Return a vector of medium parameters x, from Medium mod. x=vec(mod)\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"EditURL = \"<unknown>/srcwav/doc.jl\"","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"using GeoPhyInv\nusing LinearAlgebra\nusing Random","category":"page"},{"location":"generated/srcwav/doc/#Intro-1","page":"SrcWav","title":"Intro","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"SrcWav","category":"page"},{"location":"generated/srcwav/doc/#GeoPhyInv.SrcWav","page":"SrcWav","title":"GeoPhyInv.SrcWav","text":"A mutable type that bundles multi-component source wavelets. \n\nsrcwav=SrcWav(tgrid, ageom, [:P, :Vx])\n\n\nHere, we initialized wavelets, for :P and :Vx fields, in time domain for sources and supersources in ageom.\n\nIndexing\n\nsrcwav[i] : wavelets for ith supersource of all fields\nsrcwav[i][:P] : extract field :P \nsrcwav[i][:ns] : number of sources (same as in ageom)\nsrcwav.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, srcwav can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/srcwav/doc/#Examples-1","page":"SrcWav","title":"Examples","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Need a time grid.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Lets initialize records for :P field.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"srcwav=SrcWav(tgrid, ageom, [:P]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Random.randn!(srcwav[3][:P]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Often we want to populate the same source wavelet to all the supersources and sources.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"x=randn(length(tgrid));\nupdate!(srcwav, [:P,], x);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Populate two different wavelets for first and second supersources.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"x1=randn(length(tgrid));\nx2=randn(length(tgrid));\nupdate!(srcwav[1], [:P,], x1);\nupdate!(srcwav[2], [:P,], x2);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Scale srcwav by a scalar overwriting it in-place.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"rmul!(srcwav, 2.0);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#Methods-1","page":"SrcWav","title":"Methods","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Most of the methods listed below are also applicable to individual elements of srcwav.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"update!(GeoPhyInv.VNamedD, ::Vector{Symbol}, ::AbstractVector{Float64},)\nBase.reverse!(::GeoPhyInv.VNamedD)\nBase.iszero(::GeoPhyInv.VNamedD)\nBase.isequal(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nissimilar(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.vec(::GeoPhyInv.VNamedD)\nRandom.randn!(::GeoPhyInv.VNamedD)\nBase.fill!(::GeoPhyInv.VNamedD, ::Float64)\nLinearAlgebra.dot(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nLinearAlgebra.rmul!(::GeoPhyInv.VNamedD, ::Number)\nBase.copyto!(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.copyto!(::AbstractVector{Float64}, ::GeoPhyInv.VNamedD)\nBase.copyto!(::GeoPhyInv.VNamedD, ::AbstractVector{Float64})","category":"page"},{"location":"generated/srcwav/doc/#Base.iszero-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.iszero","text":"iszero(srcwav)\n\nReturns bool if srcwav has all zeros.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.isequal-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.isequal","text":"isequal(srcwav1, srcwav2)\n\nAssert if srcwav1 and srcwav2 are equal.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.vec-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.vec","text":"v=vec(srcwav)\nReshape `srcwav` as a one-dimensional column vector.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(srcwav1, srcwav2)\n\nCopy srcwav2 to srcwav1, which has same size.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{AbstractArray{Float64,1},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(v, srcwav)\n\nSame as vec(srcwav), but in-place operation.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},AbstractArray{Float64,1}}","page":"SrcWav","title":"Base.copyto!","text":"v=vec(srcwav) \nrandn!(v)\ncopyto!(srcwav, v)\n\nCopy v to srcwav. The sizes of the two objects much match. No memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"#The-Expt-Datatypes-1","page":"Home","title":"The Expt Datatypes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The methods in this package numerically solve some differential equations commonly faced in geophysical inverse problems. The functionality of this package revolves around the mutable Expt types. Julia's multiple dispatch is used to overload Base methods whenever possible.  Which means, if one is familiar with the Base methods of Julia, then (almost) no additional syntax is required  to use this package.  While performing a given experiment, firstly, most of the memory necessary is allocated while creating the Expt variables. Then these variables are input to in-place functions  (e.g., update!)  which as per Julia convention ends with an exclamation mark, to actually perform the experiment task. For example, the current Expt types within the realm of this package include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SeisForwExpt is the seismic (acoustic) forward modeling experiment;\nSeisInvExpt is the type for seismic inversion experiment, including migration;\nPoissonExpt is type for the solving the Poisson experiment.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some of the commonly used (and exported) mutable types to create the Expt variables are:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Medium for bundling medium parameters together;\nAGeom stores acquisition geometry related parameters;\nSrcWav allocates source signals input to an experiment;\nData allocated the output records that are fitted during inversion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get started, as an example, simply load a seismic inversion experiment already defined in our package gallery into REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GeoPhyInv # load package (after installation)\npa=SeisInvExpt(Fdtd(), LS(), :pizza); # \"pizza\" is the name of the experiment","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then, simply use update! to perform least-squares inversion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"update!(pa)","category":"page"},{"location":"#Grids-1","page":"Home","title":"Grids","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It is necessary to input the evenly-spaced spatial and temporal grids while creating the Expt variables. These grids can be simply created using Base.range in Julia, as shown below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"zgrid=range(0,stop=1000.0,length=201) # create vertical grid from 0 to 1000 m\nxgrid=range(0,stop=1000.0,length=201) # create horizontal grid\nmgrid=[zgrid, xgrid] # spatial-grid bundle\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))\ntgrid=range(0,stop=1.0,step=0.001) # a temporal grid from 0 to 1.0 s","category":"page"}]
}
