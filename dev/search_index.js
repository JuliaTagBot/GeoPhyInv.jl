var documenterSearchIndex = {"docs":
[{"location":"generated/ageom/gallery/#","page":"-","title":"-","text":"EditURL = \"<unknown>/ageom/gallery.jl\"","category":"page"},{"location":"generated/ageom/gallery/#Load-packages-1","page":"-","title":"Load packages","text":"","category":"section"},{"location":"generated/ageom/gallery/#","page":"-","title":"-","text":"using GeoPhyInv","category":"page"},{"location":"generated/ageom/gallery/#A-surface-acquisition-1","page":"-","title":"A surface acquisition","text":"","category":"section"},{"location":"generated/ageom/gallery/#","page":"-","title":"-","text":"mgrid=repeat(range(-1000.0,stop=1000.0,length=201), 2) # test spatial grid\n#ageom_surf=GeoPhyInv.Gallery.AGeom(mgrid,:surf,nss=5,nr=30);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fdtd/create_snaps.jl\"","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"We aim to save the snapshots, at given time steps in SeisForwExpt.","category":"page"},{"location":"generated/fdtd/create_snaps/#Loading-some-packages-1","page":"-","title":"Loading some packages","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics\nusing Gadfly","category":"page"},{"location":"generated/fdtd/create_snaps/#Setting-up-the-variables-necessary-to-create-the-Expt-1","page":"-","title":"Setting up the variables necessary to create the Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"model=Medium(:acou_homo1); # load a simple homogeneous acoustic model from the gallery\nupdate!(model, [:vp,:rho], randn_perc=0.1); # add some random noise to the model\nageom=AGeom(model.mgrid,:xwell, SSrcs(2)); # load a simple acquisition ageometry using `mgrid` of the seismic model\ntgrid = range(0.0,stop=2.0,length=2000) # generate a time grid\nwav = ricker(10.0, tgrid, tpeak=0.25,); # ricker wavelet\n\nsrcwav = SrcWav(tgrid, ageom, [:P])\nupdate!(srcwav, [:P], wav)\n@info \"We are ready for the modeling.\"","category":"page"},{"location":"generated/fdtd/create_snaps/#Final-step-1","page":"-","title":"Final step","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"One can plot the model, source and receivers using these commands: using Plots; p1=JP.seismic(model); JP.ageom!(ageom); plot(p1); Now we have all the required variables to create SeisForwExpt object and prepare the forward modelling. While creating, we switched the snaps_flag on, and instructed recording field at tsnaps. Once the Expt object is created, do the modelling \"without approximately any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"paE=SeisForwExpt(Fdtd(),model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsnaps_flag=true,\n\ttsnaps=[0.3, 0.4, 0.5],\n\ttgridmod=tgrid, verbose=true);\n\n@time update!(paE);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Extracting-snaps-from-Expt-1","page":"-","title":"Extracting snaps from Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"snaps=paE[:snaps,1]; # extracting snaps of the first supersource\nsnaps=paE[:snaps,2]; # second supersource\n@info string(\"The dimensions of the snaps are (nz,nx,nt)=\", size(snaps))","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"We can now plot snapshots using these commands:","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"p=[]\n#Gadfly.set_default_plot_size(20cm, 5cm)\nfor ii in 1:3\n#\tpush!(p, spy(snaps[:,:,ii], Guide.xlabel(\"x\"), Guide.ylabel(\"z\")))\nend\n#hstack(p...)","category":"page"},{"location":"contributing/#Coding-Conventions-1","page":"-","title":"Coding Conventions","text":"","category":"section"},{"location":"contributing/#","page":"-","title":"-","text":"This software is organised into various modules. Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  distance = velocity * time is prefered over using  a = b * c in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation (Image: guide)","category":"page"},{"location":"contributing/#","page":"-","title":"-","text":"The methods ending with ! ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"EditURL = \"<unknown>/Poisson/forw.jl\"","category":"page"},{"location":"generated/Poisson/forw/#Loading-some-packages-1","page":"-","title":"Loading some packages","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing ProgressMeter\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus","category":"page"},{"location":"generated/Poisson/forw/#Solve-for-ψ-in-a-PoissonExpt-1","page":"-","title":"Solve for ψ in a PoissonExpt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Consider the following Poisson experiment:","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"We start with the dimensions and spatial grids are allocated as follows.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Now lets allocate the inputs for a toy experiment. These medium parameters are used to generate the observed field ψ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n@info \"Medium parameters allocated.\"","category":"page"},{"location":"generated/Poisson/forw/#Acquisition-1","page":"-","title":"Acquisition","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Now, we will generate an acquisition ageometry and allocate a projection matrix ACQ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"ageom=AGeom(mgrid, SSrcs(1), Srcs(1), Recs(30))\nupdate!(ageom, SSrcs(), [0,0], 5, [0,2π])\nupdate!(ageom, Recs(), [0,0], 5, [0,2π])\nACQ=GeoPhyInv.ACQmat(ageom,mgrid);\n@info \"ACQ will be used to project ψ onto receivers.\"","category":"page"},{"location":"generated/Poisson/forw/#Generate-PoissonExpt-and-then-applying-mod!-1","page":"-","title":"Generate PoissonExpt and then applying mod!","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"This will first","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"apply operator A=(Q(xz)) on a field p;\nthen apply ((σ(xz)))^-1 in order to solve for ψ;\nfinally, records ψ at the receiver locations to generate data.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ)\nGeoPhyInv.mod!(paE)","category":"page"},{"location":"generated/Poisson/forw/#Extracting-data-from-Expt-1","page":"-","title":"Extracting data from Expt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"data=paE[:data]\n@info string(\"The dimensions of data are (nt,nr)=\",size(data))","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"EditURL = \"<unknown>/ageom/doc.jl\"","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"using GeoPhyInv\nusing Test\nusing SparseArrays","category":"page"},{"location":"generated/ageom/doc/#Intro-1","page":"AGeom","title":"Intro","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"AGeom","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.AGeom","page":"AGeom","title":"GeoPhyInv.AGeom","text":"AGeom=Vector{AGeomss,1}\n\nAn acquisition geometry, bundled into the mutable AGeom type, has to be specified in order to create any Expt variable. Acquisition has supersources, sources and receivers. For AGeom is a mutable type to define source-receiver geometry.  Each supersource has ns sources that are injected (or active) simultaneously, and  a set of nr receivers to  record.  AGeomss is a subtype for each supersource, therefore: This package provides tools to easily create commonly-used AGeom instances,  after deciding on a spatial grid mgrid for the experiment.\n\nIndexing and Fields\n\nLet ageom be an instance of this type, then fields  can be accessed using:\n\nageom[i] : acquisition for ith supersource\nageom[i].sx : x positions of sources\nageom[i].sz : z positions of sources\nageom[i].rx : x positions of receivers\nageom[i].rz : z positions of receivers\nageom[i].ns : number of sources \nageom[i].nr : number of receivers\n\nageom=AGeom(mgrid, attrib, SSrcs(10), Recs(20))\n\nReturn pre-defined acquisition geometries (with 10 sources and 20 receivers), based on attrib, on an input mesh mgrid. The sources and receivers positions are same for all supersources, and are not placed on the edges of the mesh. Choose attrib::Symbol\n\n=:xwell cross-well acquisition;\n=:surf surface acquisition;\n=:vsp vertical seismic profiling;\n=:rvsp  reverse vertical seismic profiling;\n=:downhole downhole sources and receivers.\n\n\n\n\n\n","category":"type"},{"location":"generated/ageom/doc/#Examples-1","page":"AGeom","title":"Examples","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Lets create a mgrid for the experiment.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Then initialize an acquisition on mgrid.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"Otherwise, initialize with one of the predefined acquisitions.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom=AGeom(mgrid, :xwell, SSrcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"By default, the sources and receivers are randomly placed on the grid. If unsure, test it.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"@test (ageom ∈ mgrid)","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"The source and receiver positions can be updated as desired.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"update!(ageom[1], Srcs(), [0,1], [10,20],);\nupdate!(ageom[1], Recs(), [0,0], [10,20],);\nupdate!(ageom, SSrcs(), [0,1], [10,20], );\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"It is easy to combine supersources. Now ageom2 has 20 supersources.","category":"page"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"ageom2=vcat(ageom, ageom);\nnothing #hide","category":"page"},{"location":"generated/ageom/doc/#Methods-1","page":"AGeom","title":"Methods","text":"","category":"section"},{"location":"generated/ageom/doc/#","page":"AGeom","title":"AGeom","text":"update!(::AGeomss, ::Srcs)\nupdate!(::AGeomss, ::Recs)\nupdate!(::AGeom, ::SSrcs)\nupdate!(::AGeom, ::Recs)\nBase.in(::AGeom, ::AbstractVector{StepRangeLen})\nBase.isequal(::AGeom, ::AGeom)\nSparseArrays.SparseMatrixCSC(::AGeomss,::AbstractVector{StepRangeLen})","category":"page"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss,Srcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Srcs(10), p1, p2)\n\nUpdate source geometry for the first supersource, with 10 sources placed regularly between p1=[z1,x1] and p2=[z2,x2]\n\nupdate!(ageom[2], Srcs(10), p0, rad, angles)\n\nUpdate source geometry for the second supersource, with 10 sources placed equidistant from p0=[z0,x0] given radius rad and angles angles=[0,2pi].\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{AGeomss,Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom[1], Recs(10), args...)\n\nSimilar to updating source positions, but for receivers.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Array{AGeomss,1},SSrcs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, SSrcs(), p1, p2)\nupdate!(ageom, SSrcs(), p0, rad, angles)\n\nUpdate source positions for all supersources. \n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#GeoPhyInv.update!-Tuple{Array{AGeomss,1},Recs}","page":"AGeom","title":"GeoPhyInv.update!","text":"update!(ageom, Recs(), p1, p2)\nupdate!(ageom, Recs(), p0, rad, angles)\n\nUpdate receiver positions for all supersources.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.in-Tuple{Array{AGeomss,1},AbstractArray{StepRangeLen,1}}","page":"AGeom","title":"Base.in","text":"ageom ∈ mgrid\nin(ageom, mgrid)\n\nAssert if all the sources and receivers in AGeom are within bounds of mgrid.\n\n\n\n\n\n","category":"method"},{"location":"generated/ageom/doc/#Base.isequal-Tuple{Array{AGeomss,1},Array{AGeomss,1}}","page":"AGeom","title":"Base.isequal","text":"isequal(ageom1, ageom2)\n\nAssert if ageom1 equals ageom2.\n\n\n\n\n\n","category":"method"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fwi/gradient_accuracy.jl\"","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Test","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"Can perform inversion of synthetic scenarios. First, the seismic data are modeled as in the forward problem. Then the data are used to perform full waveform inversion (FWI). The inverse problem estimates the Earth models and the source and receiver filters that resulted from the data. This task is necessary to test the performance of the inversion algorithm in various geological scenarios using different acquisition parameters.","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"model = Medium(:acou_homo2);\nupdate!(model, [:vp,:rho], randn_perc=1)\n\nmodel0 = Medium(:acou_homo2);\nupdate!(model0, [:vp,:rho], randn_perc=1)\n\nageom=AGeom(model.mgrid, :surf)\nwav, tgrid=ricker(model, 3, 1.0)\nsrcwav=SrcWav(tgrid,ageom,[:P])\nupdate!(srcwav,[:P], wav)\n\nparameterization=[:χvp, :χrho, :null]\n\nmgrid=model.mgrid\n\n@testset \"test parallel implementation during gradient\" begin\n\tfor attrib_mod in [Fdtd(), FdtdBorn()]\n\t\tglobal pa=SeisInvExpt(attrib_mod, Migr(), srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t\t\t\t     modm_obs=model,\n\t\t\t\t     modm0=model0,\n\t\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=300.),mgrid),\n\t\t\t\t     parameterization=parameterization,   verbose=false,\n\t\t\t\t     nworker=1)\n\n\n\t\tglobal pa_parallel=SeisInvExpt(attrib_mod, Migr(), srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t\t\t\t     modm_obs=model,\n\t\t\t\t     modm0=model0,\n\t\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=300.),mgrid),\n\t\t\t\t     parameterization=parameterization,   verbose=false,\n\t\t\t\t     nworker=nothing)\n\n\t\tresult=update!(pa)\n\n\t\tresult_parallel=update!(pa_parallel)\n\n\t\t@test result[2] ≈ result_parallel[2]\n\tend\nend\n\n\n\n@testset \"Testing Born Modeling and its gradient\" begin\n\tglobal expt=x->SeisInvExpt(FdtdBorn(), x,\n\t\t\t     srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t     \t\t     modm0=model0,\n\t\t\t     modm_obs=model,\n\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=350.),mgrid),\n\t\t\t     parameterization=parameterization,   verbose=false)\n\n\tglobal pa=expt(LS())\n\n\n\tupdate!(pa, bounded_flag=true, solver=:ipopt,\n\t\t\tipopt_options=[[\"max_iter\", 0],[\"derivative_test\", \"first-order\"]])\n\tpa=expt(Migr())\n\n\tresult=update!(pa)\n\n\tpa_fd=expt(Migr_FD());\n\tresult_fd=update!(pa_fd)\n\n\tf=Misfits.error_squared_euclidean!(nothing, result[2], result_fd[2], nothing, norm_flag=true)\n\n\t@test f<1e-15\nend\n\n\n@testset \"Testing gradient LS FWI\" begin\n\texpt=x->SeisInvExpt(Fdtd(), x,\n\t\t\t     srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t     \t\t     modm0=model0,\n\t\t\t     modm_obs=model,\n\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=350.),mgrid),\n\t\t\t     parameterization=parameterization,   verbose=false)\n\tpa=expt(LS())\n\n\n\tupdate!(pa, bounded_flag=true, solver=:ipopt,\n\t\t\tipopt_options=[[\"max_iter\", 0],[\"derivative_test\", \"first-order\"]])\n\tpa=expt(Migr())\n\n\tresult=update!(pa)\n\n\tpa_fd=expt(Migr_FD());\n\tresult_fd=update!(pa_fd)\n\n\n\n\tf=Misfits.error_squared_euclidean!(nothing, result[2], result_fd[2], nothing, norm_flag=true)\n\n\t@test f<1e-15\nend","category":"page"},{"location":"fdtd/intro/#","page":"-","title":"-","text":"A forward experiment, where the seismic data are generated using some models and acquisition parameters from our gallery. Forward modeling consists of a finite-difference simulation of the acoustic wave-equation.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Consider the following Poisson experiment:","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"EditURL = \"<unknown>/Poisson/test_born.jl\"","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"The linearized forward modeling operator F and its adjoint (aka Migration operator) are the building blocks of iterative optimization schemes. For the PoissonExpt, we have the functionality to compute F*x without explicitly storing the operator matrix (see LinearMaps.jl). The perturbed field δψ due to a perturbation in σ is given by","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"δψ=-A¹(σ₀)A(δσ)ψ₀","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"where","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"(σ₀(xz)) ψ₀(t)=A(σ₀)ψ₀(t)=f(t)","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"Lets start a tutorial.","category":"page"},{"location":"generated/Poisson/test_born/#Load-some-packages-1","page":"-","title":"Load some packages","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing ProgressMeter\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus\nusing LinearMaps","category":"page"},{"location":"generated/Poisson/test_born/#Setting-up-the-spatial-and-temporal-grids-1","page":"-","title":"Setting up the spatial and temporal grids","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/test_born/#Allocating-medium-parameters-1","page":"-","title":"Allocating medium parameters","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n\nσobs=abs.(randn(nz,nx))\nQobs=abs.(randn(nz,nx))\nnr=10 # number of abstract receivers\nACQ=sprandn(nr,nz*nx,0.6); # choose a random acquisition operator\n@info \"We are ready for the PoissonExpt.\"","category":"page"},{"location":"generated/Poisson/test_born/#Create-an-Expt,-and-then-extract-a-linear-forward-map-out-of-it-1","page":"-","title":"Create an Expt, and then extract a linear forward map out of it","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ, σobs=σobs, Qobs=Qobs,)\nF=LinearMap(paE, σ); # extract the linearized forward operator from `Expt`\nGeoPhyInv.Utils.test_linearmap(F) # finally do some tests on the linearmap","category":"page"},{"location":"generated/Poisson/test_born/#Usage-1","page":"-","title":"Usage","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"δx=randn(size(F,2)) # random model pertubation\nδd=F*δx # corresponding pertubation in data\n@info string(\"Length of data: (nt*nr)=\",length(δd))","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"EditURL = \"https://github.com/TRAVIS_REPO_SLUG/blob/master/\"","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"load packages","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"create simple (almost) homogeneous acoustic model","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"model=J.Gallery.Seismic(:acou_homo1)\nJ.Models.Seismic_addon!(model, randn_perc=0.01)","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"a simple acquisition geometry","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"acqgeom = GeoPhyInv.Gallery.Geom(model.mgrid,:xwell);","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.","category":"page"},{"location":"reference/#Fdtd-1","page":"Fdtd","title":"Fdtd","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"Modules = []\nOrder   = []","category":"page"},{"location":"reference/#Index-1","page":"Fdtd","title":"Index","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"","category":"page"},{"location":"tutorials/page1/#","page":"-","title":"-","text":"FFF FF","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"EditURL = \"<unknown>/data/doc.jl\"","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"using GeoPhyInv\nusing Test\nusing Random","category":"page"},{"location":"generated/data/doc/#Intro-1","page":"Data","title":"Intro","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Data","category":"page"},{"location":"generated/data/doc/#GeoPhyInv.Data","page":"Data","title":"GeoPhyInv.Data","text":"A mutable type that bundles multi-component records at multiple receivers.\n\ndata=Data(tgrid, ageom, [:P, :Vx])\n\n\nHere, we initialized records, of :P and :Vx fields, in time domain for receivers and supersources in ageom.\n\nIndexing\n\ndata[i] : the records due to ith supersource of all fields\ndata[i][:P] : extract field :P \ndata[i][:nr] : number of receivers (same as in ageom)\ndata.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, data can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/data/doc/#Examples-1","page":"Data","title":"Examples","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Need a time grid.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Lets initialize records for :P and :Vz fields.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"data=Data(tgrid, ageom, [:P,:Vz]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Random.randn!(data[3][:P]);\nnothing #hide","category":"page"},{"location":"generated/data/doc/#Methods-1","page":"Data","title":"Methods","text":"","category":"section"},{"location":"generated/data/doc/#","page":"Data","title":"Data","text":"Methods listed for SrcWav can used on instances of Data too.","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fdtd/reuse_expt.jl\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"This tutorial first creates a variable pa, i.e. allocates necessary memory to perform SeisForwExpt. Then, we perform forward modeling using an in-place function mod!. Finally, we will update pa with a different subsurface model and re-run the modeling task with no additional memory allocation. The ability to iteratively run the forward modeling task on various subsurface models is necessary while implementing inversion algorithms.","category":"page"},{"location":"generated/fdtd/reuse_expt/#Load-packages-1","page":"-","title":"Load packages","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics\nusing Plots\nusing Test","category":"page"},{"location":"generated/fdtd/reuse_expt/#Setup-a-spatial-grid-1","page":"-","title":"Setup a spatial grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"zgrid=range(-1000.0,stop=1000.0,length=201)\nxgrid=range(-1000.0,stop=1000.0,length=201)\nmgrid = [zgrid, xgrid]\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))","category":"page"},{"location":"generated/fdtd/reuse_expt/#Allocate-a-Seismic-model,-and-adjust-bounds-1","page":"-","title":"Allocate a Seismic model, and adjust bounds","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"vpb = [1500., 3500.] # bounds for vp\nrhob = [1500., 3500.] # density bounds\n\nmodel=Medium(mgrid)\nupdate!(model, [:vp,:rho], [vpb,rhob])\nfill!(model)\n@info \"a seismic model is created\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#Add-some-noise-to-the-model-(optional)-1","page":"-","title":"Add some noise to the model (optional)","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"update!(model, [:vp,:rho], randn_perc=0.01); # add some random noise\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#A-surface-acquisition-ageometry-1","page":"-","title":"A surface acquisition ageometry","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"ageom=GeoPhyInv.Gallery.AGeom(model.mgrid,:surf, nss=3, nr=30);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Plot-the-model-and-source,-receivers-1","page":"-","title":"Plot the model and source, receivers","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"p1=JP.seismic(model)\nJP.ageom!(ageom)\nplot(p1)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Generate-a-temporal-grid-1","page":"-","title":"Generate a temporal grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"tgrid = range(0.0,stop=2.0,length=1000)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Choose-a-source-wavelet-1","page":"-","title":"Choose a source wavelet","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"wav = GeoPhyInv.Utils.Wavelets.ricker(10.0, tgrid, tpeak=0.25,);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Distribute-the-same-source-wavelet-to-all-the-supsersources-1","page":"-","title":"Distribute the same source wavelet to all the supsersources","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"srcwav=GeoPhyInv.Acquisition.Src_fixed(ageom.nss,1,[:P],wav,tgrid);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"create Fdtd.Param object to prepare forward modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"npw corresponds to the number of independently propagating wavefields (1 in most cases)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"Once the Param object is created, do the modelling \"without any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"pa=SeisForwExpt(npw=1,model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsflags=[2], rflags=[1],\n\ttgridmod=tgrid, verbose=true);\n\n@time GeoPhyInv.Fdtd.mod!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"pdata=plot(pa.c.data[1].d[1,1])\nplot(pdata)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"create new seismic model","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"model_new=J.Gallery.Seismic(:acou_homo1) # prepare another model\nupdate!(model_new, [:vp,:rho], randn_perc=0.01)\nupdate!(model_new, [:vp,:rho], constant_pert=0.03) # perturb the model\np2=JP.seismic(model_new) # plot new model\nJP.ageom!(ageom)\nplot(p2)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"Now, we the change the model in the Param object without memory allocation This routine can be used during FWI, where medium parameters are itertively updated in the same Fdtd.Param object","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"update!(pa, model_new)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"run modelling now and plot data again","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"@time GeoPhyInv.Fdtd.mod!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot!(pdata, pa.c.data[1].d[1,1])\nplot(pdata)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"EditURL = \"<unknown>/media/doc.jl\"","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"using BenchmarkTools\nusing GeoPhyInv\nusing Test\nusing Plots","category":"page"},{"location":"generated/media/doc/#Intro-1","page":"Medium","title":"Intro","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"GeoPhyInv.Medium","category":"page"},{"location":"generated/media/doc/#GeoPhyInv.Medium","page":"Medium","title":"GeoPhyInv.Medium","text":"Mutable type for storing medium parameters.\n\nmod=Medium(mgrid, names=[:vp,:rho])\n\nThis initializes a subsurface model with :vp and :rho parameters. Print the names of the medium parameters stored in mod.\n\nnames(mod)\n\nIndexing\n\nmod.mgrid : returns the spatial-grid bundle\nmod[:vp] : P-wave velocity\nmod[:rho] : mass density\nmod[:Zp] : P-wave impedance \nmod[:K] : bulk modulus \nmod.ref : reference medium parameters \nmod.bounds : bounds of medium parameters\n\n\n\n\n\n","category":"type"},{"location":"generated/media/doc/#Examples-1","page":"Medium","title":"Examples","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To construct a variable to type Medium, the first step is to create a 2-D grid.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Initiate the storage of medium parameters on the grid using","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod = Medium(mgrid);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"By default certain parameters are populated, see","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"names(mod)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To define parameters yourself","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod = Medium(mgrid, [:vp,:rho,:vs])","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Bounds for these parameters should be input for modeling or inversion. Use update!","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"vpb=[2100.,2200.]; vsb=[1500, 1700]; rhob=[2100., 2300.]\nupdate!(mod, [:vp,:vs,:rho], [vpb, vsb, rhob]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To just fill the Medium with average values, just do","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"fill!(mod)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Otherwise, to manually fill in different parameters","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod[:vp].=3000.;\nmod[:vs].=2000.;\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"In order to add random noise to the models","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"update!(mod, [:vp,:rho], randn_perc=1.)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #1","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"p1=plot(mod, [:vp]); savefig(p1,\"p1.png\")","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"(Image: waves)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #2","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"p1=plot(mod, [:vs]); savefig(p1,\"p1.png\")","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"(Image: waves)","category":"page"},{"location":"generated/media/doc/#Methods-1","page":"Medium","title":"Methods","text":"","category":"section"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Base.getindex(::Medium, ::Symbol)\nGeoPhyInv.update!(::GeoPhyInv.Medium, ::Vector{Symbol},)\nBase.copyto!(x::AbstractArray, mod::Medium, fields::Vector{Symbol})\nBase.vec(mod::Medium, ::Symbol)","category":"page"},{"location":"generated/media/doc/#Base.getindex-Tuple{Medium,Symbol}","page":"Medium","title":"Base.getindex","text":"Get other dependent model parameters of a seismic model that are not present in Seismic.\n\n:rhoI : inverse of density\n:Zp : P-wave impedance\n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#GeoPhyInv.update!-Tuple{Medium,Array{Symbol,1}}","page":"Medium","title":"GeoPhyInv.update!","text":"In-place method to add features to the input model.\n\nArguments\n\nmod::Medium : model that is modified\n\nKeyword Arguments\n\npoint_loc::Vector{Float64}=[0., 0.,] : approx location of point pert\npoint_pert::Float64=0.0 : perturbation at the point scatterer\nellip_loc::Vector{Float64}=nothing : location of center of perturbation, [z, x]\nellip_rad::Float64=0.0 : size of elliptic perturbation\nellip_pert::Float64=0.1 : perturbation inside the ellipse\nellip_α=0.0 : rotate the ellipse\nrect_loc::Array{Float64}=nothing : rectangle location, [zmin, xmin, zmax, xmax]\nrect_pert::Float64=0.1 : perturbation in a rectangle\nconstant_pert::Float64=0.0 : constant perturbation \nrandn_pert::Float64=0.0 : percentage of reference values for additive random noise\nfields::Vector{Symbol}=[:χvp,:χrho,:χvs] : which fields are to be modified?\nonlyin : mod is modified only when field values are in these ranges \n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Base.copyto!-Tuple{AbstractArray,Medium,Array{Symbol,1}}","page":"Medium","title":"Base.copyto!","text":"Copy medium parameters from Medium mod, to vector x. Return x. copyto!(x,mod,[:vp])\n\n\n\n\n\n","category":"method"},{"location":"generated/media/doc/#Base.vec-Tuple{Medium,Symbol}","page":"Medium","title":"Base.vec","text":"Return a vector of medium parameters x, from Medium mod. x=vec(mod)\n\n\n\n\n\n","category":"method"},{"location":"tut/#","page":"-","title":"-","text":"Tutorials in a seperate repo.","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fwi/born_map.jl\"","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"using Test\nusing GeoPhyInv\nusing LinearMaps","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"he linearized forward modeling operator F, such that Fx can be computed without explicitly storing the operator matrix (  see LinearMaps.jl); the imaging/migration operator F*;","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"These maps are the building blocks of iterative optimization schemes.","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"for scenario in [:downhole, :pizza]\n\tprintln(\"@@@@@@@@@@@@TESTING \", scenario)\n\tfor rfields in [[:P], [:Vx], [:Vz]]\n\t\tpa=SeisInvExpt(FdtdBorn(), LS(), scenario, rfields=rfields)\n\n\n\t\tF=LinearMap(pa);\n\n\t\tx1=randn(size(F,2))\n\t\tx2=randn(size(F,2))\n\t\tx12=x1.+x2\n\n\n\t\td12=F*x12\n\t\td1=F*x1\n\t\tδmodtt1=copy(pa.paf.c.δmodtt)\n\t\td2=F*x2\n\t\tδmodtt2=copy(pa.paf.c.δmodtt)\n\n\n\t\td12new=d1.+d2\n\n\t\tf=Misfits.error_squared_euclidean!(nothing, d12, d12new, nothing, norm_flag=true)\n\n\t\t@test f<1e-25\n\n\n\t\tfunction adjtest()\n\t\t\tx=randn(size(F,2))\n\t\t\ty=randn(size(F,1))\n\t\t\ta=LinearAlgebra.dot(y,F*x)\n\t\t\tb=LinearAlgebra.dot(x,adjoint(F)*y)\n\t\t\tc=LinearAlgebra.dot(x, transpose(F)*F*x)\n\t\t\tprintln(\"adjoint test: \", a, \"\\t\", b)\n\t\t\t@test isapprox(a,b,rtol=1e-5)\n\t\t\tprintln(\"must be positive: \", c)\n\t\t\t@test c>0.0\n\t\tend\n\n\n\t\tfor i in 1:3\n\t\t\tadjtest()\n\t\tend\n\tend\nend","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"EditURL = \"<unknown>/srcwav/doc.jl\"","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"using GeoPhyInv\nusing LinearAlgebra\nusing Random","category":"page"},{"location":"generated/srcwav/doc/#Intro-1","page":"SrcWav","title":"Intro","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"SrcWav","category":"page"},{"location":"generated/srcwav/doc/#GeoPhyInv.SrcWav","page":"SrcWav","title":"GeoPhyInv.SrcWav","text":"A mutable type that bundles multi-component source wavelets. \n\nsrcwav=SrcWav(tgrid, ageom, [:P, :Vx])\n\n\nHere, we initialized wavelets, for :P and :Vx fields, in time domain for sources and supersources in ageom.\n\nIndexing\n\nsrcwav[i] : wavelets for ith supersource of all fields\nsrcwav[i][:P] : extract field :P \nsrcwav[i][:ns] : number of sources (same as in ageom)\nsrcwav.grid : returns tgrid \n\nAs mutable objects in Julia are like containers that might hold different values over time, srcwav can be modified.\n\n\n\n\n\n","category":"type"},{"location":"generated/srcwav/doc/#Examples-1","page":"SrcWav","title":"Examples","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Define an acquisition geometry.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10));\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Need a time grid.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"tgrid=range(0, stop=1.0, step=0.1);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Lets initialize records for :P field.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"srcwav=SrcWav(tgrid, ageom, [:P]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Fill the :P field of 3rd supersource with random numbers.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Random.randn!(srcwav[3][:P]);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Often we want to populate the same source wavelet to all the supersources and sources.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"x=randn(length(tgrid));\nupdate!(srcwav, [:P,], x);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Populate two different wavelets for first and second supersources.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"x1=randn(length(tgrid));\nx2=randn(length(tgrid));\nupdate!(srcwav[1], [:P,], x1);\nupdate!(srcwav[2], [:P,], x2);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Scale srcwav by a scalar overwriting it in-place.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"rmul!(srcwav, 2.0);\nnothing #hide","category":"page"},{"location":"generated/srcwav/doc/#Methods-1","page":"SrcWav","title":"Methods","text":"","category":"section"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"Most of the methods listed below are also applicable to individual elements of srcwav.","category":"page"},{"location":"generated/srcwav/doc/#","page":"SrcWav","title":"SrcWav","text":"update!(GeoPhyInv.VNamedD, ::Vector{Symbol}, ::AbstractVector{Float64},)\nBase.reverse!(::GeoPhyInv.VNamedD)\nBase.iszero(::GeoPhyInv.VNamedD)\nBase.isequal(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nissimilar(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.vec(::GeoPhyInv.VNamedD)\nRandom.randn!(::GeoPhyInv.VNamedD)\nBase.fill!(::GeoPhyInv.VNamedD, ::Float64)\nLinearAlgebra.dot(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nLinearAlgebra.rmul!(::GeoPhyInv.VNamedD, ::Number)\nBase.copyto!(::GeoPhyInv.VNamedD, ::GeoPhyInv.VNamedD)\nBase.copyto!(::AbstractVector{Float64}, ::GeoPhyInv.VNamedD)\nBase.copyto!(::GeoPhyInv.VNamedD, ::AbstractVector{Float64})","category":"page"},{"location":"generated/srcwav/doc/#Base.iszero-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.iszero","text":"iszero(srcwav)\n\nReturns bool if srcwav has all zeros.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.isequal-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.isequal","text":"isequal(srcwav1, srcwav2)\n\nAssert if srcwav1 and srcwav2 are equal.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.vec-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.vec","text":"v=vec(srcwav)\nReshape `srcwav` as a one-dimensional column vector.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(srcwav1, srcwav2)\n\nCopy srcwav2 to srcwav1, which has same size.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{AbstractArray{Float64,1},Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}}}","page":"SrcWav","title":"Base.copyto!","text":"copyto!(v, srcwav)\n\nSame as vec(srcwav), but in-place operation.\n\n\n\n\n\n","category":"method"},{"location":"generated/srcwav/doc/#Base.copyto!-Tuple{Union{Array{NamedD{Recs},1}, Array{NamedD{Srcs},1}},AbstractArray{Float64,1}}","page":"SrcWav","title":"Base.copyto!","text":"v=vec(srcwav) \nrandn!(v)\ncopyto!(srcwav, v)\n\nCopy v to srcwav. The sizes of the two objects much match. No memory allocations.\n\n\n\n\n\n","category":"method"},{"location":"#The-Expt-Datatypes-1","page":"Home","title":"The Expt Datatypes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The methods in this package numerically solve some differential equations commonly faced in geophysical inverse problems. The functionality of this package revolves around the mutable Expt types. Julia's multiple dispatch is used to overload Base methods whenever possible.  Which means, if one is familiar with the Base methods of Julia, then (almost) no additional syntax is required  to use this package.  While performing a given experiment, firstly, most of the memory necessary is allocated while creating the Expt variables. Then these variables are input to in-place functions  (e.g., update!)  which as per Julia convention ends with an exclamation mark, to actually perform the experiment task. For example, the current Expt types within the realm of this package include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SeisForwExpt is the seismic (acoustic) forward modeling experiment;\nSeisInvExpt is the type for seismic inversion experiment, including migration;\nPoissonExpt is type for the solving the Poisson experiment.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Some of the commonly used (and exported) mutable types to create the Expt variables are:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Medium for bundling medium parameters together;\nAGeom stores acquisition geometry related parameters;\nSrcWav allocates source signals input to an experiment;\nData allocated the output records that are fitted during inversion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get started, as an example, simply load a seismic inversion experiment already defined in our package gallery into REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GeoPhyInv # load package (after installation)\npa=SeisInvExpt(Fdtd(), LS(), :pizza); # \"pizza\" is the name of the experiment","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then, simply use update! to perform least-squares inversion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"update!(pa)","category":"page"},{"location":"#Grids-1","page":"Home","title":"Grids","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It is necessary to input the evenly-spaced spatial and temporal grids while creating the Expt variables. These grids can be simply created using Base.range in Julia, as shown below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"zgrid=range(0,stop=1000.0,length=201) # create vertical grid from 0 to 1000 m\nxgrid=range(0,stop=1000.0,length=201) # create horizontal grid\nmgrid=[zgrid, xgrid] # spatial-grid bundle\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))\ntgrid=range(0,stop=1.0,step=0.001) # a temporal grid from 0 to 1.0 s","category":"page"}]
}
