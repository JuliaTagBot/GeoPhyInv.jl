var documenterSearchIndex = {"docs":
[{"location":"generated/ageom/gallery/#","page":"The AGeom Datatype","title":"The AGeom Datatype","text":"EditURL = \"<unknown>/ageom/gallery.jl\"","category":"page"},{"location":"generated/ageom/gallery/#The-AGeom-Datatype-1","page":"The AGeom Datatype","title":"The AGeom Datatype","text":"","category":"section"},{"location":"generated/ageom/gallery/#","page":"The AGeom Datatype","title":"The AGeom Datatype","text":"An acquisition ageometry, bundled into the mutable AGeom type, has to be specified in order to create an Expt variable. Acquisiton has supersources, sources and receivers. Each supersource has ns multiple sources that are injected (or active) simultaneously. For each supersource, a set of nr receivers are recording waves. This package provides tools to easily create commonly-used AGeom variables, after deciding on a spatial grid mgrid for the experiment.","category":"page"},{"location":"generated/ageom/gallery/#Load-packages-1","page":"The AGeom Datatype","title":"Load packages","text":"","category":"section"},{"location":"generated/ageom/gallery/#","page":"The AGeom Datatype","title":"The AGeom Datatype","text":"using GeoPhyInv","category":"page"},{"location":"generated/ageom/gallery/#A-surface-acquisition-1","page":"The AGeom Datatype","title":"A surface acquisition","text":"","category":"section"},{"location":"generated/ageom/gallery/#","page":"The AGeom Datatype","title":"The AGeom Datatype","text":"mgrid=repeat(range(-1000.0,stop=1000.0,length=201), 2) # test spatial grid\n#ageom_surf=GeoPhyInv.Gallery.AGeom(mgrid,:surf,nss=5,nr=30);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fdtd/create_snaps.jl\"","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"We aim to save the snapshots, at given time steps in SeisForwExpt.","category":"page"},{"location":"generated/fdtd/create_snaps/#Loading-some-packages-1","page":"-","title":"Loading some packages","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics\nusing Gadfly","category":"page"},{"location":"generated/fdtd/create_snaps/#Setting-up-the-variables-necessary-to-create-the-Expt-1","page":"-","title":"Setting up the variables necessary to create the Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"model=Medium(:acou_homo1); # load a simple homogeneous acoustic model from the gallery\nupdate!(model, [:vp,:rho], randn_perc=0.1); # add some random noise to the model\nageom=AGeom(model.mgrid,:xwell, SSrcs(2)); # load a simple acquisition ageometry using `mgrid` of the seismic model\ntgrid = range(0.0,stop=2.0,length=2000) # generate a time grid\nwav = ricker(10.0, tgrid, tpeak=0.25,); # ricker wavelet\n\nsrcwav = SrcWav(tgrid, ageom, [:P])\nupdate!(srcwav, [:P], wav)\n@info \"We are ready for the modeling.\"","category":"page"},{"location":"generated/fdtd/create_snaps/#Final-step-1","page":"-","title":"Final step","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"One can plot the model, source and receivers using these commands: using Plots; p1=JP.seismic(model); JP.ageom!(ageom); plot(p1); Now we have all the required variables to create SeisForwExpt object and prepare the forward modelling. While creating, we switched the snaps_flag on, and instructed recording field at tsnaps. Once the Expt object is created, do the modelling \"without approximately any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"paE=SeisForwExpt(Fdtd(),model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsnaps_flag=true,\n\ttsnaps=[0.3, 0.4, 0.5],\n\ttgridmod=tgrid, verbose=true);\n\n@time update!(paE);\nnothing #hide","category":"page"},{"location":"generated/fdtd/create_snaps/#Extracting-snaps-from-Expt-1","page":"-","title":"Extracting snaps from Expt","text":"","category":"section"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"snaps=paE[:snaps,1]; # extracting snaps of the first supersource\nsnaps=paE[:snaps,2]; # second supersource\n@info string(\"The dimensions of the snaps are (nz,nx,nt)=\", size(snaps))","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"We can now plot snapshots using these commands:","category":"page"},{"location":"generated/fdtd/create_snaps/#","page":"-","title":"-","text":"p=[]\n#Gadfly.set_default_plot_size(20cm, 5cm)\nfor ii in 1:3\n#\tpush!(p, spy(snaps[:,:,ii], Guide.xlabel(\"x\"), Guide.ylabel(\"z\")))\nend\n#hstack(p...)","category":"page"},{"location":"contributing/#Coding-Conventions-1","page":"-","title":"Coding Conventions","text":"","category":"section"},{"location":"contributing/#","page":"-","title":"-","text":"This software is organised into various modules. Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  distance = velocity * time is prefered over using  a = b * c in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation (Image: guide)","category":"page"},{"location":"contributing/#","page":"-","title":"-","text":"The methods ending with ! ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"EditURL = \"<unknown>/Poisson/forw.jl\"","category":"page"},{"location":"generated/Poisson/forw/#Loading-some-packages-1","page":"-","title":"Loading some packages","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing ProgressMeter\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus","category":"page"},{"location":"generated/Poisson/forw/#Solve-for-ψ-in-a-PoissonExpt-1","page":"-","title":"Solve for ψ in a PoissonExpt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Consider the following Poisson experiment:","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"We start with the dimensions and spatial grids are allocated as follows.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Now lets allocate the inputs for a toy experiment. These medium parameters are used to generate the observed field ψ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n@info \"Medium parameters allocated.\"","category":"page"},{"location":"generated/Poisson/forw/#Acquisition-1","page":"-","title":"Acquisition","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"Now, we will generate an acquisition ageometry and allocate a projection matrix ACQ.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"ageom=AGeom(mgrid, SSrcs(1), Srcs(1), Recs(30))\nupdate!(ageom, SSrcs(), [0,0], 5, [0,2π])\nupdate!(ageom, Recs(), [0,0], 5, [0,2π])\nACQ=GeoPhyInv.ACQmat(ageom,mgrid);\n@info \"ACQ will be used to project ψ onto receivers.\"","category":"page"},{"location":"generated/Poisson/forw/#Generate-PoissonExpt-and-then-applying-mod!-1","page":"-","title":"Generate PoissonExpt and then applying mod!","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"This will first","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"apply operator A=(Q(xz)) on a field p;\nthen apply ((σ(xz)))^-1 in order to solve for ψ;\nfinally, records ψ at the receiver locations to generate data.","category":"page"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ)\nGeoPhyInv.mod!(paE)","category":"page"},{"location":"generated/Poisson/forw/#Extracting-data-from-Expt-1","page":"-","title":"Extracting data from Expt","text":"","category":"section"},{"location":"generated/Poisson/forw/#","page":"-","title":"-","text":"data=paE[:data]\n@info string(\"The dimensions of data are (nt,nr)=\",size(data))","category":"page"},{"location":"generated/ageom/doc/#","page":"-","title":"-","text":"EditURL = \"<unknown>/ageom/doc.jl\"","category":"page"},{"location":"generated/ageom/doc/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Test\n\n#AGeom in mgrid","category":"page"},{"location":"generated/ageom/doc/#","page":"-","title":"-","text":"To construct a variable to type Medium, the first step is to create a 2-D grid","category":"page"},{"location":"generated/ageom/doc/#","page":"-","title":"-","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\n\n\nageom=AGeom(mgrid, SSrcs(10), Srcs(10), Recs(10))\n@test (ageom ∈ mgrid)\n\nupdate!(ageom[1], Recs(), [0,1], [10,20],)\nupdate!(ageom[1], Srcs(), [0,1], [10,20],)\nupdate!(ageom, SSrcs(), [0,1], [10,20], )\nupdate!(ageom, SSrcs(), [0,1], [10,20], )\n\n\nageom2=vcat(ageom, ageom)\n\n\nageom2=deepcopy(ageom)\n@test isequal(ageom,ageom2)","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fwi/gradient_accuracy.jl\"","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Test","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"Can perform inversion of synthetic scenarios. First, the seismic data are modeled as in the forward problem. Then the data are used to perform full waveform inversion (FWI). The inverse problem estimates the Earth models and the source and receiver filters that resulted from the data. This task is necessary to test the performance of the inversion algorithm in various geological scenarios using different acquisition parameters.","category":"page"},{"location":"generated/fwi/gradient_accuracy/#","page":"-","title":"-","text":"model = Medium(:acou_homo2);\nupdate!(model, [:vp,:rho], randn_perc=1)\n\nmodel0 = Medium(:acou_homo2);\nupdate!(model0, [:vp,:rho], randn_perc=1)\n\nageom=AGeom(model.mgrid, :surf)\nwav, tgrid=ricker(model, 3, 1.0)\nsrcwav=SrcWav(tgrid,ageom,[:P])\nupdate!(srcwav,[:P], wav)\n\nparameterization=[:χvp, :χrho, :null]\n\nmgrid=model.mgrid\n\n@testset \"test parallel implementation during gradient\" begin\n\tfor attrib_mod in [Fdtd(), FdtdBorn()]\n\t\tpa=SeisInvExpt(attrib_mod, Migr(), srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t\t\t\t     modm_obs=model,\n\t\t\t\t     modm0=model0,\n\t\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=300.),mgrid),\n\t\t\t\t     parameterization=parameterization,   verbose=false,\n\t\t\t\t     nworker=1)\n\n\n\t\tpa_parallel=SeisInvExpt(attrib_mod, Migr(), srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t\t\t\t     modm_obs=model,\n\t\t\t\t     modm0=model0,\n\t\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=300.),mgrid),\n\t\t\t\t     parameterization=parameterization,   verbose=false,\n\t\t\t\t     nworker=nothing)\n\n\t\tresult=update!(pa)\n\n\t\tresult_parallel=update!(pa_parallel)\n\n\t\t@test result[2] ≈ result_parallel[2]\n\tend\nend\n\n\n\n@testset \"Testing Born Modeling and its gradient\" begin\n\texpt=x->SeisInvExpt(FdtdBorn(), x,\n\t\t\t     srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t     \t\t     modm0=model0,\n\t\t\t     modm_obs=model,\n\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=350.),mgrid),\n\t\t\t     parameterization=parameterization,   verbose=false)\n\n\tpa=expt(LS())\n\n\n\tupdate!(pa, bounded_flag=true, solver=:ipopt,\n\t\t\tipopt_options=[[\"max_iter\", 0],[\"derivative_test\", \"first-order\"]])\n\tpa=expt(Migr())\n\n\tresult=update!(pa)\n\n\tpa_fd=expt(Migr_FD());\n\tresult_fd=update!(pa_fd)\n\n\tf=Misfits.error_squared_euclidean!(nothing, result[2], result_fd[2], nothing, norm_flag=true)\n\n\t@test f<1e-15\nend\n\n\n@testset \"Testing gradient LS FWI\" begin\n\texpt=x->SeisInvExpt(Fdtd(), x,\n\t\t\t     srcwav=srcwav, ageom=ageom, tgrid=tgrid, modm=model0,\n\t     \t\t     modm0=model0,\n\t\t\t     modm_obs=model,\n\t\t\t     igrid_interp_scheme=:B2,\n\t\t\t     igrid=broadcast(x->range(x[1],stop=x[end],step=350.),mgrid),\n\t\t\t     parameterization=parameterization,   verbose=false)\n\tpa=expt(LS())\n\n\n\tupdate!(pa, bounded_flag=true, solver=:ipopt,\n\t\t\tipopt_options=[[\"max_iter\", 0],[\"derivative_test\", \"first-order\"]])\n\tpa=expt(Migr())\n\n\tresult=update!(pa)\n\n\tpa_fd=expt(Migr_FD());\n\tresult_fd=update!(pa_fd)\n\n\n\n\tf=Misfits.error_squared_euclidean!(nothing, result[2], result_fd[2], nothing, norm_flag=true)\n\n\t@test f<1e-15\nend","category":"page"},{"location":"fdtd/intro/#","page":"-","title":"-","text":"A forward experiment, where the seismic data are generated using some models and acquisition parameters from our gallery. Forward modeling consists of a finite-difference simulation of the acoustic wave-equation.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Consider the following Poisson experiment:","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Q = k * Q_v  η","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"EditURL = \"<unknown>/Poisson/test_born.jl\"","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"The linearized forward modeling operator F and its adjoint (aka Migration operator) are the building blocks of iterative optimization schemes. For the PoissonExpt, we have the functionality to compute F*x without explicitly storing the operator matrix (see LinearMaps.jl). The perturbed field δψ due to a perturbation in σ is given by","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"δψ=-A¹(σ₀)A(δσ)ψ₀","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"where","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"(σ₀(xz)) ψ₀(t)=A(σ₀)ψ₀(t)=f(t)","category":"page"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"Lets start a tutorial.","category":"page"},{"location":"generated/Poisson/test_born/#Load-some-packages-1","page":"-","title":"Load some packages","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"using GeoPhyInv\nusing SparseArrays\nusing StatsBase\nusing LinearAlgebra\nusing Random\nusing ProgressMeter\nusing LinearAlgebra\nusing Test\nusing ForwardDiff\nusing Calculus\nusing LinearMaps","category":"page"},{"location":"generated/Poisson/test_born/#Setting-up-the-spatial-and-temporal-grids-1","page":"-","title":"Setting up the spatial and temporal grids","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"nx=21\nnz=21\nnt=4\nnznx=nz*nx\nmgrid=[range(-div(nz,2), step=1.0, length=nz), range(-div(nx,2), step=1.0, length=nx)]\ntgrid=range(0.0,step=0.5, length=nt)\n@info \"Grids are all set.\"","category":"page"},{"location":"generated/Poisson/test_born/#Allocating-medium-parameters-1","page":"-","title":"Allocating medium parameters","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"Qv=abs.(randn(nz,nx))\nη=abs.(randn(nz,nx))\nk=abs.(randn(nz,nx))\nσ=abs.(randn(nz,nx))\np=randn(nz,nx,nt)\n\nσobs=abs.(randn(nz,nx))\nQobs=abs.(randn(nz,nx))\nnr=10 # number of abstract receivers\nACQ=sprandn(nr,nz*nx,0.6); # choose a random acquisition operator\n@info \"We are ready for the PoissonExpt.\"","category":"page"},{"location":"generated/Poisson/test_born/#Create-an-Expt,-and-then-extract-a-linear-forward-map-out-of-it-1","page":"-","title":"Create an Expt, and then extract a linear forward map out of it","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"paE=PoissonExpt(p, tgrid, mgrid, Qv, k, η, σ, ACQ, σobs=σobs, Qobs=Qobs,)\nF=LinearMap(paE, σ); # extract the linearized forward operator from `Expt`\nGeoPhyInv.Utils.test_linearmap(F) # finally do some tests on the linearmap","category":"page"},{"location":"generated/Poisson/test_born/#Usage-1","page":"-","title":"Usage","text":"","category":"section"},{"location":"generated/Poisson/test_born/#","page":"-","title":"-","text":"δx=randn(size(F,2)) # random model pertubation\nδd=F*δx # corresponding pertubation in data\n@info string(\"Length of data: (nt*nr)=\",length(δd))","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"EditURL = \"https://github.com/TRAVIS_REPO_SLUG/blob/master/\"","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"load packages","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"create simple (almost) homogeneous acoustic model","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"model=J.Gallery.Seismic(:acou_homo1)\nJ.Models.Seismic_addon!(model, randn_perc=0.01)","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"a simple acquisition geometry","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"acqgeom = GeoPhyInv.Gallery.Geom(model.mgrid,:xwell);","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.","category":"page"},{"location":"reference/#Fdtd-1","page":"Fdtd","title":"Fdtd","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"Modules = []\nOrder   = []","category":"page"},{"location":"reference/#Index-1","page":"Fdtd","title":"Index","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"","category":"page"},{"location":"tutorials/page1/#","page":"-","title":"-","text":"FFF FF","category":"page"},{"location":"generated/data/doc/#","page":"-","title":"-","text":"EditURL = \"<unknown>/data/doc.jl\"","category":"page"},{"location":"generated/data/doc/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Test","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fdtd/reuse_expt.jl\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"This tutorial first creates a variable pa, i.e. allocates necessary memory to perform SeisForwExpt. Then, we perform forward modeling using an in-place function mod!. Finally, we will update pa with a different subsurface model and re-run the modeling task with no additional memory allocation. The ability to iteratively run the forward modeling task on various subsurface models is necessary while implementing inversion algorithms.","category":"page"},{"location":"generated/fdtd/reuse_expt/#Load-packages-1","page":"-","title":"Load packages","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics\nusing Plots\nusing Test","category":"page"},{"location":"generated/fdtd/reuse_expt/#Setup-a-spatial-grid-1","page":"-","title":"Setup a spatial grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"zgrid=range(-1000.0,stop=1000.0,length=201)\nxgrid=range(-1000.0,stop=1000.0,length=201)\nmgrid = [zgrid, xgrid]\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))","category":"page"},{"location":"generated/fdtd/reuse_expt/#Allocate-a-Seismic-model,-and-adjust-bounds-1","page":"-","title":"Allocate a Seismic model, and adjust bounds","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"vpb = [1500., 3500.] # bounds for vp\nrhob = [1500., 3500.] # density bounds\n\nmodel=Medium(mgrid)\nupdate!(model, [:vp,:rho], [vpb,rhob])\nfill!(model)\n@info \"a seismic model is created\"","category":"page"},{"location":"generated/fdtd/reuse_expt/#Add-some-noise-to-the-model-(optional)-1","page":"-","title":"Add some noise to the model (optional)","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"update!(model, [:vp,:rho], randn_perc=0.01); # add some random noise\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#A-surface-acquisition-ageometry-1","page":"-","title":"A surface acquisition ageometry","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"ageom=GeoPhyInv.Gallery.AGeom(model.mgrid,:surf, nss=3, nr=30);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Plot-the-model-and-source,-receivers-1","page":"-","title":"Plot the model and source, receivers","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"p1=JP.seismic(model)\nJP.ageom!(ageom)\nplot(p1)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Generate-a-temporal-grid-1","page":"-","title":"Generate a temporal grid","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"tgrid = range(0.0,stop=2.0,length=1000)","category":"page"},{"location":"generated/fdtd/reuse_expt/#Choose-a-source-wavelet-1","page":"-","title":"Choose a source wavelet","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"wav = GeoPhyInv.Utils.Wavelets.ricker(10.0, tgrid, tpeak=0.25,);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#Distribute-the-same-source-wavelet-to-all-the-supsersources-1","page":"-","title":"Distribute the same source wavelet to all the supsersources","text":"","category":"section"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"srcwav=GeoPhyInv.Acquisition.Src_fixed(ageom.nss,1,[:P],wav,tgrid);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"create Fdtd.Param object to prepare forward modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"npw corresponds to the number of independently propagating wavefields (1 in most cases)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"Once the Param object is created, do the modelling \"without any memory allocations\" using mod!","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"pa=SeisForwExpt(npw=1,model=model,\n\tageom=[ageom], srcwav=[srcwav],\n\tsflags=[2], rflags=[1],\n\ttgridmod=tgrid, verbose=true);\n\n@time GeoPhyInv.Fdtd.mod!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"pdata=plot(pa.c.data[1].d[1,1])\nplot(pdata)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"create new seismic model","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"model_new=J.Gallery.Seismic(:acou_homo1) # prepare another model\nupdate!(model_new, [:vp,:rho], randn_perc=0.01)\nupdate!(model_new, [:vp,:rho], constant_pert=0.03) # perturb the model\np2=JP.seismic(model_new) # plot new model\nJP.ageom!(ageom)\nplot(p2)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"Now, we the change the model in the Param object without memory allocation This routine can be used during FWI, where medium parameters are itertively updated in the same Fdtd.Param object","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"update!(pa, model_new)","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"run modelling now and plot data again","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"@time GeoPhyInv.Fdtd.mod!(pa);\nnothing #hide","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot a record after modelling","category":"page"},{"location":"generated/fdtd/reuse_expt/#","page":"-","title":"-","text":"plot!(pdata, pa.c.data[1].d[1,1])\nplot(pdata)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"EditURL = \"<unknown>/media/doc.jl\"","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"using BenchmarkTools\nusing GeoPhyInv\nusing Test\nusing Plots","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To construct a variable to type Medium, the first step is to create a 2-D grid.","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mgrid = [range(0.0, stop=10.,step=0.1), range(0.0, stop=30.,step=0.2)];\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Initiate the storage of medium parameters on the grid using","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod = Medium(mgrid);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"By default certain parameters are populated, see","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"names(mod)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To define parameters yourself","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod = Medium(mgrid, [:vp,:rho,:vs])","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Bounds for these parameters should be input for modeling or inversion. Use update!","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"vpb=[2100.,2200.]; vsb=[1500, 1700]; rhob=[2100., 2300.]\nupdate!(mod, [:vp,:vs,:rho], [vpb, vsb, rhob]);\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"To just fill the Medium with average values, just do","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"fill!(mod)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Otherwise, to manually fill in different parameters","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"mod[:vp].=3000.;\nmod[:vs].=2000.;\nnothing #hide","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"In order to add random noise to the models","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"update!(mod, [:vp,:rho], randn_perc=1.)","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #1","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"plot(mod, [:vp])","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"Some plotting #2","category":"page"},{"location":"generated/media/doc/#","page":"Medium","title":"Medium","text":"plot(mod, [:vs])","category":"page"},{"location":"tut/#","page":"-","title":"-","text":"Tutorials in a seperate repo.","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"EditURL = \"<unknown>/fwi/born_map.jl\"","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"using Test\nusing GeoPhyInv\nusing LinearMaps","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"he linearized forward modeling operator F, such that Fx can be computed without explicitly storing the operator matrix (  see LinearMaps.jl); the imaging/migration operator F*;","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"These maps are the building blocks of iterative optimization schemes.","category":"page"},{"location":"generated/fwi/born_map/#","page":"-","title":"-","text":"for scenario in [:downhole, :pizza]\n\tprintln(\"@@@@@@@@@@@@TESTING \", scenario)\n\tfor rfields in [[:P], [:Vx], [:Vz]]\n\t\tpa=SeisInvExpt(FdtdBorn(), LS(), scenario, rfields=rfields)\n\n\n\t\tF=LinearMap(pa);\n\n\t\tx1=randn(size(F,2))\n\t\tx2=randn(size(F,2))\n\t\tx12=x1.+x2\n\n\n\t\td12=F*x12\n\t\td1=F*x1\n\t\tδmodtt1=copy(pa.paf.c.δmodtt)\n\t\td2=F*x2\n\t\tδmodtt2=copy(pa.paf.c.δmodtt)\n\n\n\t\td12new=d1.+d2\n\n\t\tf=Misfits.error_squared_euclidean!(nothing, d12, d12new, nothing, norm_flag=true)\n\n\t\t@test f<1e-25\n\n\n\t\tfunction adjtest()\n\t\t\tx=randn(size(F,2))\n\t\t\ty=randn(size(F,1))\n\t\t\ta=LinearAlgebra.dot(y,F*x)\n\t\t\tb=LinearAlgebra.dot(x,adjoint(F)*y)\n\t\t\tc=LinearAlgebra.dot(x, transpose(F)*F*x)\n\t\t\tprintln(\"adjoint test: \", a, \"\\t\", b)\n\t\t\t@test isapprox(a,b,rtol=1e-5)\n\t\t\tprintln(\"must be positive: \", c)\n\t\t\t@test c>0.0\n\t\tend\n\n\n\t\tfor i in 1:3\n\t\t\tadjtest()\n\t\tend\n\tend\nend","category":"page"},{"location":"generated/srcwav/doc/#","page":"-","title":"-","text":"EditURL = \"<unknown>/srcwav/doc.jl\"","category":"page"},{"location":"generated/srcwav/doc/#","page":"-","title":"-","text":"using GeoPhyInv","category":"page"},{"location":"#The-Expt-Datatypes-1","page":"Home","title":"The Expt Datatypes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The methods in this package numerically solve some differential equations commonly faced in geophysical inverse problems. The functionality of this package revolves around the mutable Expt types. Julia's multiple dispatch is used to overload Base methods whenever possible.  Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as multiple dispatch. Firstly, most of the memory necessary to perform a given experiment is allocated while creating the Expt variables. Then these variables are input to in-place functions  (e.g., mod!)  which as per Julia convention ends with an exclamation mark, to actually perform the experiment task. For example, the current Expt types within the realm of this package include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SeisForwExpt is the seismic (acoustic) forward modeling experiment  ;\nSeisInvExpt is the type for seismic inversion experiment, including migration;\nPoissonExpt is type for the solving the Poisson experiment.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get started, as an example, simply load a seismic inversion experiment already defined in our package gallery into REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GeoPhyInv # load GIPh (after installation)\npaE=GIPh.Gallery.SeisInvExpt(:pizza); # \"pizza\" is the name of the experiment","category":"page"},{"location":"#Grids-1","page":"Home","title":"Grids","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It is necessary to input the evenly-spaced spatial and temporal grids while creating the Expt variables. These grids can be simply created using Base.range in Julia, as shown below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"zgrid=range(0,stop=1000.0,length=201) # create vertical grid from 0 to 1000 m\nxgrid=range(0,stop=1000.0,length=201) # create horizontal grid\nmgrid=[zgrid, xgrid] # spatial-grid bundle\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))\ntgrid=range(0,stop=1.0,step=0.001) # a temporal grid from 0 to 1.0 s","category":"page"}]
}
