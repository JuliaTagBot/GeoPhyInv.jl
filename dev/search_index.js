var documenterSearchIndex = {"docs":
[{"location":"fdtd/intro/#","page":"-","title":"-","text":"A forward experiment, where the seismic data are generated using some models and acquisition parameters from our gallery. Forward modeling consists of a finite-difference simulation of the acoustic wave-equation.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. Current implementation assumes Neumann boundary conditions at all the boundaries.","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Consider the following Poisson experiment:","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"(σ(xz)) ψ(t) = (Q(xz)) p(t)","category":"page"},{"location":"Poisson/intro/#","page":"-","title":"-","text":"Q = k * Q_v  η","category":"page"},{"location":"contributing/#Coding-Conventions-1","page":"-","title":"Coding Conventions","text":"","category":"section"},{"location":"contributing/#","page":"-","title":"-","text":"This software is organised into various modules. Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  distance = velocity * time is prefered over using  a = b * c in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation (Image: guide)","category":"page"},{"location":"contributing/#","page":"-","title":"-","text":"The methods ending with ! ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.","category":"page"},{"location":"tut/#","page":"-","title":"-","text":"Tutorials in a seperate repo.","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"EditURL = \"https://github.com/TRAVIS_REPO_SLUG/blob/master/\"","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"load packages","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"using GeoPhyInv\nusing Statistics","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"create simple (almost) homogeneous acoustic model","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"model=J.Gallery.Seismic(:acou_homo1)\nJ.Models.Seismic_addon!(model, randn_perc=0.01)","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"a simple acquisition geometry","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"acqgeom = GeoPhyInv.Gallery.Geom(model.mgrid,:xwell);","category":"page"},{"location":"test/page1/#","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.","category":"page"},{"location":"reference/#Fdtd-1","page":"Fdtd","title":"Fdtd","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"Modules = []\nOrder   = []","category":"page"},{"location":"reference/#Index-1","page":"Fdtd","title":"Index","text":"","category":"section"},{"location":"reference/#","page":"Fdtd","title":"Fdtd","text":"","category":"page"},{"location":"tutorials/page1/#","page":"-","title":"-","text":"FFF FF","category":"page"},{"location":"#The-Expt-Datatypes-1","page":"Home","title":"The Expt Datatypes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The methods in this package numerically solve some differential equations commonly faced in geophysical inverse problems. The functionality of this package revolves around the mutable Expt types. Julia's multiple dispatch is used to overload Base methods whenever possible.  Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as multiple dispatch. Firstly, most of the memory necessary to perform a given experiment is allocated while creating the Expt variables. Then these variables are input to in-place functions  (e.g., mod!)  which as per Julia convention ends with an exclamation mark, to actually perform the experiment task. For example, the current Expt types within the realm of this package include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"SeisForwExpt is the seismic (acoustic) forward modeling experiment  ;\nSeisInvExpt is the type for seismic inversion experiment, including migration;\nPoissonExpt is type for the solving the Poisson experiment.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To get started, as an example, simply load a seismic inversion experiment already defined in our package gallery into REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using GeoPhyInv # load GIPh (after installation)\npaE=GIPh.Gallery.SeisInvExpt(:pizza); # \"pizza\" is the name of the experiment","category":"page"},{"location":"#Grids-1","page":"Home","title":"Grids","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"It is necessary to input the evenly-spaced spatial and temporal grids while creating the Expt variables. These grids can be simply created using Base.range in Julia, as shown below.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"zgrid=range(0,stop=1000.0,length=201) # create vertical grid from 0 to 1000 m\nxgrid=range(0,stop=1000.0,length=201) # create horizontal grid\nmgrid=[zgrid, xgrid] # spatial-grid bundle\n@info string(\"spatial sampling intervals (dz,dx)=\", step.(mgrid))\ntgrid=range(0,stop=1.0,step=0.001) # a temporal grid from 0 to 1.0 s","category":"page"}]
}
