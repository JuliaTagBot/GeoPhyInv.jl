{
    "docs": [
        {
            "location": "/",
            "text": "SeismicInversionToolbox\n\n\nThe main tasks of this software are:\n\n\n\n\nForward problem, where the seismic data are generated\n\n\n\n\nusing synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.\n\n\n\n\nCan perform inversion of synthetic scenarios.\n\n\n\n\nFirst, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.\n\n\n\n\nRead\n\n\n\n\nthe measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.\n\n\n\n\nCoding Conventions\n\n\n\n\nThis software is organised into various modules.\n\n\n\n\nEach module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation \n\n\n\n\nThe methods ending with \n!\n ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.\n\n\n\n\n\n\nInstallation\n\n\n\n\nInput and Output Data Format\n\n\nIt is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format. \n\n\n\n\nDemos\n\n\nDemos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Home"
        },
        {
            "location": "/#seismicinversiontoolbox",
            "text": "The main tasks of this software are:   Forward problem, where the seismic data are generated   using synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.   Can perform inversion of synthetic scenarios.   First, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.   Read   the measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.",
            "title": "SeismicInversionToolbox"
        },
        {
            "location": "/#coding-conventions",
            "text": "This software is organised into various modules.   Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation    The methods ending with  !  ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.",
            "title": "Coding Conventions"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#input-and-output-data-format",
            "text": "It is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format.",
            "title": "Input and Output Data Format"
        },
        {
            "location": "/#demos",
            "text": "Demos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Demos"
        },
        {
            "location": "/reference/",
            "text": "There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.\n\n\n\n\nCoupling\n\n\n#\n\n\nJuMIT.Coupling\n \u2014 \nModule\n.\n\n\nThe data recorded at the receivers during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response. The source filter \nssf\n takes into account  the effective wavelet present in the data.  Similarly, the receiver filter \nrf\n takes the receiver coupling into account. The Inversion module can can estimate both \nssf\n and \nrf\n from the seismic data in order to achieve better data fitting. A base source wavelet \nSrc\n is always used to model the data  before applying the time-domain filter data type  described in this module:\n\n\n\n\nTD\n : time domain filters for both source and receivers\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Coupling.TD\n \u2014 \nType\n.\n\n\nTime-domain source and receiver filters.\n\n\nFields\n\n\n\n\nssf::Array{Array{Float64,1},2}\n : source filters for each supersource and recorded component\n\n\nrf::Array{Array{Float64,2},2}\n : receiver filters for each receiver, supersource and recorded component\n\n\nfields::Vector{Symbol}\n :  number of recorded components at receivers\n\n\ntgridssf::Grid.M1D\n : a  time grid for source filters with both positive and negative lags\n\n\ntgridrf::Grid.M1D\n : a  time grid for receiver filters with both positive and negative lags\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Coupling.TD_delta\n \u2014 \nMethod\n.\n\n\nInitialize coupling filters \nTD\n with  delta functions.\n\n\nArguments\n\n\n\n\ntgriddata\n : time grid of the data\n\n\ntlagssf_fracs::Vector{Real}\n : +ve and -ve fractions of source filter\n\n\ntlagrf_fracs::Vector{Real}\n : +ve and -ve fractions for receiver filter\n\n\n\u03b4t:Float64\n : sampling interval in time\n\n\nfields::Vector{Symbol}\n : number of components\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nReturn\n\n\n\n\ntime-domain coupling filters as \nTD\n\n\n\n\nsource\n\n\n\n\nAcquisition\n\n\n#\n\n\nJuMIT.Acquisition\n \u2014 \nModule\n.\n\n\nThis module defines the following data types:\n\n\n\n\nGeom\n : acquisition geometry, i.e., positions of supersources, sources and receivers\n\n\nSrc\n : source related acquisition parameters, e.g., source wavelet\n\n\n\n\nIt also provides methods that either does operations on these data type or  help their construction.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom\n \u2014 \nType\n.\n\n\nAcquisiton has supersources, sources and receivers. Each supersource has \nns\n multiple sources that are  injected (or active) simultaneously. For each supersource, a set of \nnr\n receivers are  recording waves.\n\n\nFields\n\n\n\n\nsx::Vector{Vector{Float64,1},1}\n : $x$ positions of sources\n\n\nsz::Vector{Vector{Float64,1},1}\n : $z$ positions of sources\n\n\nrx::Vector{Vector{Float64,1},1}\n : $x$ positions of receivers\n\n\nrz::Vector{Vector{Float64,1},1}\n : $z$ positions of receivers\n\n\nnss::Int64\n : number of supersources\n\n\nns::Vector{Int64,1}\n : number of sources for every supersource\n\n\nnr::Vector{Int64,1}\n : number of receivers for every supersource\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src\n \u2014 \nType\n.\n\n\nData type for the source related parameters during acquisiton.\n\n\nFields\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Array{Int64}\n : number of sources for each supersource\n\n\nfields::Vector{Symbol}\n : number of fields\n\n\nwav::Array{Float64}\n : wavelets in time domain\n\n\ntgrid::Grid.M1D\n : time grid\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \u2014 \nFunction\n.\n\n\nCompare if two \nTD\n's  are equal\n\n\nsource\n\n\n#\n\n\nBase.print\n \u2014 \nFunction\n.\n\n\nPriiiint information about \nSrc\n\n\nsource\n\n\n#\n\n\nBase.print\n \u2014 \nFunction\n.\n\n\nPrint information about \nGeom\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAdds input positions as either sources or receivers of every supershot.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAppends the input a vector of acquisition geometries.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_advance\n \u2014 \nFunction\n.\n\n\nAdvance either source or receiver array in an acquisition geometry in horizontal or vertical directions.\n\n\nArguments\n\n\n\n\ngeom::Geom\n : acquisition geometry that is updated\n\n\nadvances::Vector{Float64}=[[0.,0.], [0.,0.,]]\n : source and receiver advancements\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_boundary\n \u2014 \nMethod\n.\n\n\nModify input \nGeom\n such that the output \nGeom\n has either sources or receivers on the boundary of  \nmgrid\n.\n\n\nArguments\n\n\n\n\nacqgeom::Geom\n : input geometry\n\n\nmgrid::Grid.M2D\n : grid to determine the boundary\n\n\n\n\nattrib::Symbol\n : decide return\n\n\n\n\n=:srcborder\n sources on boundary (useful for back propagation)\n\n\n=:recborder\n receivers on boundary\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_check\n \u2014 \nMethod\n.\n\n\nCheck if all the sources and receivers in \nGeom\n are within the model \n\n\nReturn\n\n\n\n\ntrue\n if all the positions within the model, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_circ\n \u2014 \nMethod\n.\n\n\nCircular acquisition. The sources and receivers can also be placed on a circle of radius \nrad\n. The origin of the circle is at \nloc\n.  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by \n\u03b8lim\n\n\nArguments\n\n\n\n\nnss::Int64=10\n : number of supersources\n\n\nnr::Int64=10\n : number receivers for each super source\n\n\nloc::Vector{Float64}=[0.,0.]\n : location of origin\n\n\n\n\nrad::Vector{Float64}=[100.,100.]\n : radius for source and receiver circles, for example,\n\n\n\n\n=[0.,100.]\n for sources at the center of circle\n\n\n\u03b8lim::Vector{Float64}=[0.,\u03c0]\n : acquisition is limited to these angular offsets between 0 and \u03c0\n\n\n\n\n\n\n\n\nReturn\n\n\n\n\na circular acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_find\n \u2014 \nMethod\n.\n\n\nGiven receiver positions \nrpos\n and \nrpos0\n. Returns an array Int indices of the dimension of number of supersources with \ntrue\n at indices, if the waves due to that particular source are  recorded.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_fixed\n \u2014 \nFunction\n.\n\n\nA fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.\n\n\nArguments\n\n\n\n\nssmin::Float64\n : minimum coordinate for sources\n\n\nssmax::Float64\n : maximum coordinate for sources\n\n\nss0::Float64\n : consant coordinate for sources\n\n\nrmin::Float64\n : minimum coordinate for receivers\n\n\nrmax::Float64\n : maximum coordinate for receivers\n\n\nr0::Float64\n : consant coordinate for receivers\n\n\nnss::Int64\n : number of supersources\n\n\nnr::Int64\n : number of receivers\n\n\nssattrib::Symbol=:horizontal\n : supersource array kind \n=:vertical\n : vertical array of supersources \n=:horizontal\n horizontal array of supersources\n\n\nrattrib::Symbol=:horizontal\n : receiver array kind \n=:vertical\n : vertical array of receivers \n=:horizontal\n horizontal array of receivers\n\n\nrand_flags::Vector{Bool}=[false, false]\n : decide placement of supersources and receivers  \n=[true, false]\n : randomly place supersources for regularly spaced receivers \n=[true, true]\n : randomly place supersources and receivers \n=[false, false]\n : regularly spaced supersources and receivers \n=[false, true]\n : randomly place receivers for regularly spaced supersources\n\n\n\n\nReturn\n\n\n\n\na fixed spread acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_get\n \u2014 \nMethod\n.\n\n\nReturn some derived fields of \nGeom\n\n\nArguments\n\n\n\n\nacq::Vector{Geom}\n : a vector of \nGeom\n\n\n\n\nattrib::Symbol\n : attribute to determine the return object \n\n\n\n\n=:nus\n number of unique source positions in acquisition\n\n\n=:nur\n number of unique receiver positions in acquisition\n\n\n=:uspos\n a tuple of x and z positions of all the unique sources\n\n\n=:urpos\n a tuple of x and z position of all the unique receivers\n\n\n=:geomurpos\n a \nGeom\n vector as if all the unique receiver positions are used for each supersource\n\n\n=:geomuspos\n a \nGeom\n vector as if all the unique source positions are used for each supersource\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_isfixed\n \u2014 \nMethod\n.\n\n\nCheck if the input acquisition geometry is fixed spread.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed\n \u2014 \nMethod\n.\n\n\nConstructor for \nSrc\n data type. Uses same source wavelet, i.e., \nwav\n for all sources and supersources\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of sources\n\n\nfields::Vector{Symbol}\n : number of fields the sources are exciting\n\n\nwav::Array{Float64}\n : a source wavelet that is used for all sources and supersources\n\n\ntgrid::Grid.M1D\n : time grid for the wavelet\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed_mod\n \u2014 \nMethod\n.\n\n\nConstructor of \nSrc\n, which is typical for a input model such that  the model has \nn\u03bb\n wavelengths.\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of source per each supersource\n\n\nfields::Vector{Symbol}\n :\n\n\n\n\nKeyword Arguments\n\n\n\n\nmod::Models.Seismic\n :\n\n\nn\u03bb::Int64=10\n : number of wavelengths in the mod\n\n\nwav_func::Function=(fqdom, tgrid)->Signals.Wavelets.ricker(fqdom,tgrid)\n : which wavelet to generate, see Signals.Wavelets.jl\n\n\ntmaxfrac::Float64=1.0\n : by default the maximum modelling time is computed using the average velocity and the diagonal distance of the model, use this fraction to increase of reduce the maximum time\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed_random\n \u2014 \nMethod\n.\n\n\nGenerate band-limited random source signals \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_tr\n \u2014 \nMethod\n.\n\n\nFunction that returns Src after time reversal\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_uspos\n \u2014 \nMethod\n.\n\n\nPad \nSrc\n  tgrids should be same in all Src\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_zeros\n \u2014 \nMethod\n.\n\n\nAllocate \nSrc\n with zeros depending on the acquisition geometry.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.freqs\n \u2014 \nMethod\n.\n\n\nReturn minimum, maximum and peak frequencies of \nSrc\n\n\nsource\n\n\n\n\nModels\n\n\n#\n\n\nJuMIT.Models.Seismic\n \u2014 \nType\n.\n\n\nData type fo represent a seismic model. A contrast function for a model m is given by $\u03c7(m) = \frac{m}{m0}-1$.\n\n\nFields\n\n\n\n\nvp0::Vector{Float64}\n : [vpmin, vpmax]\n\n\nvs0::Vector{Float64}\n : [vsmin, vsmax]\n\n\n\u03c10::Vector{Float64}\n : [\u03c1min, \u03c1max]\n\n\n\u03c7vp::Array{Float64,2}\n : two-dimensional contrast model (\u03c7) for vp, for e.g., zeros(mgrid.nz, mgrid.nx)\n\n\n\u03c7vs::Array{Float64}\n : two-dimensional contrast model (\u03c7) for vs, for e.g., zeros(mgrid.nz, mgrid.nx)\n\n\n\u03c7\u03c1::Array{Float64}\n : two-dimensional contrast model (\u03c7) for density, for e.g., zeros(mgrid.nz, mgrid.nx)\n\n\nmgrid::Grid.M2D\n : two-dimensional grid to determine the dimensions of models\n\n\n\n\nsource\n\n\n#\n\n\nBase.copy!\n \u2014 \nMethod\n.\n\n\nCopy for \nSeismic\n models. The models should have same bounds and sizes.\n\n\nsource\n\n\n#\n\n\nBase.isapprox\n \u2014 \nMethod\n.\n\n\nReturn if two \nSeismic\n models have same dimensions and bounds.\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \u2014 \nMethod\n.\n\n\nCompare if two \nSeismic\n models are equal\n\n\nsource\n\n\n#\n\n\nBase.iszero\n \u2014 \nMethod\n.\n\n\nReturn true if a \nSeismic\n model is just allocated with zeros.\n\n\nsource\n\n\n#\n\n\nBase.print\n \u2014 \nFunction\n.\n\n\nPrint information about \nSeismic\n\n\nsource\n\n\n#\n\n\nBase.similar\n \u2014 \nMethod\n.\n\n\nReturn a similar model to the input model, used for allocation.\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_addon!\n \u2014 \nMethod\n.\n\n\nAdd features to a model.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model that is modified\n\n\n\n\nKeyword Arguments\n\n\n\n\npoint_loc::Vector{Float64}=[0., 0.,]\n : approx location of point pert.\n\n\npoint_pert::Float64=0.0\n : perturbation at the point scatterer\n\n\nellip_loc::Vector{Float64}=nothing\n : location of center of perturbation, [z, x]\n\n\nellip_rad::Float64=0.0\n : radius of circular perturbation\n\n\nellip_pert::Float64=0.1\n : perturbation inside a circle\n\n\nrect_loc::Array{Float64}=nothing\n : rectangle location, [zmin, xmin, zmax, xmax]\n\n\nrect_pert::Float64=0.1\n : perturbation in a rectangle\n\n\nrandn_pert::Float64=0.0\n : percentage of reference values for additive random noise\n\n\nfields::Vector{Symbol}=[:\u03c7vp,:\u03c7\u03c1,:\u03c7vs]\n : which fields are to be modified?\n\n\nonlyin\n : \nmod\n is modified only when field values are in these ranges\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_chainrule!\n \u2014 \nFunction\n.\n\n\nUse chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.\n\n\nArguments\n\n\n\n\ngmod::Seismic\n : gradient model\n\n\nmod::Seismic\n : model required for chain rule\n\n\ng1\n : gradient of an objective function with respect \nattribs[1]\n\n\ng2\n : gradient of an objective function with respect \nattribs[2]\n\n\nattribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]\n :\n\n\n\n\nflag::Int64=1\n :\n\n\n\n\n=1\n updates \ngmod\n using \ng1\n and \ng2\n\n\n=-1\n updates \ng1\n and \ng2\n using \ngmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_get!\n \u2014 \nMethod\n.\n\n\nGet other dependent model parameters of a seismic model that are not present in \nSeismic\n.\n\n\n\n\n:\u03c1I\n : inverse of density\n\n\n:Zp\n : P-wave impedance\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_pml_pad_trun!\n \u2014 \nMethod\n.\n\n\nonly padding implemented\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_pml_pad_trun\n \u2014 \nMethod\n.\n\n\nExtend a seismic model into PML layers\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_reparameterize!\n \u2014 \nFunction\n.\n\n\nRe-parameterization routine  that modifies the fields  \n\u03c7vp\n and \n\u03c7\u03c1\n of an input seismic model using two input vectors.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : to be updated\n\n\nx1::Array{Float64,2}\n : contrast of inverse bulk modulus\n\n\nx2::Array{Float64,2}\n : contrast of inverse density\n\n\nattribs:::Vector{Symbol}\n : [:\u03c7KI, :\u03c7\u03c1I]\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_smooth\n \u2014 \nFunction\n.\n\n\nApply smoothing to \nSeismic\n using a Gaussian filter of zwidth and xwidth\n\n\nArguments\n\n\n\n\nmod::Seismic\n : argument that is modified\n\n\nzperc::Real\n : smoothing percentage in z-direction\n\n\nxperc::Real=zperc\n : smoothing percentage in x-direction\n\n\n\n\nKeyword Arguments\n\n\n\n\nzmin::Real=mod.mgrid.z[1]\n :\n\n\nzmax::Real=mod.mgrid.z[end]\n :\n\n\nxmin::Real=mod.mgrid.x[1]\n :\n\n\nxmax::Real=mod.mgrid.x[end]\n :\n\n\nfields\n : fields of seismic model that are to be smooth\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_trun\n \u2014 \nMethod\n.\n\n\nReturn a truncated seismic model using input bounds. Note that there is no interpolation going on here, but only truncation, so  the input bounds cannot be strictly imposed.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model that is truncated\n\n\n\n\nKeyword Arguments\n\n\n\n\nzmin::Float64=mod.mgrid.z[1]\n :\n\n\nzmax::Float64=mod.mgrid.z[end]\n :\n\n\nxmin::Float64=mod.mgrid.x[1]\n :\n\n\nxmax::Float64=mod.mgrid.x[end]\n :\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.Seismic_zeros\n \u2014 \nMethod\n.\n\n\nReturn \nSeismic\n with zeros everywhere; this method is used for preallocation.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : used for sizes of \u03c7 fields\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.adjust_bounds!\n \u2014 \nFunction\n.\n\n\nAdjust the bounds and hence the reference values. Since the reference values are adjust the \u03c7 fields should also be changed\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.bounds\n \u2014 \nFunction\n.\n\n\nReturn medium property bounds based on maximum and minimum values of the array and frac. The bounds cannot be less than zero\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.interp_spray!\n \u2014 \nFunction\n.\n\n\nfunction to resample in the model domain\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model\n\n\nmodi::Seismic\n : model after interpolation\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.pml_pad_trun!\n \u2014 \nFunction\n.\n\n\nPML Extend a model on all four sides\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.\u03c7\n \u2014 \nFunction\n.\n\n\nReturn dimensionless contrast model parameter using the reference value.\n\n\nArguments\n\n\n\n\nmod::Array{Float64}\n : subsurface parameter\n\n\nmod0::Vector{Float64}\n : reference value is mean of this vector\n\n\nflag::Int64=1\n :\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Models.\u03c7g\n \u2014 \nFunction\n.\n\n\nGradients Return contrast model parameter using the reference value.\n\n\nsource\n\n\n\n\nData\n\n\n#\n\n\nJuMIT.Data\n \u2014 \nModule\n.\n\n\nThis module defines the data types related to seismic data:\n\n\n\n\nTD\n : time domain representation\n\n\n\n\nIt also provides methods that apply source and receiver filters onto  seismic data.\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.Param_error\n \u2014 \nType\n.\n\n\nCalculate the distance between the observed data \ny\n and the calculated data \nx\n. The time grid of the observed data can be different from that of the modelled data. The acqistion geometry of both the data sets should be the same.\n\n\nIf \nJ\n is the distance, the gradient of the misfit w.r.t to the calculated data is returned as \ndJx\n\n\n\n\nw\n used for data preconditioning\n\n\ncoupling\n source and receiver coupling functions\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD\n \u2014 \nType\n.\n\n\nTime domain representation of Seismic Data.\n\n\nFields\n\n\n\n\nd::Array{Array{Float64,2},2}\n : data\n\n\nfields::Vector{Symbol}\n : components recorded at each receiver\n\n\ntgrid::Grid.M1D\n : grid to represent time\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry used to generate the data\n\n\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.dot\n \u2014 \nMethod\n.\n\n\nReturns dot product of data.\n\n\nArguments\n\n\n\n\ndata1::TD\n : data 1\n\n\ndata2::TD\n : data 2\n\n\n\n\nReturn\n\n\n\n\ndot product as \nFloat64\n\n\n\n\nsource\n\n\n#\n\n\nBase.copy!\n \u2014 \nMethod\n.\n\n\nCopy \nTD\n's, which are similar.\n\n\nsource\n\n\n#\n\n\nBase.isapprox\n \u2014 \nMethod\n.\n\n\nReturn if two \nTD\n's have same dimensions and bounds.\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \u2014 \nMethod\n.\n\n\nCompare if two \nTD\n's  are equal\n\n\nsource\n\n\n#\n\n\nBase.iszero\n \u2014 \nMethod\n.\n\n\nReturns bool depending on if input \ndata::TD\n has all zeros or not.\n\n\nsource\n\n\n#\n\n\nBase.var\n \u2014 \nMethod\n.\n\n\nReturns the variance of data\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_normalize\n \u2014 \nFunction\n.\n\n\nNormalize time-domain seismic data.\n\n\nArguments\n\n\n\n\ndata::TD\n : input data\n\n\n\n\nattrib::Symbol\n : decide kind of normalization\n\n\n\n\n=:recrms\n the record at every receiver is normalized with its RMS value\n\n\n=:recmax\n the record at every receiver is normalized with its maximum value\n\n\n\n\n\n\n\n\nReturn\n\n\n\n\nnormalized data as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_ones\n \u2014 \nMethod\n.\n\n\nSame as \nTD_zeros\n, except for returning ones\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_tr!\n \u2014 \nMethod\n.\n\n\nTime reverse the records of each receiver in \nTD\n \n\n\nArguments\n\n\n\n\ndata::TD\n : input data that is modified\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_urpos\n \u2014 \nMethod\n.\n\n\nConstruct TD using data at all the unique receiver positions for all supersources.\n\n\n\n\nd::Array{Float64}\n : the data matrix ordered in order such that time-domain modelling schemes are fast, i.e., [irec,ifield,it,nss]\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_weight!\n \u2014 \nMethod\n.\n\n\nApply different weighting functions to \nTD\n. Use this method to create a  data preconditioning matrix\n\n\nArguments Modified\n\n\n\n\ndw::TD\n :\n\n\n\n\nKeyword Arguments\n\n\n\n\noffsetlim::Vector{Float64}=[-Inf,Inf]\n : [xoffsetlim, zoffsetlim], where the records with offsets > \noffsetlim\n are given zero weight\n\n\ntlim::Vector{Float64}=[dw.tgrid.x[1], dw.tgrid.x[end]]\n : [tminimum, tmaximum], time mute window\n\n\noffsetpow::Vector{Float64}=[0.0,0.0]\n :\n\n\ntpow::Float64=0.0\n :\n\n\nttaperperc::Float64=0.\n : taper window percentage for time window\n\n\nNOTE: if more than one simultaneous source are present, their mean position is considered to calculate offset.\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TD_zeros\n \u2014 \nMethod\n.\n\n\nMethod used to preallocate \nTD\n with zeros.\n\n\nArguments\n\n\n\n\nfields::Vector{Symbol}\n : number of components\n\n\ntgrid::Grid.M1D\n : time domain grid\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nReturn\n\n\n\n\ndata with zeros as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.TDcoup!\n \u2014 \nMethod\n.\n\n\nApply source and receiver coupling functions to TD. Currently, only source filters are applied.\n\n\nArguments\n\n\n\n\ns::TD\n : input data\n\n\nr::TD\n : input data\n\n\nw::Coupling.TD\n : input source and receiver filters\n\n\n\n\nattrib::Symbol\n : attribute to \n\n\n\n\n=:s\n to apply \nw\n to \nr\n and modify \ns\n\n\n=:r\n to apply adjoint of \nw\n to \ns\n and modify \nr\n\n\n=:w\n modify \nw\n using \nr\n and \ns\n\n\n\n\n\n\n\n\nTODO: need to work on parallelization and speed up here\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.interp\n \u2014 \nMethod\n.\n\n\nMethod to resample data in time.\n\n\nArguments\n\n\n\n\ndata::TD\n : input data of type \nTD\n\n\ntgrid::Grid.M1D\n : resampling in time according to this time grid\n\n\n\n\nReturn\n\n\n\n\ndata after resampling as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Data.interp_spray!\n \u2014 \nFunction\n.\n\n\nMethod to resample data in time. Can reduce allocations =========\n\n\nArguments\n\n\n\n\ndata::TD\n : input data of type \nTD\n\n\ndataout::TD\n : preallocated data of type \nTD\n that is modified\n\n\n\n\nsource\n\n\n\n\nGallery\n\n\n#\n\n\nJuMIT.Gallery.Geom\n \u2014 \nMethod\n.\n\n\nGallery of acquisition geometries \nGeom\n using an input mesh \nM2D\n. The sources and receivers are not placed anywhere on the edges of the mesh.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : a 2-D mesh\n\n\n\n\nattrib::Symbol\n : attribute decides output\n\n\n\n\n=:xwell\n cross-well acquisition\n\n\n=:surf\n surface acquisition\n\n\n=:vsp\n vertical seismic profiling\n\n\n=:rvsp\n  reverse vertical seismic profiling\n\n\n=:downhole\n downhole sources and receivers\n\n\n\n\n\n\n\n\nKeyword Arguments\n\n\n\n\nnss=2\n : number of supersources\n\n\nnr=2\n : number of receivers per supersource\n\n\nrand_flags::Vector{Bool}=[false, false]\n : randomly or equally spaced supersources and receivers.\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.M1D\n \u2014 \nMethod\n.\n\n\nGallery of \nM1D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a time grid for with 1000 samples; maximum time is 2 s\n\n\nattrib=:acou_homo1_long\n : a time grid for with 1000 samples; maximum time is 4 s\n\n\nattrib=:npow2samp1\n : a sample npow2 grid with 16 samples\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.M2D\n \u2014 \nMethod\n.\n\n\nGallery of \nM2D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a square grid for with 201 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\n\n\nattrib=:acou_homo2\n : a square grid for with 51 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.Seismic\n \u2014 \nFunction\n.\n\n\nGallery of \nSeismic\n models.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\n\n\nattrib=:acou_homo1\n : an homogeneous acoustic model with \nvp0=2000\n and \n\u03c10=2000\n\n\n\n\nattrib=:acou_homo2\n : same as above, but with spatial sampling as 40 m (faster testing)\n\n\nattrib=:seismic_marmousi2\n : marmousi model with lower resolution; ideal for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_high_res\n : marmousi model high resolution; slower to load\n\n\nattrib=:seismic_marmousi2_xwell\n : boxed marmousi model ideal for crosswell experiments\n\n\nattrib=:seismic_marmousi2_surf\n : boxed marmousi2 for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_downhole\n : boxed marmousi2 for downhole seismic experiments\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.Src\n \u2014 \nFunction\n.\n\n\nGallery of source signals \nSrc\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\nnss::Int64=1\n : number of supersources\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n :\n\n\n\n\nsource\n\n\n\n\nFdtd\n\n\n#\n\n\nJuMIT.Fdtd.Param\n \u2014 \nMethod\n.\n\n\nMethod to create \nFdtd\n modeling parameters. The output of this method can be used as an input to \nmod!\n, where the actual  finite-difference modeling is performed.\n\n\nKeyword Arguments\n\n\n\n\nnpw::Int64=1\n : number of independently propagating wavefields in \nmodel\n\n\nmodel::Models.Seismic=Gallery.Seismic(:acou_homo1)\n : seismic medium parameters\n\n\nmodel_pert::Models.Seismic=model\n : perturbed model, i.e., model + \u03b4model, used only for Born modeling\n\n\ntgridmod::Grid.M1D=Gallery.M1D(:acou_homo1)\n : modeling time grid, maximum time in tgridmod should be greater than or equal to maximum source time, same sampling interval as the wavelet\n\n\ntgrid::Grid.M1D=tgridmod\n : output records are resampled on this time grid\n\n\nacqgeom::Vector{Acquisition.Geom}=fill(Gallery.Geom(:acou_homo1),npw)\n :  acquisition geometry for each independently propagating wavefield\n\n\nacqsrc::Vector{Acquisition.Src}=fill(Gallery.Src(:acou_homo1),npw)\n : source acquisition parameters for each independently propagating wavefield\n\n\n\n\nsflags::Vector{Int64}=fill(2,npw)\n : source related flags for each propagating wavefield\n\n\n\n\n=[0]\n inactive sources\n\n\n=[1]\n sources with injection rate\n\n\n=[2]\n volume injection sources\n\n\n=[3]\n sources input after time reversal (use only during backpropagation)\n\n\n\n\nrflags::Vector{Int64}=fill(1,npw)\n : receiver related flags for each propagating wavefield\n\n\n\n\n\n\n=[0]\n receivers do not record (or) inactive receivers\n\n\n\n\n=[0,1]\n receivers are active only for the second propagating wavefield\n\n\nrfields::Vector{Symbol}=[:P]\n : multi-component receiver flag; types fields the receivers record (to be changed later)\n\n\n\n\nbackprop_flag::Bool=Int64\n : save final state variables and the boundary conditions for later use\n\n\n\n\n\n\n=1\n save boundary and final values in \nboundary\n\n\n\n\n=-1\n use stored values in \nboundary\n for back propagation\n\n\n\n\nabs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]\n : use absorbing PML boundary conditions or not\n\n\n\n\n\n\n=[:top, :bottom]\n apply PML conditions only at the top and bottom of the model\n\n\n\n\n=[:bottom, :right, :left]\n top is reflecting\n\n\nborn_flag::Bool=false\n : do only Born modeling instead of full wavefield modelling (to be updated soon)\n\n\ngmodel_flag=false\n : flag that is used to output gradient; there should be atleast two propagating wavefields in order to do so: 1) forward wavefield and 2) adjoint wavefield\n\n\nillum_flag::Bool=false\n : flag to output wavefield energy or source illumination; it can be used as preconditioner during inversion\n\n\ntsnaps::Vector{Float64}=fill(0.5*(tgridmod.x[end]+tgridmod.x[1]),1)\n : store snaps at these modelling times\n\n\nsnaps_flag::Bool=false\n : return snaps or not\n\n\nverbose::Bool=false\n : verbose flag\n\n\n\n\n\n\n\n\nExample\n\n\npa\n \n=\n \nJuMIT\n.\nFdtd\n.\nParam\n(\nacqgeom\n=\nacqgeom\n,\n \nacqsrc\n=\nacqsrc\n,\n \nmodel\n=\nmodel\n,\n \ntgridmod\n=\ntgridmod\n);\n\n\nJuMIT\n.\nFdtd\n.\nmod!\n(\npa\n);\n\n\n\n\n\n\nCredits\n\n\nAuthor: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)\n\n\n\n\noriginal code in FORTRAN90: March 2013\n\n\nmodified: 11 Sept 2013\n\n\nmajor update: 25 July 2014\n\n\ncode optimization with help from Jan Thorbecke: Dec 2015\n\n\nrewritten in Julia: June 2017\n\n\nadded parrallelization over supersources in Julia: July 2017\n\n\nefficient parrallelization using distributed arrays: Sept 2017\n\n\noptimized memory allocation: Oct 2017\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramc\n \u2014 \nType\n.\n\n\nModelling parameters common for all supersources\n\n\nKeyword Arguments that are modified by the method (some of them are returned as well)\n\n\n\n\ngmodel::Models.Seismic=Models.Seismic_zeros(model.mgrid)\n : gradient model modified only if \ngmodel_flag\n\n\nTDout::Vector{Data.TD}=[Data.TD_zeros(rfields,tgridmod,acqgeom[ip]) for ip in 1:length(findn(rflags))]\n\n\nillum::Array{Float64,2}=zeros(model.mgrid.nz, model.mgrid.nx)\n : source energy if \nillum_flag\n\n\nboundary::Array{Array{Float64,4},1}\n : stored boundary values for first propagating wavefield\n\n\nsnaps::Array{Float64,4}=zeros(model.mgrid.nz,model.mgrid.nx,length(tsnaps),acqgeom[1].nss)\n :snapshots saved at \ntsnaps\n\n\n\n\nReturn (in order)\n\n\n\n\nmodelled data for each propagating wavefield as \nVector{TD}\n\n\nstored boundary values of the first propagating wavefield as \nArray{Array{Float64,4},1}\n (use for backpropagation)\n\n\nfinal conditions of the first propagating wavefield as \nArray{Float64,4}\n (use for back propagation)\n\n\ngradient model as \nSeismic\n\n\nstored snaps shots at tsnaps as Array{Float64,4}\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramp\n \u2014 \nType\n.\n\n\nParameters per every worker, not necessarily for every supersource. Note that a single worker can take care of multiple supersources.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramp\n \u2014 \nMethod\n.\n\n\nCreate modeling parameters for each worker. Each worker performs the modeling of supersources in \nsschunks\n. The parameters common to all workers are stored in \npac\n.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramss\n \u2014 \nType\n.\n\n\nModelling parameters per every supersource for each worker\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramss\n \u2014 \nMethod\n.\n\n\nCreate modeling parameters for each supersource.  Every worker models one or more supersources.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.get_rhovxI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.get_rhovzI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.mod!\n \u2014 \nFunction\n.\n\n\nThis method updated the input \nFdtd.Param\n after the wave propagation.\n\n\nArguments\n\n\n\n\npa::Param\n : modelling parameters\n\n\n\n\nUseful fields in \npa\n that are modified by the method\n\n\n\n\npa.c.TDout::Vector{Data.TD}\n : seismic data at receivers after modeling, for each propagating wavefield\n\n\npa.c.snaps::Array{Float64,4}\n : snaps with size \n(nz,nx,length(tsnaps),nss)\n saved at \ntsnaps\n\n\npa.c.gmodel::Models.Seismic\n : gradient model modified only if \ngmodel_flag\n\n\npa.c.illum_stack::Array{Float64,2}\n source energy of size \n(nz,nx)\n if \nillum_flag\n\n\n\n\nExample\n\n\nJuMIT\n.\nFdtd\n.\nmod!\n(\npa\n)\n\n\n\n\n\n\nCredits\n\n\nAuthor: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.pml_variables\n \u2014 \nMethod\n.\n\n\nOutput vectors related to PML boundaries.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.update_model!\n \u2014 \nFunction\n.\n\n\nUpdate the \nSeismic\n models in \nParamc\n without additional memory allocation. This routine is used during FWI, where medium parameters are itertively updated. \n\n\nsource\n\n\n\n\nFWI\n\n\n#\n\n\nJuMIT.FWI\n \u2014 \nModule\n.\n\n\nThis module defines a type called \nParam\n that is to be constructed  before performing  and kind of inversion. The following functionality is currently added in this module:\n\n\n\n\na simple RTM\n\n\nfull-waveform inversion\n\n\nsource and receiver filter inversion\n\n\n\n\nOnce a \nParam\n object is constructed, the following routines update certain fields of the \nParam\n after performing the inversion.\n\n\n\n\nxfwi!\n : updates the initial subsurface models in \nParam\n using its observed data\n\n\nwfwi!\n : updates the source and receiver filters in \nParam\n using its observed data\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Param\n \u2014 \nType\n.\n\n\nFWI Parameters\n\n\nFields\n\n\n\n\nmgrid::Grid.M2D\n : modelling grid\n\n\nigrid::Grid.M2D\n : inversion grid\n\n\nacqsrc::Acquisition.Src\n : base source wavelet for modelling data\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\ntgrid::Grid.M1D\n :\n\n\nattrib_mod::Symbol\n\n\nmodel_obs\n : model used for generating observed data\n\n\nmodel0\n : background velocity model (only used during Born modeling and inversion)\n\n\nparameterization\n : a vector of Symbols specifying parameterization of the inversion vector\n\n\nverbose\n : print level on STOUT\n\n\nattrib\n : synthetic or real\n\n\n\n\nTODO: add an extra attribute for coupling functions inversion and modelling\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Param\n \u2014 \nMethod\n.\n\n\nConstructor for \nParam\n\n\nArguments\n\n\n\n\nacqsrc::Acquisition.Src\n : source time functions\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\ntgrid::Grid.M1D\n : modelling time grid\n\n\nattrib_mod::Symbol\n : modelling attribute\n\n\nattrib_inv::Symbol\n : inversion attribute\n\n\nmodm::Models.Seismic\n : seismic model on modelling mesh\n\n\n\n\nOptional Arguments\n\n\n\n\ntgrid_obs::Grid.M1D\n : time grid for observed data\n\n\nigrid::Grid.M2D=modm.mgrid\n : inversion grid if different from the modelling grid, i.e., \nmodm.mgrid\n\n\n\n\nmprecon_factor::Float64=1\n : factor to control model preconditioner, always greater than 1\n\n\n\n\n=1\n means the preconditioning is switched off\n\n\n>1\n means the preconditioning is switched on, larger the mprecon_factor, stronger the applied preconditioner becomes\n\n\ndobs::Data.TD\n : observed data\n\n\ndprecon::Data.TD=Data.TD_ones(1,dobs.tgrid,dobs.acqgeom)\n : data preconditioning, defaults to one\n\n\ntlagssf_fracs=0.0\n : maximum lagtime of unknown source filter\n\n\ntlagrf_fracs=0.0\n : maximum lagtime of unknown receiver filter\n\n\nacqsrc_obs::Acquisition.Src=acqsrc\n : source wavelets to generate \nobserved data\n; can be different from \nacqsrc\n\n\nmodm_obs::Models.Seismic=modm\n : actual seismic model to generate \nobserved data\n\n\nmodm0::Models.Seismic=modm\n : background seismic model for Born modelling and inversion (still being tested)\n\n\nmod_inv_parameterization::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]\n : subsurface parameterization\n\n\nverbose::Bool=false\n : print level on STDOUT during inversion\n\n\n\n\nattrib::Symbol=:synthetic\n : an attribute to control class\n\n\n\n\n\n\n=:synthetic\n synthetic data inversion\n\n\n\n\n=:field\n field data inversion\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.AdjGeom\n \u2014 \nMethod\n.\n\n\nModify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Coupling_gx!\n \u2014 \nMethod\n.\n\n\nConvert dJssf to gradient vector\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Coupling_x!\n \u2014 \nMethod\n.\n\n\nConvert coupling functions to x and vice versa\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.F!\n \u2014 \nFunction\n.\n\n\nPerform a forward simulation. This simulation is common for both functional and gradient calculation. During the computation of the gradient, we need an adjoint simulation. Update the buffer, which consists of the modelled data and boundary values for adjoint calculation.\n\n\nArguments\n\n\n\n\nx::Vector{Float64}\n : inversion variable\n\n\nlast_x::Vector{Float64}\n : buffer is only updated when x!=last_x, and modified such that last_x=x\n\n\npa::Param\n : parameters that are constant during the inversion\n\n\nmodm::Models.Seismic\n :\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Fadj!\n \u2014 \nMethod\n.\n\n\n\n\nuse x and update model in pa\n\n\ncompute gradient\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Seismic_gx!\n \u2014 \nMethod\n.\n\n\nConvert gradient vector to \nSeismic\n type and vice versa This will be different from the previous one, once  the parameterizations come in\n\n\n\n\ngmodm::Models.Seismic\n : gradient model on the modelling grid\n\n\nmodm::Models.Seismic\n : model on the modelling grid\n\n\ngmodi::Models.Seismic\n : gradient model on the inversion grid\n\n\nmodi::Models.Seismic\n : model on the inversion grid\n\n\ngx::Vector{Float64}\n : gradient vector\n\n\npa::Param\n :\n\n\n\n\nflag::Int64\n :\n\n\n\n\n=1\n update the vector \ngx\n using \ngmod\n\n\n=-1\n update gmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Seismic_x!\n \u2014 \nMethod\n.\n\n\nConvert \nSeismic\n model to x and vice versa\n\n\n\n\nmodm\n : seismic model on modelling grid (input nothing to not use it)\n\n\nmodi::Models.Seismic\n : seismic model on inversion grid\n\n\nx::Vector{Float64}\n : inversion vector\n\n\npa::Param\n : fwi parameters\n\n\n\n\nflag::Int64\n : \n\n\n\n\n=1\n converts either modm or modi to x\n\n\n=-1\n updates both modm and modi using x\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.Seismic_xbound!\n \u2014 \nMethod\n.\n\n\nReturn bound vectors for the \nSeismic\n model,  depeding on paramaterization\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.build_mprecon!\n \u2014 \nFunction\n.\n\n\nbuild a model precon\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.func_grad_Coupling!\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.func_grad_xfwi!\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.hessian_xfwi!\n \u2014 \nMethod\n.\n\n\noutdated\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.update_adjsrc!\n \u2014 \nMethod\n.\n\n\nConvert the data \nTD\n to \nSrc\n after time reversal.\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.wfwi!\n \u2014 \nMethod\n.\n\n\nUpdate pa.w\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.wfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables for source and receiver filter inversion  corresponding to \nParam\n. This number depends on the maximum lagtimes of the filters. \n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.xfwi!\n \u2014 \nMethod\n.\n\n\nFull Waveform Inversion using \nOptim\n package. This method updates \npa.modm\n and \npa.dcal\n. More details about the optional parameters can be found in the documentation of the \nOptim\n  package. \npa.modi\n is used as initial model if non-zero.\n\n\nArguments that are modified\n\n\n\n\npa::Param\n : inversion parameters\n\n\n\n\nOptional Arguments\n\n\n\n\nextended_trace::Bool=true\n : save extended trace\n\n\ntime_limit=Float64=2.0*60.\n : time limit for inversion (testing)\n\n\niterations::Int64=5\n : maximum number of iterations\n\n\nlinesearch_iterations::Int64=3\n : maximum number of line search iterations\n\n\nf_tol::Float64=1e-5\n : functional tolerance\n\n\ng_tol::Float64=1e-8\n : gradient tolerance\n\n\nx_tol::Float64=1e-5\n : model tolerance\n\n\n\n\nOutputs\n\n\n\n\n\n\ndepending on  \npa.attrib_inv\n\n\n\n\n=:cls\n classic least-squares inversion using adjoint state method\n\n\n=:migr\n return gradient at the first iteration, i.e., a migration image\n\n\n=:migr_finite_difference\n same as above but \nnot\n using adjoint state method; time consuming; only for testing, TODO: implement autodiff here\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.FWI.xfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables for FWI corresponding to \nParam\n. This number of inversion variables depend on the size of inversion mesh.\n\n\nsource\n\n\n\n\nInterferometry\n\n\n#\n\n\nJuMIT.Interferometry.TD_noise_corr\n \u2014 \nMethod\n.\n\n\nCorrelating noise records with reference records\n\n\n\n\nirref\n : reference receiver\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Interferometry.TD_virtual_diff\n \u2014 \nMethod\n.\n\n\nenhance diffractions in the \nTD\n\n\nKeyword Arguments\n\n\n\u03bbdom::Float64=0.0\n : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005) \ntlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]\n : maximum lag time in the output traces \n\n\nsource\n\n\n\n\nPoisson\n\n\n#\n\n\nJuMIT.Poisson\n \u2014 \nModule\n.\n\n\nThis module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. The following functionality is currently available in this module:\n\n\n\n\n'Forward' problem: given the source, and the conductivity distribution, solve for the electrical potential \u03c8:\n\n\n\n\n \nExample\n \nproblem\n:\n \nsolve\n \nA\u03c8\n=\n\u2207\u22c5\nj\n;\n \nA\n=\n\u2207\u22c5\n(\n\u03c3\n(\nx\n,\nz\n)\n\u2207\n),\n \nfor\n \n\u03c8\n.\n\n\n\n\n\n\n\n\n'Inverse' problem: given wave propagation related pore pressure, and mechanical medium properties, calculate the source term:\n\n\n\n\n \nExample\n \nproblem\n:\n \nsolve\n \nA\u03c8\n=\n-\n\u2207\u22c5\nj\n;\n \nA\n=\n\u2207\u22c5\n(\n[\nQ\n*\nk\n/\n\u03b7\n]\n(\nx\n,\nz\n)\n\u2207\nB\n*\nP\n),\n \nfor\n \n\u2207\u22c5\nj\n;\n\n\n\n\n\n\n\n\nThe Boundary Value Problem that is currently implemented assumes Neumann boundary conditions at all boundaries.\n\n\n\n\nDeveloped by:\n Niels Grobbe, Massachusetts Institute of Technology, USA.\n In collaboration with: Aim\u00e9 Fournier & Laurent Demanet, Massachusetts Institute of Technology, USA.\n Date: October, 2017 \n Contact: ngrobbe@gmail.com\n\n\nsource\n\n\n#\n\n\nJuMIT.Poisson.solve\n \u2014 \nMethod\n.\n\n\nPoisson.solve(field,mpars,solflag) solves the forward or inverse Poisson problem in a heterogeneous medium.\n\n\nFunction input arguments:\n\n\n\n\nfield\n : either source term used in 'forward' mode to get field, or the field (e.g. pore pressure) used in 'inverse' mode to calculate source-term\n\n\nmpars\n : medium parameters for forward or inverse mode\n\n\nsolflag\n : Solution flag determining whether to use forward (solflag=1) or inverse mode (solflag=-1) of Poisson solver.\n\n\n\n\nsource\n\n\n\n\nPlots\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot acquisition geometry \nAcquisition.Geom\n on and model grid \nM2D\n.\n\n\nattrib::Symbol=:unique\n : default; plots unique source and receiver positions \nssvec::Vector{Int64}\n : plot source and receivers of only these supersources\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot the velocity and density seismic models.\n\n\nArguments\n\n\n\n\nmodel::Models.Seismic\n : model that should be plotted\n\n\n\n\nKeyword Arguments\n\n\n\n\nxlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]\n : minimum and maximum limits of the second dimension while plotting\n\n\nzlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]\n : minimum and maximum limits of the first dimension while plotting\n\n\nfields::Vector{Symbol}=[:vp, :\u03c1]\n : fields that are to be plotted, see Models.Seismic_get\n\n\ncontrast_flag=false\n : plot only the edges of the model\n\n\nuse_bounds=false\n : adjust \nclim\n to the bounds in the seismic model\n\n\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot the source wavelet used for acquisition.\n\n\nArguments\n\n\n\n\nacqsrc::Acquisition.Src\n : source acquisition parameters\n\n\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot time-domain data of type \nData.TD\n\n\nArguments\n\n\n\n\ntd::Vector{Data.TD}\n : time-domain data to be compared\n\n\n\n\nKeyword Arguments\n\n\n\n\nssvec::Vector{Vector{Int64}}=fill([1], length(td))\n : supersource vector to be plotted\n\n\nfields::Vector{Int64}=[1]\n : field vector to be plotted\n\n\ntr_flag::Bool=false\n : plot time-reversed data when true\n\n\nattrib::Symbol=:wav\n : specify type of plot\n\n\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nJuMIT.Acquisition\n\n\nJuMIT.Coupling\n\n\nJuMIT.Data\n\n\nJuMIT.FWI\n\n\nJuMIT.Poisson\n\n\nJuMIT.Acquisition.Geom\n\n\nJuMIT.Acquisition.Src\n\n\nJuMIT.Coupling.TD\n\n\nJuMIT.Data.Param_error\n\n\nJuMIT.Data.TD\n\n\nJuMIT.FWI.Param\n\n\nJuMIT.FWI.Param\n\n\nJuMIT.Fdtd.Param\n\n\nJuMIT.Fdtd.Paramc\n\n\nJuMIT.Fdtd.Paramp\n\n\nJuMIT.Fdtd.Paramp\n\n\nJuMIT.Fdtd.Paramss\n\n\nJuMIT.Fdtd.Paramss\n\n\nJuMIT.Models.Seismic\n\n\nBase.LinAlg.dot\n\n\nBase.copy!\n\n\nBase.copy!\n\n\nBase.isapprox\n\n\nBase.isapprox\n\n\nBase.isequal\n\n\nBase.isequal\n\n\nBase.isequal\n\n\nBase.iszero\n\n\nBase.iszero\n\n\nBase.print\n\n\nBase.print\n\n\nBase.print\n\n\nBase.similar\n\n\nBase.var\n\n\nJuMIT.Acquisition.Geom_add!\n\n\nJuMIT.Acquisition.Geom_add!\n\n\nJuMIT.Acquisition.Geom_advance\n\n\nJuMIT.Acquisition.Geom_boundary\n\n\nJuMIT.Acquisition.Geom_check\n\n\nJuMIT.Acquisition.Geom_circ\n\n\nJuMIT.Acquisition.Geom_find\n\n\nJuMIT.Acquisition.Geom_fixed\n\n\nJuMIT.Acquisition.Geom_get\n\n\nJuMIT.Acquisition.Geom_getvec\n\n\nJuMIT.Acquisition.Geom_isfixed\n\n\nJuMIT.Acquisition.Src_fixed\n\n\nJuMIT.Acquisition.Src_fixed_mod\n\n\nJuMIT.Acquisition.Src_fixed_random\n\n\nJuMIT.Acquisition.Src_getvec\n\n\nJuMIT.Acquisition.Src_tr\n\n\nJuMIT.Acquisition.Src_uspos\n\n\nJuMIT.Acquisition.Src_zeros\n\n\nJuMIT.Acquisition.freqs\n\n\nJuMIT.Coupling.TD_delta\n\n\nJuMIT.Data.TD_normalize\n\n\nJuMIT.Data.TD_ones\n\n\nJuMIT.Data.TD_tr!\n\n\nJuMIT.Data.TD_urpos\n\n\nJuMIT.Data.TD_weight!\n\n\nJuMIT.Data.TD_zeros\n\n\nJuMIT.Data.TDcoup!\n\n\nJuMIT.Data.interp\n\n\nJuMIT.Data.interp_spray!\n\n\nJuMIT.FWI.AdjGeom\n\n\nJuMIT.FWI.Coupling_gx!\n\n\nJuMIT.FWI.Coupling_x!\n\n\nJuMIT.FWI.F!\n\n\nJuMIT.FWI.Fadj!\n\n\nJuMIT.FWI.Seismic_gx!\n\n\nJuMIT.FWI.Seismic_x!\n\n\nJuMIT.FWI.Seismic_xbound!\n\n\nJuMIT.FWI.build_mprecon!\n\n\nJuMIT.FWI.func_grad_Coupling!\n\n\nJuMIT.FWI.func_grad_xfwi!\n\n\nJuMIT.FWI.hessian_xfwi!\n\n\nJuMIT.FWI.update_adjsrc!\n\n\nJuMIT.FWI.wfwi!\n\n\nJuMIT.FWI.wfwi_ninv\n\n\nJuMIT.FWI.xfwi!\n\n\nJuMIT.FWI.xfwi_ninv\n\n\nJuMIT.Fdtd.get_rhovxI\n\n\nJuMIT.Fdtd.get_rhovzI\n\n\nJuMIT.Fdtd.mod!\n\n\nJuMIT.Fdtd.pml_variables\n\n\nJuMIT.Fdtd.update_model!\n\n\nJuMIT.Gallery.Geom\n\n\nJuMIT.Gallery.M1D\n\n\nJuMIT.Gallery.M2D\n\n\nJuMIT.Gallery.Seismic\n\n\nJuMIT.Gallery.Src\n\n\nJuMIT.Interferometry.TD_noise_corr\n\n\nJuMIT.Interferometry.TD_virtual_diff\n\n\nJuMIT.Models.Seismic_addon!\n\n\nJuMIT.Models.Seismic_chainrule!\n\n\nJuMIT.Models.Seismic_get!\n\n\nJuMIT.Models.Seismic_pml_pad_trun\n\n\nJuMIT.Models.Seismic_pml_pad_trun!\n\n\nJuMIT.Models.Seismic_reparameterize!\n\n\nJuMIT.Models.Seismic_smooth\n\n\nJuMIT.Models.Seismic_trun\n\n\nJuMIT.Models.Seismic_zeros\n\n\nJuMIT.Models.adjust_bounds!\n\n\nJuMIT.Models.bounds\n\n\nJuMIT.Models.interp_spray!\n\n\nJuMIT.Models.pml_pad_trun!\n\n\nJuMIT.Models.\u03c7\n\n\nJuMIT.Models.\u03c7g\n\n\nJuMIT.Poisson.solve\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe",
            "title": "Reference"
        },
        {
            "location": "/reference/#coupling",
            "text": "#  JuMIT.Coupling  \u2014  Module .  The data recorded at the receivers during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response. The source filter  ssf  takes into account  the effective wavelet present in the data.  Similarly, the receiver filter  rf  takes the receiver coupling into account. The Inversion module can can estimate both  ssf  and  rf  from the seismic data in order to achieve better data fitting. A base source wavelet  Src  is always used to model the data  before applying the time-domain filter data type  described in this module:   TD  : time domain filters for both source and receivers   source  #  JuMIT.Coupling.TD  \u2014  Type .  Time-domain source and receiver filters.  Fields   ssf::Array{Array{Float64,1},2}  : source filters for each supersource and recorded component  rf::Array{Array{Float64,2},2}  : receiver filters for each receiver, supersource and recorded component  fields::Vector{Symbol}  :  number of recorded components at receivers  tgridssf::Grid.M1D  : a  time grid for source filters with both positive and negative lags  tgridrf::Grid.M1D  : a  time grid for receiver filters with both positive and negative lags  acqgeom::Acquisition.Geom  : acquisition geometry   source  #  JuMIT.Coupling.TD_delta  \u2014  Method .  Initialize coupling filters  TD  with  delta functions.  Arguments   tgriddata  : time grid of the data  tlagssf_fracs::Vector{Real}  : +ve and -ve fractions of source filter  tlagrf_fracs::Vector{Real}  : +ve and -ve fractions for receiver filter  \u03b4t:Float64  : sampling interval in time  fields::Vector{Symbol}  : number of components  acqgeom::Acquisition.Geom  : acquisition geometry   Return   time-domain coupling filters as  TD   source",
            "title": "Coupling"
        },
        {
            "location": "/reference/#acquisition",
            "text": "#  JuMIT.Acquisition  \u2014  Module .  This module defines the following data types:   Geom  : acquisition geometry, i.e., positions of supersources, sources and receivers  Src  : source related acquisition parameters, e.g., source wavelet   It also provides methods that either does operations on these data type or  help their construction.  source  #  JuMIT.Acquisition.Geom  \u2014  Type .  Acquisiton has supersources, sources and receivers. Each supersource has  ns  multiple sources that are  injected (or active) simultaneously. For each supersource, a set of  nr  receivers are  recording waves.  Fields   sx::Vector{Vector{Float64,1},1}  : $x$ positions of sources  sz::Vector{Vector{Float64,1},1}  : $z$ positions of sources  rx::Vector{Vector{Float64,1},1}  : $x$ positions of receivers  rz::Vector{Vector{Float64,1},1}  : $z$ positions of receivers  nss::Int64  : number of supersources  ns::Vector{Int64,1}  : number of sources for every supersource  nr::Vector{Int64,1}  : number of receivers for every supersource   source  #  JuMIT.Acquisition.Src  \u2014  Type .  Data type for the source related parameters during acquisiton.  Fields   nss::Int64  : number of supersources  ns::Array{Int64}  : number of sources for each supersource  fields::Vector{Symbol}  : number of fields  wav::Array{Float64}  : wavelets in time domain  tgrid::Grid.M1D  : time grid   source  #  Base.isequal  \u2014  Function .  Compare if two  TD 's  are equal  source  #  Base.print  \u2014  Function .  Priiiint information about  Src  source  #  Base.print  \u2014  Function .  Print information about  Geom  source  #  JuMIT.Acquisition.Geom_add!  \u2014  Method .  Adds input positions as either sources or receivers of every supershot.  source  #  JuMIT.Acquisition.Geom_add!  \u2014  Method .  Appends the input a vector of acquisition geometries.  source  #  JuMIT.Acquisition.Geom_advance  \u2014  Function .  Advance either source or receiver array in an acquisition geometry in horizontal or vertical directions.  Arguments   geom::Geom  : acquisition geometry that is updated  advances::Vector{Float64}=[[0.,0.], [0.,0.,]]  : source and receiver advancements   source  #  JuMIT.Acquisition.Geom_boundary  \u2014  Method .  Modify input  Geom  such that the output  Geom  has either sources or receivers on the boundary of   mgrid .  Arguments   acqgeom::Geom  : input geometry  mgrid::Grid.M2D  : grid to determine the boundary   attrib::Symbol  : decide return   =:srcborder  sources on boundary (useful for back propagation)  =:recborder  receivers on boundary     source  #  JuMIT.Acquisition.Geom_check  \u2014  Method .  Check if all the sources and receivers in  Geom  are within the model   Return   true  if all the positions within the model,  false  otherwise   source  #  JuMIT.Acquisition.Geom_circ  \u2014  Method .  Circular acquisition. The sources and receivers can also be placed on a circle of radius  rad . The origin of the circle is at  loc .  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by  \u03b8lim  Arguments   nss::Int64=10  : number of supersources  nr::Int64=10  : number receivers for each super source  loc::Vector{Float64}=[0.,0.]  : location of origin   rad::Vector{Float64}=[100.,100.]  : radius for source and receiver circles, for example,   =[0.,100.]  for sources at the center of circle  \u03b8lim::Vector{Float64}=[0.,\u03c0]  : acquisition is limited to these angular offsets between 0 and \u03c0     Return   a circular acquisition geometry  Geom   source  #  JuMIT.Acquisition.Geom_find  \u2014  Method .  Given receiver positions  rpos  and  rpos0 . Returns an array Int indices of the dimension of number of supersources with  true  at indices, if the waves due to that particular source are  recorded.  source  #  JuMIT.Acquisition.Geom_fixed  \u2014  Function .  A fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.  Arguments   ssmin::Float64  : minimum coordinate for sources  ssmax::Float64  : maximum coordinate for sources  ss0::Float64  : consant coordinate for sources  rmin::Float64  : minimum coordinate for receivers  rmax::Float64  : maximum coordinate for receivers  r0::Float64  : consant coordinate for receivers  nss::Int64  : number of supersources  nr::Int64  : number of receivers  ssattrib::Symbol=:horizontal  : supersource array kind  =:vertical  : vertical array of supersources  =:horizontal  horizontal array of supersources  rattrib::Symbol=:horizontal  : receiver array kind  =:vertical  : vertical array of receivers  =:horizontal  horizontal array of receivers  rand_flags::Vector{Bool}=[false, false]  : decide placement of supersources and receivers   =[true, false]  : randomly place supersources for regularly spaced receivers  =[true, true]  : randomly place supersources and receivers  =[false, false]  : regularly spaced supersources and receivers  =[false, true]  : randomly place receivers for regularly spaced supersources   Return   a fixed spread acquisition geometry  Geom   source  #  JuMIT.Acquisition.Geom_get  \u2014  Method .  Return some derived fields of  Geom  Arguments   acq::Vector{Geom}  : a vector of  Geom   attrib::Symbol  : attribute to determine the return object    =:nus  number of unique source positions in acquisition  =:nur  number of unique receiver positions in acquisition  =:uspos  a tuple of x and z positions of all the unique sources  =:urpos  a tuple of x and z position of all the unique receivers  =:geomurpos  a  Geom  vector as if all the unique receiver positions are used for each supersource  =:geomuspos  a  Geom  vector as if all the unique source positions are used for each supersource     source  #  JuMIT.Acquisition.Geom_getvec  \u2014  Method .  return a vector of the order   source  #  JuMIT.Acquisition.Geom_isfixed  \u2014  Method .  Check if the input acquisition geometry is fixed spread.  source  #  JuMIT.Acquisition.Src_fixed  \u2014  Method .  Constructor for  Src  data type. Uses same source wavelet, i.e.,  wav  for all sources and supersources  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of sources  fields::Vector{Symbol}  : number of fields the sources are exciting  wav::Array{Float64}  : a source wavelet that is used for all sources and supersources  tgrid::Grid.M1D  : time grid for the wavelet   source  #  JuMIT.Acquisition.Src_fixed_mod  \u2014  Method .  Constructor of  Src , which is typical for a input model such that  the model has  n\u03bb  wavelengths.  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of source per each supersource  fields::Vector{Symbol}  :   Keyword Arguments   mod::Models.Seismic  :  n\u03bb::Int64=10  : number of wavelengths in the mod  wav_func::Function=(fqdom, tgrid)->Signals.Wavelets.ricker(fqdom,tgrid)  : which wavelet to generate, see Signals.Wavelets.jl  tmaxfrac::Float64=1.0  : by default the maximum modelling time is computed using the average velocity and the diagonal distance of the model, use this fraction to increase of reduce the maximum time   source  #  JuMIT.Acquisition.Src_fixed_random  \u2014  Method .  Generate band-limited random source signals   source  #  JuMIT.Acquisition.Src_getvec  \u2014  Method .  return a vector of the order   source  #  JuMIT.Acquisition.Src_tr  \u2014  Method .  Function that returns Src after time reversal  source  #  JuMIT.Acquisition.Src_uspos  \u2014  Method .  Pad  Src   tgrids should be same in all Src  source  #  JuMIT.Acquisition.Src_zeros  \u2014  Method .  Allocate  Src  with zeros depending on the acquisition geometry.  source  #  JuMIT.Acquisition.freqs  \u2014  Method .  Return minimum, maximum and peak frequencies of  Src  source",
            "title": "Acquisition"
        },
        {
            "location": "/reference/#models",
            "text": "#  JuMIT.Models.Seismic  \u2014  Type .  Data type fo represent a seismic model. A contrast function for a model m is given by $\u03c7(m) = \frac{m}{m0}-1$.  Fields   vp0::Vector{Float64}  : [vpmin, vpmax]  vs0::Vector{Float64}  : [vsmin, vsmax]  \u03c10::Vector{Float64}  : [\u03c1min, \u03c1max]  \u03c7vp::Array{Float64,2}  : two-dimensional contrast model (\u03c7) for vp, for e.g., zeros(mgrid.nz, mgrid.nx)  \u03c7vs::Array{Float64}  : two-dimensional contrast model (\u03c7) for vs, for e.g., zeros(mgrid.nz, mgrid.nx)  \u03c7\u03c1::Array{Float64}  : two-dimensional contrast model (\u03c7) for density, for e.g., zeros(mgrid.nz, mgrid.nx)  mgrid::Grid.M2D  : two-dimensional grid to determine the dimensions of models   source  #  Base.copy!  \u2014  Method .  Copy for  Seismic  models. The models should have same bounds and sizes.  source  #  Base.isapprox  \u2014  Method .  Return if two  Seismic  models have same dimensions and bounds.  source  #  Base.isequal  \u2014  Method .  Compare if two  Seismic  models are equal  source  #  Base.iszero  \u2014  Method .  Return true if a  Seismic  model is just allocated with zeros.  source  #  Base.print  \u2014  Function .  Print information about  Seismic  source  #  Base.similar  \u2014  Method .  Return a similar model to the input model, used for allocation.  source  #  JuMIT.Models.Seismic_addon!  \u2014  Method .  Add features to a model.  Arguments   mod::Seismic  : model that is modified   Keyword Arguments   point_loc::Vector{Float64}=[0., 0.,]  : approx location of point pert.  point_pert::Float64=0.0  : perturbation at the point scatterer  ellip_loc::Vector{Float64}=nothing  : location of center of perturbation, [z, x]  ellip_rad::Float64=0.0  : radius of circular perturbation  ellip_pert::Float64=0.1  : perturbation inside a circle  rect_loc::Array{Float64}=nothing  : rectangle location, [zmin, xmin, zmax, xmax]  rect_pert::Float64=0.1  : perturbation in a rectangle  randn_pert::Float64=0.0  : percentage of reference values for additive random noise  fields::Vector{Symbol}=[:\u03c7vp,:\u03c7\u03c1,:\u03c7vs]  : which fields are to be modified?  onlyin  :  mod  is modified only when field values are in these ranges   source  #  JuMIT.Models.Seismic_chainrule!  \u2014  Function .  Use chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.  Arguments   gmod::Seismic  : gradient model  mod::Seismic  : model required for chain rule  g1  : gradient of an objective function with respect  attribs[1]  g2  : gradient of an objective function with respect  attribs[2]  attribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]  :   flag::Int64=1  :   =1  updates  gmod  using  g1  and  g2  =-1  updates  g1  and  g2  using  gmod     source  #  JuMIT.Models.Seismic_get!  \u2014  Method .  Get other dependent model parameters of a seismic model that are not present in  Seismic .   :\u03c1I  : inverse of density  :Zp  : P-wave impedance   source  #  JuMIT.Models.Seismic_pml_pad_trun!  \u2014  Method .  only padding implemented  source  #  JuMIT.Models.Seismic_pml_pad_trun  \u2014  Method .  Extend a seismic model into PML layers  source  #  JuMIT.Models.Seismic_reparameterize!  \u2014  Function .  Re-parameterization routine  that modifies the fields   \u03c7vp  and  \u03c7\u03c1  of an input seismic model using two input vectors.  Arguments   mod::Seismic  : to be updated  x1::Array{Float64,2}  : contrast of inverse bulk modulus  x2::Array{Float64,2}  : contrast of inverse density  attribs:::Vector{Symbol}  : [:\u03c7KI, :\u03c7\u03c1I]   source  #  JuMIT.Models.Seismic_smooth  \u2014  Function .  Apply smoothing to  Seismic  using a Gaussian filter of zwidth and xwidth  Arguments   mod::Seismic  : argument that is modified  zperc::Real  : smoothing percentage in z-direction  xperc::Real=zperc  : smoothing percentage in x-direction   Keyword Arguments   zmin::Real=mod.mgrid.z[1]  :  zmax::Real=mod.mgrid.z[end]  :  xmin::Real=mod.mgrid.x[1]  :  xmax::Real=mod.mgrid.x[end]  :  fields  : fields of seismic model that are to be smooth   source  #  JuMIT.Models.Seismic_trun  \u2014  Method .  Return a truncated seismic model using input bounds. Note that there is no interpolation going on here, but only truncation, so  the input bounds cannot be strictly imposed.  Arguments   mod::Seismic  : model that is truncated   Keyword Arguments   zmin::Float64=mod.mgrid.z[1]  :  zmax::Float64=mod.mgrid.z[end]  :  xmin::Float64=mod.mgrid.x[1]  :  xmax::Float64=mod.mgrid.x[end]  :   source  #  JuMIT.Models.Seismic_zeros  \u2014  Method .  Return  Seismic  with zeros everywhere; this method is used for preallocation.  Arguments   mgrid::Grid.M2D  : used for sizes of \u03c7 fields   source  #  JuMIT.Models.adjust_bounds!  \u2014  Function .  Adjust the bounds and hence the reference values. Since the reference values are adjust the \u03c7 fields should also be changed  source  #  JuMIT.Models.bounds  \u2014  Function .  Return medium property bounds based on maximum and minimum values of the array and frac. The bounds cannot be less than zero  source  #  JuMIT.Models.interp_spray!  \u2014  Function .  function to resample in the model domain  Arguments   mod::Seismic  : model  modi::Seismic  : model after interpolation   source  #  JuMIT.Models.pml_pad_trun!  \u2014  Function .  PML Extend a model on all four sides  source  #  JuMIT.Models.\u03c7  \u2014  Function .  Return dimensionless contrast model parameter using the reference value.  Arguments   mod::Array{Float64}  : subsurface parameter  mod0::Vector{Float64}  : reference value is mean of this vector  flag::Int64=1  :   source  #  JuMIT.Models.\u03c7g  \u2014  Function .  Gradients Return contrast model parameter using the reference value.  source",
            "title": "Models"
        },
        {
            "location": "/reference/#data",
            "text": "#  JuMIT.Data  \u2014  Module .  This module defines the data types related to seismic data:   TD  : time domain representation   It also provides methods that apply source and receiver filters onto  seismic data.  source  #  JuMIT.Data.Param_error  \u2014  Type .  Calculate the distance between the observed data  y  and the calculated data  x . The time grid of the observed data can be different from that of the modelled data. The acqistion geometry of both the data sets should be the same.  If  J  is the distance, the gradient of the misfit w.r.t to the calculated data is returned as  dJx   w  used for data preconditioning  coupling  source and receiver coupling functions   source  #  JuMIT.Data.TD  \u2014  Type .  Time domain representation of Seismic Data.  Fields   d::Array{Array{Float64,2},2}  : data  fields::Vector{Symbol}  : components recorded at each receiver  tgrid::Grid.M1D  : grid to represent time  acqgeom::Acquisition.Geom  : acquisition geometry used to generate the data   source  #  Base.LinAlg.dot  \u2014  Method .  Returns dot product of data.  Arguments   data1::TD  : data 1  data2::TD  : data 2   Return   dot product as  Float64   source  #  Base.copy!  \u2014  Method .  Copy  TD 's, which are similar.  source  #  Base.isapprox  \u2014  Method .  Return if two  TD 's have same dimensions and bounds.  source  #  Base.isequal  \u2014  Method .  Compare if two  TD 's  are equal  source  #  Base.iszero  \u2014  Method .  Returns bool depending on if input  data::TD  has all zeros or not.  source  #  Base.var  \u2014  Method .  Returns the variance of data  source  #  JuMIT.Data.TD_normalize  \u2014  Function .  Normalize time-domain seismic data.  Arguments   data::TD  : input data   attrib::Symbol  : decide kind of normalization   =:recrms  the record at every receiver is normalized with its RMS value  =:recmax  the record at every receiver is normalized with its maximum value     Return   normalized data as  TD   source  #  JuMIT.Data.TD_ones  \u2014  Method .  Same as  TD_zeros , except for returning ones  source  #  JuMIT.Data.TD_tr!  \u2014  Method .  Time reverse the records of each receiver in  TD    Arguments   data::TD  : input data that is modified   source  #  JuMIT.Data.TD_urpos  \u2014  Method .  Construct TD using data at all the unique receiver positions for all supersources.   d::Array{Float64}  : the data matrix ordered in order such that time-domain modelling schemes are fast, i.e., [irec,ifield,it,nss]   source  #  JuMIT.Data.TD_weight!  \u2014  Method .  Apply different weighting functions to  TD . Use this method to create a  data preconditioning matrix  Arguments Modified   dw::TD  :   Keyword Arguments   offsetlim::Vector{Float64}=[-Inf,Inf]  : [xoffsetlim, zoffsetlim], where the records with offsets >  offsetlim  are given zero weight  tlim::Vector{Float64}=[dw.tgrid.x[1], dw.tgrid.x[end]]  : [tminimum, tmaximum], time mute window  offsetpow::Vector{Float64}=[0.0,0.0]  :  tpow::Float64=0.0  :  ttaperperc::Float64=0.  : taper window percentage for time window  NOTE: if more than one simultaneous source are present, their mean position is considered to calculate offset.   source  #  JuMIT.Data.TD_zeros  \u2014  Method .  Method used to preallocate  TD  with zeros.  Arguments   fields::Vector{Symbol}  : number of components  tgrid::Grid.M1D  : time domain grid  acqgeom::Acquisition.Geom  : acquisition geometry   Return   data with zeros as  TD   source  #  JuMIT.Data.TDcoup!  \u2014  Method .  Apply source and receiver coupling functions to TD. Currently, only source filters are applied.  Arguments   s::TD  : input data  r::TD  : input data  w::Coupling.TD  : input source and receiver filters   attrib::Symbol  : attribute to    =:s  to apply  w  to  r  and modify  s  =:r  to apply adjoint of  w  to  s  and modify  r  =:w  modify  w  using  r  and  s     TODO: need to work on parallelization and speed up here  source  #  JuMIT.Data.interp  \u2014  Method .  Method to resample data in time.  Arguments   data::TD  : input data of type  TD  tgrid::Grid.M1D  : resampling in time according to this time grid   Return   data after resampling as  TD   source  #  JuMIT.Data.interp_spray!  \u2014  Function .  Method to resample data in time. Can reduce allocations =========  Arguments   data::TD  : input data of type  TD  dataout::TD  : preallocated data of type  TD  that is modified   source",
            "title": "Data"
        },
        {
            "location": "/reference/#gallery",
            "text": "#  JuMIT.Gallery.Geom  \u2014  Method .  Gallery of acquisition geometries  Geom  using an input mesh  M2D . The sources and receivers are not placed anywhere on the edges of the mesh.  Arguments   mgrid::Grid.M2D  : a 2-D mesh   attrib::Symbol  : attribute decides output   =:xwell  cross-well acquisition  =:surf  surface acquisition  =:vsp  vertical seismic profiling  =:rvsp   reverse vertical seismic profiling  =:downhole  downhole sources and receivers     Keyword Arguments   nss=2  : number of supersources  nr=2  : number of receivers per supersource  rand_flags::Vector{Bool}=[false, false]  : randomly or equally spaced supersources and receivers.   source  #  JuMIT.Gallery.M1D  \u2014  Method .  Gallery of  M1D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a time grid for with 1000 samples; maximum time is 2 s  attrib=:acou_homo1_long  : a time grid for with 1000 samples; maximum time is 4 s  attrib=:npow2samp1  : a sample npow2 grid with 16 samples   source  #  JuMIT.Gallery.M2D  \u2014  Method .  Gallery of  M2D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a square grid for with 201 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.   attrib=:acou_homo2  : a square grid for with 51 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.  source  #  JuMIT.Gallery.Seismic  \u2014  Function .  Gallery of  Seismic  models.  Arguments   attrib::Symbol  :   Outputs    attrib=:acou_homo1  : an homogeneous acoustic model with  vp0=2000  and  \u03c10=2000   attrib=:acou_homo2  : same as above, but with spatial sampling as 40 m (faster testing)  attrib=:seismic_marmousi2  : marmousi model with lower resolution; ideal for surface seismic experiments  attrib=:seismic_marmousi2_high_res  : marmousi model high resolution; slower to load  attrib=:seismic_marmousi2_xwell  : boxed marmousi model ideal for crosswell experiments  attrib=:seismic_marmousi2_surf  : boxed marmousi2 for surface seismic experiments  attrib=:seismic_marmousi2_downhole  : boxed marmousi2 for downhole seismic experiments     source  #  JuMIT.Gallery.Src  \u2014  Function .  Gallery of source signals  Src .  Arguments   attrib::Symbol  :  nss::Int64=1  : number of supersources   Outputs   attrib=:acou_homo1  :   source",
            "title": "Gallery"
        },
        {
            "location": "/reference/#fdtd",
            "text": "#  JuMIT.Fdtd.Param  \u2014  Method .  Method to create  Fdtd  modeling parameters. The output of this method can be used as an input to  mod! , where the actual  finite-difference modeling is performed.  Keyword Arguments   npw::Int64=1  : number of independently propagating wavefields in  model  model::Models.Seismic=Gallery.Seismic(:acou_homo1)  : seismic medium parameters  model_pert::Models.Seismic=model  : perturbed model, i.e., model + \u03b4model, used only for Born modeling  tgridmod::Grid.M1D=Gallery.M1D(:acou_homo1)  : modeling time grid, maximum time in tgridmod should be greater than or equal to maximum source time, same sampling interval as the wavelet  tgrid::Grid.M1D=tgridmod  : output records are resampled on this time grid  acqgeom::Vector{Acquisition.Geom}=fill(Gallery.Geom(:acou_homo1),npw)  :  acquisition geometry for each independently propagating wavefield  acqsrc::Vector{Acquisition.Src}=fill(Gallery.Src(:acou_homo1),npw)  : source acquisition parameters for each independently propagating wavefield   sflags::Vector{Int64}=fill(2,npw)  : source related flags for each propagating wavefield   =[0]  inactive sources  =[1]  sources with injection rate  =[2]  volume injection sources  =[3]  sources input after time reversal (use only during backpropagation)   rflags::Vector{Int64}=fill(1,npw)  : receiver related flags for each propagating wavefield    =[0]  receivers do not record (or) inactive receivers   =[0,1]  receivers are active only for the second propagating wavefield  rfields::Vector{Symbol}=[:P]  : multi-component receiver flag; types fields the receivers record (to be changed later)   backprop_flag::Bool=Int64  : save final state variables and the boundary conditions for later use    =1  save boundary and final values in  boundary   =-1  use stored values in  boundary  for back propagation   abs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]  : use absorbing PML boundary conditions or not    =[:top, :bottom]  apply PML conditions only at the top and bottom of the model   =[:bottom, :right, :left]  top is reflecting  born_flag::Bool=false  : do only Born modeling instead of full wavefield modelling (to be updated soon)  gmodel_flag=false  : flag that is used to output gradient; there should be atleast two propagating wavefields in order to do so: 1) forward wavefield and 2) adjoint wavefield  illum_flag::Bool=false  : flag to output wavefield energy or source illumination; it can be used as preconditioner during inversion  tsnaps::Vector{Float64}=fill(0.5*(tgridmod.x[end]+tgridmod.x[1]),1)  : store snaps at these modelling times  snaps_flag::Bool=false  : return snaps or not  verbose::Bool=false  : verbose flag     Example  pa   =   JuMIT . Fdtd . Param ( acqgeom = acqgeom ,   acqsrc = acqsrc ,   model = model ,   tgridmod = tgridmod );  JuMIT . Fdtd . mod! ( pa );   Credits  Author: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)   original code in FORTRAN90: March 2013  modified: 11 Sept 2013  major update: 25 July 2014  code optimization with help from Jan Thorbecke: Dec 2015  rewritten in Julia: June 2017  added parrallelization over supersources in Julia: July 2017  efficient parrallelization using distributed arrays: Sept 2017  optimized memory allocation: Oct 2017   source  #  JuMIT.Fdtd.Paramc  \u2014  Type .  Modelling parameters common for all supersources  Keyword Arguments that are modified by the method (some of them are returned as well)   gmodel::Models.Seismic=Models.Seismic_zeros(model.mgrid)  : gradient model modified only if  gmodel_flag  TDout::Vector{Data.TD}=[Data.TD_zeros(rfields,tgridmod,acqgeom[ip]) for ip in 1:length(findn(rflags))]  illum::Array{Float64,2}=zeros(model.mgrid.nz, model.mgrid.nx)  : source energy if  illum_flag  boundary::Array{Array{Float64,4},1}  : stored boundary values for first propagating wavefield  snaps::Array{Float64,4}=zeros(model.mgrid.nz,model.mgrid.nx,length(tsnaps),acqgeom[1].nss)  :snapshots saved at  tsnaps   Return (in order)   modelled data for each propagating wavefield as  Vector{TD}  stored boundary values of the first propagating wavefield as  Array{Array{Float64,4},1}  (use for backpropagation)  final conditions of the first propagating wavefield as  Array{Float64,4}  (use for back propagation)  gradient model as  Seismic  stored snaps shots at tsnaps as Array{Float64,4}   source  #  JuMIT.Fdtd.Paramp  \u2014  Type .  Parameters per every worker, not necessarily for every supersource. Note that a single worker can take care of multiple supersources.  source  #  JuMIT.Fdtd.Paramp  \u2014  Method .  Create modeling parameters for each worker. Each worker performs the modeling of supersources in  sschunks . The parameters common to all workers are stored in  pac .  source  #  JuMIT.Fdtd.Paramss  \u2014  Type .  Modelling parameters per every supersource for each worker  source  #  JuMIT.Fdtd.Paramss  \u2014  Method .  Create modeling parameters for each supersource.  Every worker models one or more supersources.  source  #  JuMIT.Fdtd.get_rhovxI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  JuMIT.Fdtd.get_rhovzI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  JuMIT.Fdtd.mod!  \u2014  Function .  This method updated the input  Fdtd.Param  after the wave propagation.  Arguments   pa::Param  : modelling parameters   Useful fields in  pa  that are modified by the method   pa.c.TDout::Vector{Data.TD}  : seismic data at receivers after modeling, for each propagating wavefield  pa.c.snaps::Array{Float64,4}  : snaps with size  (nz,nx,length(tsnaps),nss)  saved at  tsnaps  pa.c.gmodel::Models.Seismic  : gradient model modified only if  gmodel_flag  pa.c.illum_stack::Array{Float64,2}  source energy of size  (nz,nx)  if  illum_flag   Example  JuMIT . Fdtd . mod! ( pa )   Credits  Author: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)  source  #  JuMIT.Fdtd.pml_variables  \u2014  Method .  Output vectors related to PML boundaries.  source  #  JuMIT.Fdtd.update_model!  \u2014  Function .  Update the  Seismic  models in  Paramc  without additional memory allocation. This routine is used during FWI, where medium parameters are itertively updated.   source",
            "title": "Fdtd"
        },
        {
            "location": "/reference/#fwi",
            "text": "#  JuMIT.FWI  \u2014  Module .  This module defines a type called  Param  that is to be constructed  before performing  and kind of inversion. The following functionality is currently added in this module:   a simple RTM  full-waveform inversion  source and receiver filter inversion   Once a  Param  object is constructed, the following routines update certain fields of the  Param  after performing the inversion.   xfwi!  : updates the initial subsurface models in  Param  using its observed data  wfwi!  : updates the source and receiver filters in  Param  using its observed data   source  #  JuMIT.FWI.Param  \u2014  Type .  FWI Parameters  Fields   mgrid::Grid.M2D  : modelling grid  igrid::Grid.M2D  : inversion grid  acqsrc::Acquisition.Src  : base source wavelet for modelling data  acqgeom::Acquisition.Geom  : acquisition geometry  tgrid::Grid.M1D  :  attrib_mod::Symbol  model_obs  : model used for generating observed data  model0  : background velocity model (only used during Born modeling and inversion)  parameterization  : a vector of Symbols specifying parameterization of the inversion vector  verbose  : print level on STOUT  attrib  : synthetic or real   TODO: add an extra attribute for coupling functions inversion and modelling  source  #  JuMIT.FWI.Param  \u2014  Method .  Constructor for  Param  Arguments   acqsrc::Acquisition.Src  : source time functions  acqgeom::Acquisition.Geom  : acquisition geometry  tgrid::Grid.M1D  : modelling time grid  attrib_mod::Symbol  : modelling attribute  attrib_inv::Symbol  : inversion attribute  modm::Models.Seismic  : seismic model on modelling mesh   Optional Arguments   tgrid_obs::Grid.M1D  : time grid for observed data  igrid::Grid.M2D=modm.mgrid  : inversion grid if different from the modelling grid, i.e.,  modm.mgrid   mprecon_factor::Float64=1  : factor to control model preconditioner, always greater than 1   =1  means the preconditioning is switched off  >1  means the preconditioning is switched on, larger the mprecon_factor, stronger the applied preconditioner becomes  dobs::Data.TD  : observed data  dprecon::Data.TD=Data.TD_ones(1,dobs.tgrid,dobs.acqgeom)  : data preconditioning, defaults to one  tlagssf_fracs=0.0  : maximum lagtime of unknown source filter  tlagrf_fracs=0.0  : maximum lagtime of unknown receiver filter  acqsrc_obs::Acquisition.Src=acqsrc  : source wavelets to generate  observed data ; can be different from  acqsrc  modm_obs::Models.Seismic=modm  : actual seismic model to generate  observed data  modm0::Models.Seismic=modm  : background seismic model for Born modelling and inversion (still being tested)  mod_inv_parameterization::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]  : subsurface parameterization  verbose::Bool=false  : print level on STDOUT during inversion   attrib::Symbol=:synthetic  : an attribute to control class    =:synthetic  synthetic data inversion   =:field  field data inversion     source  #  JuMIT.FWI.AdjGeom  \u2014  Method .  Modify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.  source  #  JuMIT.FWI.Coupling_gx!  \u2014  Method .  Convert dJssf to gradient vector  source  #  JuMIT.FWI.Coupling_x!  \u2014  Method .  Convert coupling functions to x and vice versa  source  #  JuMIT.FWI.F!  \u2014  Function .  Perform a forward simulation. This simulation is common for both functional and gradient calculation. During the computation of the gradient, we need an adjoint simulation. Update the buffer, which consists of the modelled data and boundary values for adjoint calculation.  Arguments   x::Vector{Float64}  : inversion variable  last_x::Vector{Float64}  : buffer is only updated when x!=last_x, and modified such that last_x=x  pa::Param  : parameters that are constant during the inversion  modm::Models.Seismic  :   source  #  JuMIT.FWI.Fadj!  \u2014  Method .   use x and update model in pa  compute gradient   source  #  JuMIT.FWI.Seismic_gx!  \u2014  Method .  Convert gradient vector to  Seismic  type and vice versa This will be different from the previous one, once  the parameterizations come in   gmodm::Models.Seismic  : gradient model on the modelling grid  modm::Models.Seismic  : model on the modelling grid  gmodi::Models.Seismic  : gradient model on the inversion grid  modi::Models.Seismic  : model on the inversion grid  gx::Vector{Float64}  : gradient vector  pa::Param  :   flag::Int64  :   =1  update the vector  gx  using  gmod  =-1  update gmod     source  #  JuMIT.FWI.Seismic_x!  \u2014  Method .  Convert  Seismic  model to x and vice versa   modm  : seismic model on modelling grid (input nothing to not use it)  modi::Models.Seismic  : seismic model on inversion grid  x::Vector{Float64}  : inversion vector  pa::Param  : fwi parameters   flag::Int64  :    =1  converts either modm or modi to x  =-1  updates both modm and modi using x     source  #  JuMIT.FWI.Seismic_xbound!  \u2014  Method .  Return bound vectors for the  Seismic  model,  depeding on paramaterization  source  #  JuMIT.FWI.build_mprecon!  \u2014  Function .  build a model precon  source  #  JuMIT.FWI.func_grad_Coupling!  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  JuMIT.FWI.func_grad_xfwi!  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  JuMIT.FWI.hessian_xfwi!  \u2014  Method .  outdated  source  #  JuMIT.FWI.update_adjsrc!  \u2014  Method .  Convert the data  TD  to  Src  after time reversal.  source  #  JuMIT.FWI.wfwi!  \u2014  Method .  Update pa.w  source  #  JuMIT.FWI.wfwi_ninv  \u2014  Method .  Return the number of inversion variables for source and receiver filter inversion  corresponding to  Param . This number depends on the maximum lagtimes of the filters.   source  #  JuMIT.FWI.xfwi!  \u2014  Method .  Full Waveform Inversion using  Optim  package. This method updates  pa.modm  and  pa.dcal . More details about the optional parameters can be found in the documentation of the  Optim   package.  pa.modi  is used as initial model if non-zero.  Arguments that are modified   pa::Param  : inversion parameters   Optional Arguments   extended_trace::Bool=true  : save extended trace  time_limit=Float64=2.0*60.  : time limit for inversion (testing)  iterations::Int64=5  : maximum number of iterations  linesearch_iterations::Int64=3  : maximum number of line search iterations  f_tol::Float64=1e-5  : functional tolerance  g_tol::Float64=1e-8  : gradient tolerance  x_tol::Float64=1e-5  : model tolerance   Outputs    depending on   pa.attrib_inv   =:cls  classic least-squares inversion using adjoint state method  =:migr  return gradient at the first iteration, i.e., a migration image  =:migr_finite_difference  same as above but  not  using adjoint state method; time consuming; only for testing, TODO: implement autodiff here     source  #  JuMIT.FWI.xfwi_ninv  \u2014  Method .  Return the number of inversion variables for FWI corresponding to  Param . This number of inversion variables depend on the size of inversion mesh.  source",
            "title": "FWI"
        },
        {
            "location": "/reference/#interferometry",
            "text": "#  JuMIT.Interferometry.TD_noise_corr  \u2014  Method .  Correlating noise records with reference records   irref  : reference receiver   source  #  JuMIT.Interferometry.TD_virtual_diff  \u2014  Method .  enhance diffractions in the  TD  Keyword Arguments  \u03bbdom::Float64=0.0  : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005)  tlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]  : maximum lag time in the output traces   source",
            "title": "Interferometry"
        },
        {
            "location": "/reference/#poisson",
            "text": "#  JuMIT.Poisson  \u2014  Module .  This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. The following functionality is currently available in this module:   'Forward' problem: given the source, and the conductivity distribution, solve for the electrical potential \u03c8:     Example   problem :   solve   A\u03c8 = \u2207\u22c5 j ;   A = \u2207\u22c5 ( \u03c3 ( x , z ) \u2207 ),   for   \u03c8 .    'Inverse' problem: given wave propagation related pore pressure, and mechanical medium properties, calculate the source term:     Example   problem :   solve   A\u03c8 = - \u2207\u22c5 j ;   A = \u2207\u22c5 ( [ Q * k / \u03b7 ] ( x , z ) \u2207 B * P ),   for   \u2207\u22c5 j ;    The Boundary Value Problem that is currently implemented assumes Neumann boundary conditions at all boundaries.   Developed by:\n Niels Grobbe, Massachusetts Institute of Technology, USA.\n In collaboration with: Aim\u00e9 Fournier & Laurent Demanet, Massachusetts Institute of Technology, USA.\n Date: October, 2017 \n Contact: ngrobbe@gmail.com  source  #  JuMIT.Poisson.solve  \u2014  Method .  Poisson.solve(field,mpars,solflag) solves the forward or inverse Poisson problem in a heterogeneous medium.  Function input arguments:   field  : either source term used in 'forward' mode to get field, or the field (e.g. pore pressure) used in 'inverse' mode to calculate source-term  mpars  : medium parameters for forward or inverse mode  solflag  : Solution flag determining whether to use forward (solflag=1) or inverse mode (solflag=-1) of Poisson solver.   source",
            "title": "Poisson"
        },
        {
            "location": "/reference/#plots",
            "text": "#  RecipesBase.apply_recipe  \u2014  Method .  Plot acquisition geometry  Acquisition.Geom  on and model grid  M2D .  attrib::Symbol=:unique  : default; plots unique source and receiver positions  ssvec::Vector{Int64}  : plot source and receivers of only these supersources  source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot the velocity and density seismic models.  Arguments   model::Models.Seismic  : model that should be plotted   Keyword Arguments   xlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]  : minimum and maximum limits of the second dimension while plotting  zlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]  : minimum and maximum limits of the first dimension while plotting  fields::Vector{Symbol}=[:vp, :\u03c1]  : fields that are to be plotted, see Models.Seismic_get  contrast_flag=false  : plot only the edges of the model  use_bounds=false  : adjust  clim  to the bounds in the seismic model   source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot the source wavelet used for acquisition.  Arguments   acqsrc::Acquisition.Src  : source acquisition parameters   source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot time-domain data of type  Data.TD  Arguments   td::Vector{Data.TD}  : time-domain data to be compared   Keyword Arguments   ssvec::Vector{Vector{Int64}}=fill([1], length(td))  : supersource vector to be plotted  fields::Vector{Int64}=[1]  : field vector to be plotted  tr_flag::Bool=false  : plot time-reversed data when true  attrib::Symbol=:wav  : specify type of plot   source",
            "title": "Plots"
        },
        {
            "location": "/reference/#index",
            "text": "JuMIT.Acquisition  JuMIT.Coupling  JuMIT.Data  JuMIT.FWI  JuMIT.Poisson  JuMIT.Acquisition.Geom  JuMIT.Acquisition.Src  JuMIT.Coupling.TD  JuMIT.Data.Param_error  JuMIT.Data.TD  JuMIT.FWI.Param  JuMIT.FWI.Param  JuMIT.Fdtd.Param  JuMIT.Fdtd.Paramc  JuMIT.Fdtd.Paramp  JuMIT.Fdtd.Paramp  JuMIT.Fdtd.Paramss  JuMIT.Fdtd.Paramss  JuMIT.Models.Seismic  Base.LinAlg.dot  Base.copy!  Base.copy!  Base.isapprox  Base.isapprox  Base.isequal  Base.isequal  Base.isequal  Base.iszero  Base.iszero  Base.print  Base.print  Base.print  Base.similar  Base.var  JuMIT.Acquisition.Geom_add!  JuMIT.Acquisition.Geom_add!  JuMIT.Acquisition.Geom_advance  JuMIT.Acquisition.Geom_boundary  JuMIT.Acquisition.Geom_check  JuMIT.Acquisition.Geom_circ  JuMIT.Acquisition.Geom_find  JuMIT.Acquisition.Geom_fixed  JuMIT.Acquisition.Geom_get  JuMIT.Acquisition.Geom_getvec  JuMIT.Acquisition.Geom_isfixed  JuMIT.Acquisition.Src_fixed  JuMIT.Acquisition.Src_fixed_mod  JuMIT.Acquisition.Src_fixed_random  JuMIT.Acquisition.Src_getvec  JuMIT.Acquisition.Src_tr  JuMIT.Acquisition.Src_uspos  JuMIT.Acquisition.Src_zeros  JuMIT.Acquisition.freqs  JuMIT.Coupling.TD_delta  JuMIT.Data.TD_normalize  JuMIT.Data.TD_ones  JuMIT.Data.TD_tr!  JuMIT.Data.TD_urpos  JuMIT.Data.TD_weight!  JuMIT.Data.TD_zeros  JuMIT.Data.TDcoup!  JuMIT.Data.interp  JuMIT.Data.interp_spray!  JuMIT.FWI.AdjGeom  JuMIT.FWI.Coupling_gx!  JuMIT.FWI.Coupling_x!  JuMIT.FWI.F!  JuMIT.FWI.Fadj!  JuMIT.FWI.Seismic_gx!  JuMIT.FWI.Seismic_x!  JuMIT.FWI.Seismic_xbound!  JuMIT.FWI.build_mprecon!  JuMIT.FWI.func_grad_Coupling!  JuMIT.FWI.func_grad_xfwi!  JuMIT.FWI.hessian_xfwi!  JuMIT.FWI.update_adjsrc!  JuMIT.FWI.wfwi!  JuMIT.FWI.wfwi_ninv  JuMIT.FWI.xfwi!  JuMIT.FWI.xfwi_ninv  JuMIT.Fdtd.get_rhovxI  JuMIT.Fdtd.get_rhovzI  JuMIT.Fdtd.mod!  JuMIT.Fdtd.pml_variables  JuMIT.Fdtd.update_model!  JuMIT.Gallery.Geom  JuMIT.Gallery.M1D  JuMIT.Gallery.M2D  JuMIT.Gallery.Seismic  JuMIT.Gallery.Src  JuMIT.Interferometry.TD_noise_corr  JuMIT.Interferometry.TD_virtual_diff  JuMIT.Models.Seismic_addon!  JuMIT.Models.Seismic_chainrule!  JuMIT.Models.Seismic_get!  JuMIT.Models.Seismic_pml_pad_trun  JuMIT.Models.Seismic_pml_pad_trun!  JuMIT.Models.Seismic_reparameterize!  JuMIT.Models.Seismic_smooth  JuMIT.Models.Seismic_trun  JuMIT.Models.Seismic_zeros  JuMIT.Models.adjust_bounds!  JuMIT.Models.bounds  JuMIT.Models.interp_spray!  JuMIT.Models.pml_pad_trun!  JuMIT.Models.\u03c7  JuMIT.Models.\u03c7g  JuMIT.Poisson.solve  RecipesBase.apply_recipe  RecipesBase.apply_recipe  RecipesBase.apply_recipe  RecipesBase.apply_recipe",
            "title": "Index"
        },
        {
            "location": "/tut/",
            "text": "Tutorials in a seperate repo.",
            "title": "Tutorials"
        }
    ]
}