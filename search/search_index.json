{
    "docs": [
        {
            "location": "/home/",
            "text": "SeismicInversionToolbox\n\n\nThe main tasks of this software are:\n\n\n\n\nForward problem, where the seismic data are generated\n\n\n\n\nusing synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.\n\n\n\n\nCan perform inversion of synthetic scenarios.\n\n\n\n\nFirst, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.\n\n\n\n\nRead\n\n\n\n\nthe measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.\n\n\n\n\nCoding Conventions\n\n\n\n\nThis software is organised into various modules.\n\n\n\n\nEach module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation \n\n\n\n\nThe methods ending with \n!\n ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.\n\n\n\n\n\n\nInstallation\n\n\n\n\nInput and Output Data Format\n\n\nIt is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format. \n\n\n\n\nDemos\n\n\nDemos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Home"
        },
        {
            "location": "/home/#seismicinversiontoolbox",
            "text": "The main tasks of this software are:   Forward problem, where the seismic data are generated   using synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.   Can perform inversion of synthetic scenarios.   First, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.   Read   the measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.",
            "title": "SeismicInversionToolbox"
        },
        {
            "location": "/home/#coding-conventions",
            "text": "This software is organised into various modules.   Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation    The methods ending with  !  ideally should not allocate and memory. They are supposed to be fast and iteratively called inside loops.",
            "title": "Coding Conventions"
        },
        {
            "location": "/home/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/home/#input-and-output-data-format",
            "text": "It is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format.",
            "title": "Input and Output Data Format"
        },
        {
            "location": "/home/#demos",
            "text": "Demos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Demos"
        },
        {
            "location": "/",
            "text": "There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.\n\n\n\n\nGrid\n\n\n```@autodocs\nModules = [JuMIT.Grid]\nOrder   = [:module, :type, :function]\n\n\n<a id='Wavelets-1'>\n</\na\n>\n\n\n\n#\n \nWavelets\n\n\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nJuMIT\n.\nWavelets\n]\n\n\nOrder\n   \n=\n \n[\n:\nmodule\n,\n \n:\ntype\n,\n \n:\nfunction\n]\n\n\n\n\n\n\n\n\nCoupling\n\n\n#\n\n\nJuMIT.Coupling\n \u2014 \nModule\n.\n\n\nThe data recorded at the receivers during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response. The source filter \nssf\n takes into account  the effective wavelet present in the data.  Similarly, the receiver filter \nrf\n takes the receiver coupling into account. The Inversion module can can estimate both \nssf\n and \nrf\n from the seismic data in order to achieve better data fitting. A base source wavelet \nSrc\n is always used to model the data  before applying the time-domain filter data type  described in this module:\n\n\n\n\nTD\n : time domain filters for both source and receivers\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Coupling.TD\n \u2014 \nType\n.\n\n\nTime-domain source and receiver filters.\n\n\nFields\n\n\n\n\nssf::Array{Array{Float64,1},2}\n : source filters for each supersource and recorded component\n\n\nrf::Array{Array{Float64,2},2}\n : receiver filters for each receiver, supersource and recorded component\n\n\nfields::Vector{Symbol}\n :  number of recorded components at receivers\n\n\ntgridssf::Grid.M1D\n : a  time grid for source filters with both positive and negative lags\n\n\ntgridrf::Grid.M1D\n : a  time grid for receiver filters with both positive and negative lags\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Coupling.TD_delta\n \u2014 \nMethod\n.\n\n\nInitialize coupling filters \nTD\n with  delta functions.\n\n\nArguments\n\n\n\n\ntgriddata\n : time grid of the data\n\n\ntlagssf_fracs::Vector{Real}\n : +ve and -ve fractions of source filter\n\n\ntlagrf_fracs::Vector{Real}\n : +ve and -ve fractions for receiver filter\n\n\n\u03b4t:Float64\n : sampling interval in time\n\n\nfields::Vector{Symbol}\n : number of components\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nReturn\n\n\n\n\ntime-domain coupling filters as \nTD\n\n\n\n\nsource\n\n\n\n\nAcquisition\n\n\n#\n\n\nJuMIT.Acquisition\n \u2014 \nModule\n.\n\n\nThis module defines the following data types:\n\n\n\n\nGeom\n : acquisition geometry, i.e., positions of supersources, sources and receivers\n\n\nSrc\n : source related acquisition parameters, e.g., source wavelet\n\n\n\n\nIt also provides methods that either does operations on these data type or  help their construction.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom\n \u2014 \nType\n.\n\n\nAcquisiton has supersources, sources and receivers. Each supersource has \nns\n multiple sources that are  injected (or active) simultaneously. For each supersource, a set of \nnr\n receivers are  recording waves.\n\n\nFields\n\n\n\n\nsx::Vector{Vector{Float64,1},1}\n : $x$ positions of sources\n\n\nsz::Vector{Vector{Float64,1},1}\n : $z$ positions of sources\n\n\nrx::Vector{Vector{Float64,1},1}\n : $x$ positions of receivers\n\n\nrz::Vector{Vector{Float64,1},1}\n : $z$ positions of receivers\n\n\nnss::Int64\n : number of supersources\n\n\nns::Vector{Int64,1}\n : number of sources for every supersource\n\n\nnr::Vector{Int64,1}\n : number of receivers for every supersource\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src\n \u2014 \nType\n.\n\n\nData type for the source related parameters during acquisiton.\n\n\nFields\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Array{Int64}\n : number of sources for each supersource\n\n\nfields::Vector{Symbol}\n : number of fields\n\n\nwav::Array{Float64}\n : wavelets in time domain\n\n\ntgrid::Grid.M1D\n : time grid\n\n\n\n\nsource\n\n\n#\n\n\nBase.isequal\n \u2014 \nFunction\n.\n\n\nCompare if two \nTD\n's  are equal\n\n\nsource\n\n\n#\n\n\nBase.print\n \u2014 \nFunction\n.\n\n\nPriiiint information about \nSrc\n\n\nsource\n\n\n#\n\n\nBase.print\n \u2014 \nFunction\n.\n\n\nPrint information about \nGeom\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAdds input positions as either sources or receivers of every supershot.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAppends the input a vector of acquisition geometries.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_advance\n \u2014 \nFunction\n.\n\n\nAdvance either source or receiver array in an acquisition geometry in horizontal or vertical directions.\n\n\nArguments\n\n\n\n\ngeom::Geom\n : acquisition geometry that is updated\n\n\nadvances::Vector{Float64}=[[0.,0.], [0.,0.,]]\n : source and receiver advancements\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_boundary\n \u2014 \nMethod\n.\n\n\nModify input \nGeom\n such that the output \nGeom\n has either sources or receivers on the boundary of  \nmgrid\n.\n\n\nArguments\n\n\n\n\nacqgeom::Geom\n : input geometry\n\n\nmgrid::Grid.M2D\n : grid to determine the boundary\n\n\n\n\nattrib::Symbol\n : decide return\n\n\n\n\n=:srcborder\n sources on boundary (useful for back propagation)\n\n\n=:recborder\n receivers on boundary\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_check\n \u2014 \nMethod\n.\n\n\nCheck if all the sources and receivers in \nGeom\n are within the model \n\n\nReturn\n\n\n\n\ntrue\n if all the positions within the model, \nfalse\n otherwise\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_circ\n \u2014 \nMethod\n.\n\n\nCircular acquisition. The sources and receivers can also be placed on a circle of radius \nrad\n. The origin of the circle is at \nloc\n.  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by \n\u03b8lim\n\n\nArguments\n\n\n\n\nnss::Int64=10\n : number of supersources\n\n\nnr::Int64=10\n : number receivers for each super source\n\n\nloc::Vector{Float64}=[0.,0.]\n : location of origin\n\n\n\n\nrad::Vector{Float64}=[100.,100.]\n : radius for source and receiver circles, for example,\n\n\n\n\n=[0.,100.]\n for sources at the center of circle\n\n\n\u03b8lim::Vector{Float64}=[0.,\u03c0]\n : acquisition is limited to these angular offsets between 0 and \u03c0\n\n\n\n\n\n\n\n\nReturn\n\n\n\n\na circular acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_find\n \u2014 \nMethod\n.\n\n\nGiven receiver positions \nrpos\n and \nrpos0\n. Returns an array Int indices of the dimension of number of supersources with \ntrue\n at indices, if the waves due to that particular source are  recorded.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_fixed\n \u2014 \nFunction\n.\n\n\nA fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.\n\n\nArguments\n\n\n\n\nssmin::Float64\n : minimum coordinate for sources\n\n\nssmax::Float64\n : maximum coordinate for sources\n\n\nss0::Float64\n : consant coordinate for sources\n\n\nrmin::Float64\n : minimum coordinate for receivers\n\n\nrmax::Float64\n : maximum coordinate for receivers\n\n\nr0::Float64\n : consant coordinate for receivers\n\n\nnss::Int64\n : number of supersources\n\n\nnr::Int64\n : number of receivers\n\n\nssattrib::Symbol=:horizontal\n : supersource array kind \n=:vertical\n : vertical array of supersources \n=:horizontal\n horizontal array of supersources\n\n\nrattrib::Symbol=:horizontal\n : receiver array kind \n=:vertical\n : vertical array of receivers \n=:horizontal\n horizontal array of receivers\n\n\nrand_flags::Vector{Bool}=[false, false]\n : decide placement of supersources and receivers  \n=[true, false]\n : randomly place supersources for regularly spaced receivers \n=[true, true]\n : randomly place supersources and receivers \n=[false, false]\n : regularly spaced supersources and receivers \n=[false, true]\n : randomly place receivers for regularly spaced supersources\n\n\n\n\nReturn\n\n\n\n\na fixed spread acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_get\n \u2014 \nMethod\n.\n\n\nReturn some derived fields of \nGeom\n\n\nArguments\n\n\n\n\nacq::Vector{Geom}\n : a vector of \nGeom\n\n\n\n\nattrib::Symbol\n : attribute to determine the return object \n\n\n\n\n=:nus\n number of unique source positions in acquisition\n\n\n=:nur\n number of unique receiver positions in acquisition\n\n\n=:uspos\n a tuple of x and z positions of all the unique sources\n\n\n=:urpos\n a tuple of x and z position of all the unique receivers\n\n\n=:geomurpos\n a \nGeom\n vector as if all the unique receiver positions are used for each supersource\n\n\n=:geomuspos\n a \nGeom\n vector as if all the unique source positions are used for each supersource\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Geom_isfixed\n \u2014 \nMethod\n.\n\n\nCheck if the input acquisition geometry is fixed spread.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed\n \u2014 \nMethod\n.\n\n\nConstructor for \nSrc\n data type. Uses same source wavelet, i.e., \nwav\n for all sources and supersources\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of sources\n\n\nfields::Vector{Symbol}\n : number of fields the sources are exciting\n\n\nwav::Array{Float64}\n : a source wavelet that is used for all sources and supersources\n\n\ntgrid::Grid.M1D\n : time grid for the wavelet\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed_mod\n \u2014 \nMethod\n.\n\n\nConstructor of \nSrc\n, which is typical for a input model such that  the model has \nn\u03bb\n wavelengths.\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of source per each supersource\n\n\nfields::Vector{Symbol}\n :\n\n\n\n\nKeyword Arguments\n\n\n\n\nmod::Models.Seismic\n :\n\n\nn\u03bb::Int64=10\n : number of wavelengths in the mod\n\n\nwav_func::Function=(fqdom, tgrid)->Signals.Wavelets.ricker(fqdom,tgrid)\n : which wavelet to generate, see Signals.Wavelets.jl\n\n\ntmaxfrac::Float64=1.0\n : by default the maximum modelling time is computed using the average velocity and the diagonal distance of the model, use this fraction to increase of reduce the maximum time\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_fixed_random\n \u2014 \nMethod\n.\n\n\nGenerate band-limited random source signals \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_tr\n \u2014 \nMethod\n.\n\n\nFunction that returns Src after time reversal\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_uspos\n \u2014 \nMethod\n.\n\n\nPad \nSrc\n  tgrids should be same in all Src\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.Src_zeros\n \u2014 \nMethod\n.\n\n\nAllocate \nSrc\n with zeros depending on the acquisition geometry.\n\n\nsource\n\n\n#\n\n\nJuMIT.Acquisition.freqs\n \u2014 \nMethod\n.\n\n\nReturn minimum, maximum and peak frequencies of \nSrc\n\n\nsource\n\n\n\n\nInterpolation\n\n\n```@autodocs\nModules = [JuMIT.Interpolation]\nOrder   = [:module, :type, :function]\n\n\n<\na\n \nid\n=\n'Models-1'\n><\n/a>\n\n\n\n#\n \nModels\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic'\n \nhref\n=\n'#JuMIT.Models.Seismic'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic`\n**\n \n&\nmdash\n;\n \n*\nType\n*\n.\n\n\n\n\n\nData\n \ntype\n \nfo\n \nrepresent\n \na\n \nseismic\n \nmodel\n.\n \nA\n \ncontrast\n \nfunction\n \nfor\n \na\n \nmodel\n \nm\n \nis\n \ngiven\n \nby\n \n$\u03c7\n(\nm\n)\n \n=\n \f\nrac\n{\nm\n}{\nm0\n}\n-\n1\n$\n.\n\n\n\n**\nFields\n**\n\n\n  \n*\n \n`vp0::Vector{Float64}`\n \n:\n \n[\nvpmin\n,\n \nvpmax\n]\n\n  \n*\n \n`vs0::Vector{Float64}`\n \n:\n \n[\nvsmin\n,\n \nvsmax\n]\n\n  \n*\n \n`\u03c10::Vector{Float64}`\n \n:\n \n[\n\u03c1\nmin\n,\n \n\u03c1\nmax\n]\n\n  \n*\n \n`\u03c7vp::Array{Float64,2}`\n \n:\n \ntwo\n-\ndimensional\n \ncontrast\n \nmodel\n \n(\n\u03c7\n)\n \nfor\n \nvp\n,\n \nfor\n \ne\n.\ng\n.,\n \nzeros\n(\nmgrid\n.\nnz\n,\n \nmgrid\n.\nnx\n)\n\n  \n*\n \n`\u03c7vs::Array{Float64}`\n \n:\n \ntwo\n-\ndimensional\n \ncontrast\n \nmodel\n \n(\n\u03c7\n)\n \nfor\n \nvs\n,\n \nfor\n \ne\n.\ng\n.,\n \nzeros\n(\nmgrid\n.\nnz\n,\n \nmgrid\n.\nnx\n)\n\n  \n*\n \n`\u03c7\u03c1::Array{Float64}`\n \n:\n \ntwo\n-\ndimensional\n \ncontrast\n \nmodel\n \n(\n\u03c7\n)\n \nfor\n \ndensity\n,\n \nfor\n \ne\n.\ng\n.,\n \nzeros\n(\nmgrid\n.\nnz\n,\n \nmgrid\n.\nnx\n)\n\n  \n*\n \n`mgrid::Grid.M2D`\n \n:\n \ntwo\n-\ndimensional\n \ngrid\n \nto\n \ndetermine\n \nthe\n \ndimensions\n \nof\n \nmodels\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L13-L26'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.copy!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n \nhref\n=\n'#Base.copy!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`Base.copy!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nCopy\n \nfor\n \n`Seismic`\n \nmodels\n.\n \nThe\n \nmodels\n \nshould\n \nhave\n \nsame\n \nbounds\n \nand\n \nsizes\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L152-L154'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.isapprox-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n \nhref\n=\n'#Base.isapprox-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`Base.isapprox`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \nif\n \ntwo\n \n`Seismic`\n \nmodels\n \nhave\n \nsame\n \ndimensions\n \nand\n \nbounds\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L139-L141'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.isequal-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n \nhref\n=\n'#Base.isequal-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`Base.isequal`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nCompare\n \nif\n \ntwo\n \n`Seismic`\n \nmodels\n \nare\n \nequal\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L132'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.iszero-Tuple{JuMIT.Models.Seismic}'\n \nhref\n=\n'#Base.iszero-Tuple{JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`Base.iszero`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \ntrue\n \nif\n \na\n \n`Seismic`\n \nmodel\n \nis\n \njust\n \nallocated\n \nwith\n \nzeros\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L115-L117'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.print'\n \nhref\n=\n'#Base.print'\n>\n#\n<\n/a>\n\n\n**\n`Base.print`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nPrint\n \ninformation\n \nabout\n \n`Seismic`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L54-L56'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.similar-Tuple{JuMIT.Models.Seismic}'\n \nhref\n=\n'#Base.similar-Tuple{JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`Base.similar`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \na\n \nsimilar\n \nmodel\n \nto\n \nthe\n \ninput\n \nmodel\n,\n \nused\n \nfor\n \nallocation\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L122-L124'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_addon!-Tuple{JuMIT.Models.Seismic}'\n \nhref\n=\n'#JuMIT.Models.Seismic_addon!-Tuple{JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_addon!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nAdd\n \nfeatures\n \nto\n \na\n \nmodel\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nmodel\n \nthat\n \nis\n \nmodified\n\n\n\n**\nKeyword\n \nArguments\n**\n\n\n  \n*\n \n`point_loc::Vector{Float64}=[0., 0.,]`\n \n:\n \napprox\n \nlocation\n \nof\n \npoint\n \npert\n.\n\n  \n*\n \n`point_pert::Float64=0.0`\n \n:\n \nperturbation\n \nat\n \nthe\n \npoint\n \nscatterer\n\n  \n*\n \n`ellip_loc::Vector{Float64}=nothing`\n \n:\n \nlocation\n \nof\n \ncenter\n \nof\n \nperturbation\n,\n \n[\nz\n,\n \nx\n]\n\n  \n*\n \n`ellip_rad::Float64=0.0`\n \n:\n \nradius\n \nof\n \ncircular\n \nperturbation\n\n  \n*\n \n`ellip_pert::Float64=0.1`\n \n:\n \nperturbation\n \ninside\n \na\n \ncircle\n\n  \n*\n \n`rect_loc::Array{Float64}=nothing`\n \n:\n \nrectangle\n \nlocation\n,\n \n[\nzmin\n,\n \nxmin\n,\n \nzmax\n,\n \nxmax\n]\n\n  \n*\n \n`rect_pert::Float64=0.1`\n \n:\n \nperturbation\n \nin\n \na\n \nrectangle\n\n  \n*\n \n`randn_pert::Float64=0.0`\n \n:\n \npercentage\n \nof\n \nreference\n \nvalues\n \nfor\n \nadditive\n \nrandom\n \nnoise\n\n  \n*\n \n`fields::Vector{Symbol}=[:\u03c7vp,:\u03c7\u03c1,:\u03c7vs]`\n \n:\n \nwhich\n \nfields\n \nare\n \nto\n \nbe\n \nmodified\n?\n\n  \n*\n \n`onlyin`\n \n:\n \n`mod`\n \nis\n \nmodified\n \nonly\n \nwhen\n \nfield\n \nvalues\n \nare\n \nin\n \nthese\n \nranges\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L471-L489'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_chainrule!'\n \nhref\n=\n'#JuMIT.Models.Seismic_chainrule!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_chainrule!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nUse\n \nchain\n \nrule\n \nto\n \noutput\n \ngradients\n \nwith\n  \nrespect\n \nto\n \n\u03c7\nvp\n \nand\n \n\u03c7\u03c1\n \nfrom\n  \ngradients\n  \nwith\n \nrespect\n \nto\n \nKI\n \nand\n \n\u03c1\nI\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`gmod::Seismic`\n \n:\n \ngradient\n \nmodel\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nmodel\n \nrequired\n \nfor\n \nchain\n \nrule\n\n  \n*\n \n`g1`\n \n:\n \ngradient\n \nof\n \nan\n \nobjective\n \nfunction\n \nwith\n \nrespect\n \n`attribs[1]`\n\n  \n*\n \n`g2`\n \n:\n \ngradient\n \nof\n \nan\n \nobjective\n \nfunction\n \nwith\n \nrespect\n \n`attribs[2]`\n\n  \n*\n \n`attribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]`\n \n:\n\n  \n*\n \n`flag::Int64=1`\n \n:\n\n\n      \n*\n \n`=1`\n \nupdates\n \n`gmod`\n \nusing\n \n`g1`\n \nand\n \n`g2`\n\n      \n*\n \n`=-1`\n \nupdates\n \n`g1`\n \nand\n \n`g2`\n \nusing\n \n`gmod`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L305-L320'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_get!-Tuple{Array{Float64,2},JuMIT.Models.Seismic,Symbol}'\n \nhref\n=\n'#JuMIT.Models.Seismic_get!-Tuple{Array{Float64,2},JuMIT.Models.Seismic,Symbol}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_get!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nGet\n \nother\n \ndependent\n \nmodel\n \nparameters\n \nof\n \na\n \nseismic\n \nmodel\n \nthat\n \nare\n \nnot\n \npresent\n \nin\n \n`Seismic`\n.\n\n\n  \n*\n \n`:\u03c1I`\n \n:\n \ninverse\n \nof\n \ndensity\n\n  \n*\n \n`:Zp`\n \n:\n \nP\n-\nwave\n \nimpedance\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L198-L204'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_pml_pad_trun!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n \nhref\n=\n'#JuMIT.Models.Seismic_pml_pad_trun!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_pml_pad_trun!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nonly\n \npadding\n \nimplemented\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L655'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_pml_pad_trun-Tuple{JuMIT.Models.Seismic}'\n \nhref\n=\n'#JuMIT.Models.Seismic_pml_pad_trun-Tuple{JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_pml_pad_trun`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nExtend\n \na\n \nseismic\n \nmodel\n \ninto\n \nPML\n \nlayers\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L642-L644'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_reparameterize!'\n \nhref\n=\n'#JuMIT.Models.Seismic_reparameterize!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_reparameterize!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nRe\n-\nparameterization\n \nroutine\n  \nthat\n \nmodifies\n \nthe\n \nfields\n  \n`\u03c7vp`\n \nand\n \n`\u03c7\u03c1`\n \nof\n \nan\n \ninput\n \nseismic\n \nmodel\n \nusing\n \ntwo\n \ninput\n \nvectors\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nto\n \nbe\n \nupdated\n\n  \n*\n \n`x1::Array{Float64,2}`\n \n:\n \ncontrast\n \nof\n \ninverse\n \nbulk\n \nmodulus\n\n  \n*\n \n`x2::Array{Float64,2}`\n \n:\n \ncontrast\n \nof\n \ninverse\n \ndensity\n\n  \n*\n \n`attribs:::Vector{Symbol}`\n \n:\n \n[\n:\n\u03c7\nKI\n,\n \n:\n\u03c7\u03c1\nI\n]\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L271-L283'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_smooth'\n \nhref\n=\n'#JuMIT.Models.Seismic_smooth'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_smooth`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nApply\n \nsmoothing\n \nto\n \n`Seismic`\n \nusing\n \na\n \nGaussian\n \nfilter\n \nof\n \nzwidth\n \nand\n \nxwidth\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nargument\n \nthat\n \nis\n \nmodified\n\n  \n*\n \n`zperc::Real`\n \n:\n \nsmoothing\n \npercentage\n \nin\n \nz\n-\ndirection\n\n  \n*\n \n`xperc::Real=zperc`\n \n:\n \nsmoothing\n \npercentage\n \nin\n \nx\n-\ndirection\n\n\n\n**\nKeyword\n \nArguments\n**\n\n\n  \n*\n \n`zmin::Real=mod.mgrid.z[1]`\n \n:\n\n  \n*\n \n`zmax::Real=mod.mgrid.z[end]`\n \n:\n\n  \n*\n \n`xmin::Real=mod.mgrid.x[1]`\n \n:\n\n  \n*\n \n`xmax::Real=mod.mgrid.x[end]`\n \n:\n\n  \n*\n \n`fields`\n \n:\n \nfields\n \nof\n \nseismic\n \nmodel\n \nthat\n \nare\n \nto\n \nbe\n \nsmooth\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L557-L573'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_trun-Tuple{JuMIT.Models.Seismic}'\n \nhref\n=\n'#JuMIT.Models.Seismic_trun-Tuple{JuMIT.Models.Seismic}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_trun`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \na\n \ntruncated\n \nseismic\n \nmodel\n \nusing\n \ninput\n \nbounds\n.\n \nNote\n \nthat\n \nthere\n \nis\n \nno\n \ninterpolation\n \ngoing\n \non\n \nhere\n,\n \nbut\n \nonly\n \ntruncation\n,\n \nso\n  \nthe\n \ninput\n \nbounds\n \ncannot\n \nbe\n \nstrictly\n \nimposed\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nmodel\n \nthat\n \nis\n \ntruncated\n\n\n\n**\nKeyword\n \nArguments\n**\n\n\n  \n*\n \n`zmin::Float64=mod.mgrid.z[1]`\n \n:\n\n  \n*\n \n`zmax::Float64=mod.mgrid.z[end]`\n \n:\n\n  \n*\n \n`xmin::Float64=mod.mgrid.x[1]`\n \n:\n\n  \n*\n \n`xmax::Float64=mod.mgrid.x[end]`\n \n:\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L598-L612'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.Seismic_zeros-Tuple{Grid.M2D}'\n \nhref\n=\n'#JuMIT.Models.Seismic_zeros-Tuple{Grid.M2D}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.Seismic_zeros`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \n`Seismic`\n \nwith\n \nzeros\n \neverywhere\n;\n \nthis\n \nmethod\n \nis\n \nused\n \nfor\n \npreallocation\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mgrid::Grid.M2D`\n \n:\n \nused\n \nfor\n \nsizes\n \nof\n \n\u03c7\n \nfields\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L96-L102'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.adjust_bounds!'\n \nhref\n=\n'#JuMIT.Models.adjust_bounds!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.adjust_bounds!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nAdjust\n \nthe\n \nbounds\n \nand\n \nhence\n \nthe\n \nreference\n \nvalues\n.\n \nSince\n \nthe\n \nreference\n \nvalues\n \nare\n \nadjust\n \nthe\n \n\u03c7\n \nfields\n \nshould\n \nalso\n \nbe\n \nchanged\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L80-L83'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.bounds'\n \nhref\n=\n'#JuMIT.Models.bounds'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.bounds`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nReturn\n \nmedium\n \nproperty\n \nbounds\n \nbased\n \non\n \nmaximum\n \nand\n \nminimum\n \nvalues\n \nof\n \nthe\n \narray\n \nand\n \nfrac\n.\n \nThe\n \nbounds\n \ncannot\n \nbe\n \nless\n \nthan\n \nzero\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L67-L70'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.interp_spray!'\n \nhref\n=\n'#JuMIT.Models.interp_spray!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.interp_spray!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nfunction\n \nto\n \nresample\n \nin\n \nthe\n \nmodel\n \ndomain\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Seismic`\n \n:\n \nmodel\n\n  \n*\n \n`modi::Seismic`\n \n:\n \nmodel\n \nafter\n \ninterpolation\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L718-L724'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.pml_pad_trun!'\n \nhref\n=\n'#JuMIT.Models.pml_pad_trun!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.pml_pad_trun!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nPML\n \nExtend\n \na\n \nmodel\n \non\n \nall\n \nfour\n \nsides\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L681-L683'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.\u03c7'\n \nhref\n=\n'#JuMIT.Models.\u03c7'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.\u03c7`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nReturn\n \ndimensionless\n \ncontrast\n \nmodel\n \nparameter\n \nusing\n \nthe\n \nreference\n \nvalue\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`mod::Array{Float64}`\n \n:\n \nsubsurface\n \nparameter\n\n  \n*\n \n`mod0::Vector{Float64}`\n \n:\n \nreference\n \nvalue\n \nis\n \nmean\n \nof\n \nthis\n \nvector\n\n  \n*\n \n`flag::Int64=1`\n \n:\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L414-L422'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Models.\u03c7g'\n \nhref\n=\n'#JuMIT.Models.\u03c7g'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Models.\u03c7g`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nGradients\n \nReturn\n \ncontrast\n \nmodel\n \nparameter\n \nusing\n \nthe\n \nreference\n \nvalue\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L448-L452'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n\n<\na\n \nid\n=\n'Data-1'\n><\n/a>\n\n\n\n#\n \nData\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data'\n \nhref\n=\n'#JuMIT.Data'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data`\n**\n \n&\nmdash\n;\n \n*\nModule\n*\n.\n\n\n\n\n\nThis\n \nmodule\n \ndefines\n \nthe\n \ndata\n \ntypes\n \nrelated\n \nto\n \nseismic\n \ndata\n:\n\n\n  \n*\n \n`TD`\n \n:\n \ntime\n \ndomain\n \nrepresentation\n\n\n\nIt\n \nalso\n \nprovides\n \nmethods\n \nthat\n \napply\n \nsource\n \nand\n \nreceiver\n \nfilters\n \nonto\n  \nseismic\n \ndata\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L3-L9'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.Param_error'\n \nhref\n=\n'#JuMIT.Data.Param_error'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.Param_error`\n**\n \n&\nmdash\n;\n \n*\nType\n*\n.\n\n\n\n\n\nCalculate\n \nthe\n \ndistance\n \nbetween\n \nthe\n \nobserved\n \ndata\n \n`y`\n \nand\n \nthe\n \ncalculated\n \ndata\n \n`x`\n.\n \nThe\n \ntime\n \ngrid\n \nof\n \nthe\n \nobserved\n \ndata\n \ncan\n \nbe\n \ndifferent\n \nfrom\n \nthat\n \nof\n \nthe\n \nmodelled\n \ndata\n.\n \nThe\n \nacqistion\n \ngeometry\n \nof\n \nboth\n \nthe\n \ndata\n \nsets\n \nshould\n \nbe\n \nthe\n \nsame\n.\n\n\n\nIf\n \n`J`\n \nis\n \nthe\n \ndistance\n,\n \nthe\n \ngradient\n \nof\n \nthe\n \nmisfit\n \nw\n.\nr\n.\nt\n \nto\n \nthe\n \ncalculated\n \ndata\n \nis\n \nreturned\n \nas\n \n`dJx`\n\n\n  \n*\n \n`w`\n \nused\n \nfor\n \ndata\n \npreconditioning\n\n  \n*\n \n`coupling`\n \nsource\n \nand\n \nreceiver\n \ncoupling\n \nfunctions\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L484-L492'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD'\n \nhref\n=\n'#JuMIT.Data.TD'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD`\n**\n \n&\nmdash\n;\n \n*\nType\n*\n.\n\n\n\n\n\nTime\n \ndomain\n \nrepresentation\n \nof\n \nSeismic\n \nData\n.\n\n\n\n**\nFields\n**\n\n\n  \n*\n \n`d::Array{Array{Float64,2},2}`\n \n:\n \ndata\n\n  \n*\n \n`fields::Vector{Symbol}`\n \n:\n \ncomponents\n \nrecorded\n \nat\n \neach\n \nreceiver\n\n  \n*\n \n`tgrid::Grid.M1D`\n \n:\n \ngrid\n \nto\n \nrepresent\n \ntime\n\n  \n*\n \n`acqgeom::Acquisition.Geom`\n \n:\n \nacquisition\n \ngeometry\n \nused\n \nto\n \ngenerate\n \nthe\n \ndata\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L22-L31'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.LinAlg.dot-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n \nhref\n=\n'#Base.LinAlg.dot-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.LinAlg.dot`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturns\n \ndot\n \nproduct\n \nof\n \ndata\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`data1::TD`\n \n:\n \ndata\n \n1\n\n  \n*\n \n`data2::TD`\n \n:\n \ndata\n \n2\n\n\n\n**\nReturn\n**\n\n\n  \n*\n \ndot\n \nproduct\n \nas\n \n`Float64`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L248-L259'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.copy!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n \nhref\n=\n'#Base.copy!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.copy!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nCopy\n \n`TD`\n's, which are similar.\n\n\n\n\n<a target='\n_blank\n' href='\nhttps\n:\n//github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L71-L73' class='documenter-source'>source</a><br>\n\n\n\n<\na\n \nid\n=\n'Base.isapprox-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n \nhref\n=\n'#Base.isapprox-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.isapprox`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturn\n \nif\n \ntwo\n \n`TD`\n's have same dimensions and bounds.\n\n\n\n\n<a target='\n_blank\n' href='\nhttps\n:\n//github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L55-L57' class='documenter-source'>source</a><br>\n\n\n\n<\na\n \nid\n=\n'Base.isequal-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n \nhref\n=\n'#Base.isequal-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.isequal`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nCompare\n \nif\n \ntwo\n \n`TD`\n's  are equal\n\n\n\n\n<a target='\n_blank\n' href='\nhttps\n:\n//github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L48' class='documenter-source'>source</a><br>\n\n\n\n<\na\n \nid\n=\n'Base.iszero-Tuple{JuMIT.Data.TD}'\n \nhref\n=\n'#Base.iszero-Tuple{JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.iszero`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturns\n \nbool\n \ndepending\n \non\n \nif\n \ninput\n \n`data::TD`\n \nhas\n \nall\n \nzeros\n \nor\n \nnot\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L182-L184'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'Base.var-Tuple{JuMIT.Data.TD}'\n \nhref\n=\n'#Base.var-Tuple{JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`Base.var`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nReturns\n \nthe\n \nvariance\n \nof\n \ndata\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L201-L204'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_normalize'\n \nhref\n=\n'#JuMIT.Data.TD_normalize'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_normalize`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nNormalize\n \ntime\n-\ndomain\n \nseismic\n \ndata\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`data::TD`\n \n:\n \ninput\n \ndata\n\n  \n*\n \n`attrib::Symbol`\n \n:\n \ndecide\n \nkind\n \nof\n \nnormalization\n\n\n      \n*\n \n`=:recrms`\n \nthe\n \nrecord\n \nat\n \nevery\n \nreceiver\n \nis\n \nnormalized\n \nwith\n \nits\n \nRMS\n \nvalue\n\n      \n*\n \n`=:recmax`\n \nthe\n \nrecord\n \nat\n \nevery\n \nreceiver\n \nis\n \nnormalized\n \nwith\n \nits\n \nmaximum\n \nvalue\n\n\n\n**\nReturn\n**\n\n\n  \n*\n \nnormalized\n \ndata\n \nas\n \n`TD`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L275-L288'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_ones-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'\n \nhref\n=\n'#JuMIT.Data.TD_ones-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_ones`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nSame\n \nas\n \n`TD_zeros`\n,\n \nexcept\n \nfor\n \nreturning\n \nones\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L175'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_tr!-Tuple{JuMIT.Data.TD}'\n \nhref\n=\n'#JuMIT.Data.TD_tr!-Tuple{JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_tr!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nTime\n \nreverse\n \nthe\n \nrecords\n \nof\n \neach\n \nreceiver\n \nin\n \n`TD`\n \n\n\n**\nArguments\n**\n\n\n  \n*\n \n`data::TD`\n \n:\n \ninput\n \ndata\n \nthat\n \nis\n \nmodified\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L189-L195'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_urpos-Tuple{Array{Float64,N} where N,Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom,Int64,Tuple{Array{Float64,1},Array{Float64,1}}}'\n \nhref\n=\n'#JuMIT.Data.TD_urpos-Tuple{Array{Float64,N} where N,Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom,Int64,Tuple{Array{Float64,1},Array{Float64,1}}}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_urpos`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nConstruct\n \nTD\n \nusing\n \ndata\n \nat\n \nall\n \nthe\n \nunique\n \nreceiver\n \npositions\n \nfor\n \nall\n \nsupersources\n.\n\n\n  \n*\n \n`d::Array{Float64}`\n \n:\n \nthe\n \ndata\n \nmatrix\n \nordered\n \nin\n \norder\n \nsuch\n \nthat\n \ntime\n-\ndomain\n \nmodelling\n \nschemes\n \nare\n \nfast\n,\n \ni\n.\ne\n.,\n \n[\nirec\n,\nifield\n,\nit\n,\nnss\n]\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L343-L349'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_weight!-Tuple{JuMIT.Data.TD}'\n \nhref\n=\n'#JuMIT.Data.TD_weight!-Tuple{JuMIT.Data.TD}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_weight!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nApply\n \ndifferent\n \nweighting\n \nfunctions\n \nto\n \n`TD`\n.\n \nUse\n \nthis\n \nmethod\n \nto\n \ncreate\n \na\n  \ndata\n \npreconditioning\n \nmatrix\n\n\n\n**\nArguments\n \nModified\n**\n\n\n  \n*\n \n`dw::TD`\n \n:\n\n\n\n**\nKeyword\n \nArguments\n**\n\n\n  \n*\n \n`offsetlim::Vector{Float64}=[-Inf,Inf]`\n \n:\n \n[\nxoffsetlim\n,\n \nzoffsetlim\n],\n \nwhere\n \nthe\n \nrecords\n \nwith\n \noffsets\n \n>\n \n`offsetlim`\n \nare\n \ngiven\n \nzero\n \nweight\n\n  \n*\n \n`tlim::Vector{Float64}=[dw.tgrid.x[1], dw.tgrid.x[end]]`\n \n:\n \n[\ntminimum\n,\n \ntmaximum\n],\n \ntime\n \nmute\n \nwindow\n\n  \n*\n \n`offsetpow::Vector{Float64}=[0.0,0.0]`\n \n:\n\n  \n*\n \n`tpow::Float64=0.0`\n \n:\n\n  \n*\n \n`ttaperperc::Float64=0.`\n \n:\n \ntaper\n \nwindow\n \npercentage\n \nfor\n \ntime\n \nwindow\n\n  \n*\n \nNOTE\n: \nif\n \nmore\n \nthan\n \none\n \nsimultaneous\n \nsource\n \nare\n \npresent\n,\n \ntheir\n \nmean\n \nposition\n \nis\n \nconsidered\n \nto\n \ncalculate\n \noffset\n.\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L415-L432'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TD_zeros-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'\n \nhref\n=\n'#JuMIT.Data.TD_zeros-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TD_zeros`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nMethod\n \nused\n \nto\n \npreallocate\n \n`TD`\n \nwith\n \nzeros\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`fields::Vector{Symbol}`\n \n:\n \nnumber\n \nof\n \ncomponents\n\n  \n*\n \n`tgrid::Grid.M1D`\n \n:\n \ntime\n \ndomain\n \ngrid\n\n  \n*\n \n`acqgeom::Acquisition.Geom`\n \n:\n \nacquisition\n \ngeometry\n\n\n\n**\nReturn\n**\n\n\n  \n*\n \ndata\n \nwith\n \nzeros\n \nas\n \n`TD`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L147-L159'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.TDcoup!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD,JuMIT.Coupling.TD,Symbol}'\n \nhref\n=\n'#JuMIT.Data.TDcoup!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD,JuMIT.Coupling.TD,Symbol}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.TDcoup!`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nApply\n \nsource\n \nand\n \nreceiver\n \ncoupling\n \nfunctions\n \nto\n \nTD\n.\n \nCurrently\n,\n \nonly\n \nsource\n \nfilters\n \nare\n \napplied\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`s::TD`\n \n:\n \ninput\n \ndata\n\n  \n*\n \n`r::TD`\n \n:\n \ninput\n \ndata\n\n  \n*\n \n`w::Coupling.TD`\n \n:\n \ninput\n \nsource\n \nand\n \nreceiver\n \nfilters\n\n  \n*\n \n`attrib::Symbol`\n \n:\n \nattribute\n \nto\n \n\n      \n*\n \n`=:s`\n \nto\n \napply\n \n`w`\n \nto\n \n`r`\n \nand\n \nmodify\n \n`s`\n\n      \n*\n \n`=:r`\n \nto\n \napply\n \nadjoint\n \nof\n \n`w`\n \nto\n \n`s`\n \nand\n \nmodify\n \n`r`\n\n      \n*\n \n`=:w`\n \nmodify\n \n`w`\n \nusing\n \n`r`\n \nand\n \n`s`\n\n\n\nTODO\n: \nneed\n \nto\n \nwork\n \non\n \nparallelization\n \nand\n \nspeed\n \nup\n \nhere\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L372-L387'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.interp-Tuple{JuMIT.Data.TD,Grid.M1D}'\n \nhref\n=\n'#JuMIT.Data.interp-Tuple{JuMIT.Data.TD,Grid.M1D}'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.interp`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nMethod\n \nto\n \nresample\n \ndata\n \nin\n \ntime\n.\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`data::TD`\n \n:\n \ninput\n \ndata\n \nof\n \ntype\n \n`TD`\n\n  \n*\n \n`tgrid::Grid.M1D`\n \n:\n \nresampling\n \nin\n \ntime\n \naccording\n \nto\n \nthis\n \ntime\n \ngrid\n\n\n\n**\nReturn\n**\n\n\n  \n*\n \ndata\n \nafter\n \nresampling\n \nas\n \n`TD`\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L91-L102'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n<\na\n \nid\n=\n'JuMIT.Data.interp_spray!'\n \nhref\n=\n'#JuMIT.Data.interp_spray!'\n>\n#\n<\n/a>\n\n\n**\n`JuMIT.Data.interp_spray!`\n**\n \n&\nmdash\n;\n \n*\nFunction\n*\n.\n\n\n\n\n\nMethod\n \nto\n \nresample\n \ndata\n \nin\n \ntime\n.\n \nCan\n \nreduce\n \nallocations\n \n=========\n\n\n\n**\nArguments\n**\n\n\n  \n*\n \n`data::TD`\n \n:\n \ninput\n \ndata\n \nof\n \ntype\n \n`TD`\n\n  \n*\n \n`dataout::TD`\n \n:\n \npreallocated\n \ndata\n \nof\n \ntype\n \n`TD`\n \nthat\n \nis\n \nmodified\n\n\n\n\n<\na\n \ntarget\n=\n'_blank'\n \nhref\n=\n'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L116-L124'\n \nclass\n=\n'documenter-source'\n>\nsource\n<\n/a><br>\n\n\n\n\n<\na\n \nid\n=\n'Misfits-1'\n><\n/a>\n\n\n\n#\n \nMisfits\n\n\n\n\n```@autodocs\n\n\nModules = [JuMIT.Misfits]\n\n\nOrder   = [:module, :type, :function]\n\n\n\n\n\n\n\n\nGallery\n\n\n#\n\n\nJuMIT.Gallery.Geom\n \u2014 \nMethod\n.\n\n\nGallery of acquisition geometries \nGeom\n using an input mesh \nM2D\n. The sources and receivers are not placed anywhere on the edges of the mesh.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : a 2-D mesh\n\n\n\n\nattrib::Symbol\n : attribute decides output\n\n\n\n\n=:xwell\n cross-well acquisition\n\n\n=:surf\n surface acquisition\n\n\n=:vsp\n vertical seismic profiling\n\n\n=:rvsp\n  reverse vertical seismic profiling\n\n\n=:downhole\n downhole sources and receivers\n\n\n\n\n\n\n\n\nKeyword Arguments\n\n\n\n\nnss=2\n : number of supersources\n\n\nnr=2\n : number of receivers per supersource\n\n\nrand_flags::Vector{Bool}=[false, false]\n : randomly or equally spaced supersources and receivers.\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.M1D\n \u2014 \nMethod\n.\n\n\nGallery of \nM1D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a time grid for with 1000 samples; maximum time is 2 s\n\n\nattrib=:acou_homo1_long\n : a time grid for with 1000 samples; maximum time is 4 s\n\n\nattrib=:npow2samp1\n : a sample npow2 grid with 16 samples\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.M2D\n \u2014 \nMethod\n.\n\n\nGallery of \nM2D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a square grid for with 201 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\n\n\nattrib=:acou_homo2\n : a square grid for with 51 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.Seismic\n \u2014 \nFunction\n.\n\n\nGallery of \nSeismic\n models.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\n\n\nattrib=:acou_homo1\n : an homogeneous acoustic model with \nvp0=2000\n and \n\u03c10=2000\n\n\n\n\nattrib=:acou_homo2\n : same as above, but with spatial sampling as 40 m (faster testing)\n\n\nattrib=:seismic_marmousi2\n : marmousi model with lower resolution; ideal for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_high_res\n : marmousi model high resolution; slower to load\n\n\nattrib=:seismic_marmousi2_xwell\n : boxed marmousi model ideal for crosswell experiments\n\n\nattrib=:seismic_marmousi2_surf\n : boxed marmousi2 for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_downhole\n : boxed marmousi2 for downhole seismic experiments\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Gallery.Src\n \u2014 \nFunction\n.\n\n\nGallery of source signals \nSrc\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\nnss::Int64=1\n : number of supersources\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n :\n\n\n\n\nsource\n\n\n\n\nFdtd\n\n\n#\n\n\nJuMIT.Fdtd.Param\n \u2014 \nMethod\n.\n\n\nMethod to create \nFdtd\n modeling parameters. The output of this method can be used as an input to \nmod!\n, where the actual  finite-difference modeling is performed.\n\n\nKeyword Arguments\n\n\n\n\nnpw::Int64=1\n : number of independently propagating wavefields in \nmodel\n\n\nmodel::Models.Seismic=Gallery.Seismic(:acou_homo1)\n : seismic medium parameters\n\n\nmodel_pert::Models.Seismic=model\n : perturbed model, i.e., model + \u03b4model, used only for Born modeling\n\n\ntgridmod::Grid.M1D=Gallery.M1D(:acou_homo1)\n : modeling time grid, maximum time in tgridmod should be greater than or equal to maximum source time, same sampling interval as the wavelet\n\n\ntgrid::Grid.M1D=tgridmod\n : output records are resampled on this time grid\n\n\nacqgeom::Vector{Acquisition.Geom}=fill(Gallery.Geom(:acou_homo1),npw)\n :  acquisition geometry for each independently propagating wavefield\n\n\nacqsrc::Vector{Acquisition.Src}=fill(Gallery.Src(:acou_homo1),npw)\n : source acquisition parameters for each independently propagating wavefield\n\n\n\n\nsflags::Vector{Int64}=fill(2,npw)\n : source related flags for each propagating wavefield\n\n\n\n\n=[0]\n inactive sources\n\n\n=[1]\n sources with injection rate\n\n\n=[2]\n volume injection sources\n\n\n=[3]\n sources input after time reversal (use only during backpropagation)\n\n\n\n\nrflags::Vector{Int64}=fill(1,npw)\n : receiver related flags for each propagating wavefield\n\n\n\n\n\n\n=[0]\n receivers do not record (or) inactive receivers\n\n\n\n\n=[0,1]\n receivers are active only for the second propagating wavefield\n\n\nrfields::Vector{Symbol}=[:P]\n : multi-component receiver flag; types fields the receivers record (to be changed later)\n\n\n\n\nbackprop_flag::Bool=Int64\n : save final state variables and the boundary conditions for later use\n\n\n\n\n\n\n=1\n save boundary and final values in \nboundary\n\n\n\n\n=-1\n use stored values in \nboundary\n for back propagation\n\n\n\n\nabs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]\n : use absorbing PML boundary conditions or not\n\n\n\n\n\n\n=[:top, :bottom]\n apply PML conditions only at the top and bottom of the model\n\n\n\n\n=[:bottom, :right, :left]\n top is reflecting\n\n\nborn_flag::Bool=false\n : do only Born modeling instead of full wavefield modelling (to be updated soon)\n\n\ngmodel_flag=false\n : flag that is used to output gradient; there should be atleast two propagating wavefields in order to do so: 1) forward wavefield and 2) adjoint wavefield\n\n\nillum_flag::Bool=false\n : flag to output wavefield energy or source illumination; it can be used as preconditioner during inversion\n\n\ntsnaps::Vector{Float64}=fill(0.5*(tgridmod.x[end]+tgridmod.x[1]),1)\n : store snaps at these modelling times\n\n\nsnaps_flag::Bool=false\n : return snaps or not\n\n\nverbose::Bool=false\n : verbose flag\n\n\n\n\n\n\n\n\nExample\n\n\npa\n \n=\n \nJuMIT\n.\nFdtd\n.\nParam\n(\nacqgeom\n=\nacqgeom\n,\n \nacqsrc\n=\nacqsrc\n,\n \nmodel\n=\nmodel\n,\n \ntgridmod\n=\ntgridmod\n);\n\n\nJuMIT\n.\nFdtd\n.\nmod!\n(\npa\n);\n\n\n\n\n\n\nCredits\n\n\nAuthor: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)\n\n\n\n\noriginal code in FORTRAN90: March 2013\n\n\nmodified: 11 Sept 2013\n\n\nmajor update: 25 July 2014\n\n\ncode optimization with help from Jan Thorbecke: Dec 2015\n\n\nrewritten in Julia: June 2017\n\n\nadded parrallelization over supersources in Julia: July 2017\n\n\nefficient parrallelization using distributed arrays: Sept 2017\n\n\noptimized memory allocation: Oct 2017\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramc\n \u2014 \nType\n.\n\n\nModelling parameters common for all supersources\n\n\nKeyword Arguments that are modified by the method (some of them are returned as well)\n\n\n\n\ngmodel::Models.Seismic=Models.Seismic_zeros(model.mgrid)\n : gradient model modified only if \ngmodel_flag\n\n\nTDout::Vector{Data.TD}=[Data.TD_zeros(rfields,tgridmod,acqgeom[ip]) for ip in 1:length(findn(rflags))]\n\n\nillum::Array{Float64,2}=zeros(model.mgrid.nz, model.mgrid.nx)\n : source energy if \nillum_flag\n\n\nboundary::Array{Array{Float64,4},1}\n : stored boundary values for first propagating wavefield\n\n\nsnaps::Array{Float64,4}=zeros(model.mgrid.nz,model.mgrid.nx,length(tsnaps),acqgeom[1].nss)\n :snapshots saved at \ntsnaps\n\n\n\n\nReturn (in order)\n\n\n\n\nmodelled data for each propagating wavefield as \nVector{TD}\n\n\nstored boundary values of the first propagating wavefield as \nArray{Array{Float64,4},1}\n (use for backpropagation)\n\n\nfinal conditions of the first propagating wavefield as \nArray{Float64,4}\n (use for back propagation)\n\n\ngradient model as \nSeismic\n\n\nstored snaps shots at tsnaps as Array{Float64,4}\n\n\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramp\n \u2014 \nType\n.\n\n\nParameters per every worker, not necessarily for every supersource. Note that a single worker can take care of multiple supersources.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramp\n \u2014 \nMethod\n.\n\n\nCreate modeling parameters for each worker. Each worker performs the modeling of supersources in \nsschunks\n. The parameters common to all workers are stored in \npac\n.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramss\n \u2014 \nType\n.\n\n\nModelling parameters per every supersource for each worker\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.Paramss\n \u2014 \nMethod\n.\n\n\nCreate modeling parameters for each supersource.  Every worker models one or more supersources.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.get_rhovxI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.get_rhovzI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.mod!\n \u2014 \nFunction\n.\n\n\nThis method updated the input \nFdtd.Param\n after the wave propagation.\n\n\nArguments\n\n\n\n\npa::Param\n : modelling parameters\n\n\n\n\nUseful fields in \npa\n that are modified by the method\n\n\n\n\npa.c.TDout::Vector{Data.TD}\n : seismic data at receivers after modeling, for each propagating wavefield\n\n\npa.c.snaps::Array{Float64,4}\n : snaps with size \n(nz,nx,length(tsnaps),nss)\n saved at \ntsnaps\n\n\npa.c.gmodel::Models.Seismic\n : gradient model modified only if \ngmodel_flag\n\n\npa.c.illum_stack::Array{Float64,2}\n source energy of size \n(nz,nx)\n if \nillum_flag\n\n\n\n\nExample\n\n\nJuMIT\n.\nFdtd\n.\nmod!\n(\npa\n)\n\n\n\n\n\n\nCredits\n\n\nAuthor: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.pml_variables\n \u2014 \nMethod\n.\n\n\nOutput vectors related to PML boundaries.\n\n\nsource\n\n\n#\n\n\nJuMIT.Fdtd.update_model!\n \u2014 \nFunction\n.\n\n\nUpdate the \nSeismic\n models in \nParamc\n without additional memory allocation. This routine is used during FWI, where medium parameters are itertively updated. \n\n\nsource\n\n\n\n\nInversion\n\n\n```@autodocs\nModules = [JuMIT.Inversion]\nOrder   = [:module, :type, :function]\n\n\n<a id='Interferometry-1'>\n</\na\n>\n\n\n\n#\n \nInterferometry\n\n\n\n<a id='JuMIT.Interferometry.TD_noise_corr-Tuple{JuMIT.Data.TD}' href='#JuMIT.Interferometry.TD_noise_corr-Tuple{JuMIT.Data.TD}'>\n#\n</\na\n>\n\n\n**\n`\nJuMIT\n.\nInterferometry\n.\nTD_noise_corr\n`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nCorrelating\n \nnoise\n \nrecords\n \nwith\n \nreference\n \nrecords\n\n\n  \n*\n \n`\nirref\n`\n \n:\n \nreference\n \nreceiver\n\n\n\n\n<a target='_blank' href='https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Interferometry.jl#L113-L116' class='documenter-source'>\nsource\n</\na\n><\nbr\n>\n\n\n\n<a id='JuMIT.Interferometry.TD_virtual_diff-Tuple{JuMIT.Data.TD}' href='#JuMIT.Interferometry.TD_virtual_diff-Tuple{JuMIT.Data.TD}'>\n#\n</\na\n>\n\n\n**\n`\nJuMIT\n.\nInterferometry\n.\nTD_virtual_diff\n`\n**\n \n&\nmdash\n;\n \n*\nMethod\n*\n.\n\n\n\n\n\nenhance\n \ndiffractions\n \nin\n \nthe\n \n`\nTD\n`\n\n\n\n**\nKeyword\n \nArguments\n**\n\n\n\n`\n\u03bbdom\n::\nFloat64\n=\n0.0\n`\n \n:\n \ndistance\n \nbetween\n \nreceivers\n \nmust\n \nbe\n \ngreater\n \nthan\n \ntwice\n \ncentral\n \nwavelength\n,\n \n2\n*\n\u03bbdom\n \n(\nShapiro\n \n2005\n)\n \n`\ntlag\n::\nFloat64\n=\ndata\n.\ntgrid\n.\nx\n[\nend\n]-\ndata\n.\ntgrid\n.\nx\n[\n1\n]\n`\n \n:\n \nmaximum\n \nlag\n \ntime\n \nin\n \nthe\n \noutput\n \ntraces\n \n\n\n\n<a target='_blank' href='https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Interferometry.jl#L11-L19' class='documenter-source'>\nsource\n</\na\n><\nbr\n>\n\n\n\n\n<a id='CICA-1'>\n</\na\n>\n\n\n\n#\n \nCICA\n\n\n\n\n```@\nautodocs\n\n\nModules\n \n=\n \n[\nJuMIT\n.\nCICA\n]\n\n\nOrder\n   \n=\n \n[\n:\nmodule\n,\n \n:\ntype\n,\n \n:\nfunction\n]\n\n\n\n\n\n\n\n\nPoisson\n\n\n#\n\n\nJuMIT.Poisson\n \u2014 \nModule\n.\n\n\nThis module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. The following functionality is currently available in this module:\n\n\n\n\n'Forward' problem: given the source, and the conductivity distribution, solve for the electrical potential \u03c8:\n\n\n\n\n \nExample\n \nproblem\n:\n \nsolve\n \nA\u03c8\n=\n\u2207\u22c5\nj\n;\n \nA\n=\n\u2207\u22c5\n(\n\u03c3\n(\nx\n,\nz\n)\n\u2207\n),\n \nfor\n \n\u03c8\n.\n\n\n\n\n\n\n\n\n'Inverse' problem: given wave propagation related pore pressure, and mechanical medium properties, calculate the source term:\n\n\n\n\n \nExample\n \nproblem\n:\n \nsolve\n \nA\u03c8\n=\n-\n\u2207\u22c5\nj\n;\n \nA\n=\n\u2207\u22c5\n(\n[\nQ\n*\nk\n/\n\u03b7\n]\n(\nx\n,\nz\n)\n\u2207\nB\n*\nP\n),\n \nfor\n \n\u2207\u22c5\nj\n;\n\n\n\n\n\n\n\n\nThe Boundary Value Problem that is currently implemented assumes Neumann boundary conditions at all boundaries.\n\n\n\n\nDeveloped by:\n Niels Grobbe, Massachusetts Institute of Technology, USA.\n In collaboration with: Aim\u00e9 Fournier & Laurent Demanet, Massachusetts Institute of Technology, USA.\n Date: October, 2017 \n Contact: ngrobbe@gmail.com\n\n\nsource\n\n\n#\n\n\nJuMIT.Poisson.solve\n \u2014 \nMethod\n.\n\n\nPoisson.solve(field,mpars,solflag) solves the forward or inverse Poisson problem in a heterogeneous medium.\n\n\nFunction input arguments:\n\n\n\n\nfield\n : either source term used in 'forward' mode to get field, or the field (e.g. pore pressure) used in 'inverse' mode to calculate source-term\n\n\nmpars\n : medium parameters for forward or inverse mode\n\n\nsolflag\n : Solution flag determining whether to use forward (solflag=1) or inverse mode (solflag=-1) of Poisson solver.\n\n\n\n\nsource\n\n\n\n\nPlots\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot acquisition geometry \nAcquisition.Geom\n on and model grid \nM2D\n.\n\n\nattrib::Symbol=:unique\n : default; plots unique source and receiver positions \nssvec::Vector{Int64}\n : plot source and receivers of only these supersources\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot the velocity and density seismic models.\n\n\nArguments\n\n\n\n\nmodel::Models.Seismic\n : model that should be plotted\n\n\n\n\nKeyword Arguments\n\n\n\n\nxlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]\n : minimum and maximum limits of the second dimension while plotting\n\n\nzlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]\n : minimum and maximum limits of the first dimension while plotting\n\n\nfields::Vector{Symbol}=[:vp, :\u03c1]\n : fields that are to be plotted, see Models.Seismic_get\n\n\ncontrast_flag=false\n : plot only the edges of the model\n\n\nuse_bounds=false\n : adjust \nclim\n to the bounds in the seismic model\n\n\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot the source wavelet used for acquisition.\n\n\nArguments\n\n\n\n\nacqsrc::Acquisition.Src\n : source acquisition parameters\n\n\n\n\nsource\n\n\n#\n\n\nRecipesBase.apply_recipe\n \u2014 \nMethod\n.\n\n\nPlot time-domain data of type \nData.TD\n\n\nArguments\n\n\n\n\ntd::Vector{Data.TD}\n : time-domain data to be compared\n\n\n\n\nKeyword Arguments\n\n\n\n\nssvec::Vector{Vector{Int64}}=fill([1], length(td))\n : supersource vector to be plotted\n\n\nfields::Vector{Int64}=[1]\n : field vector to be plotted\n\n\ntr_flag::Bool=false\n : plot time-reversed data when true\n\n\nattrib::Symbol=:wav\n : specify type of plot\n\n\n\n\nsource\n\n\n%## Another Section %\n@contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %\n %  %\n@contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %\n\n\n\n\nIndex\n\n\n\n\nJuMIT.Acquisition\n\n\nJuMIT.Coupling\n\n\nJuMIT.Data\n\n\nJuMIT.Poisson\n\n\nJuMIT.Acquisition.Geom\n\n\nJuMIT.Acquisition.Src\n\n\nJuMIT.Coupling.TD\n\n\nJuMIT.Data.Param_error\n\n\nJuMIT.Data.TD\n\n\nJuMIT.Fdtd.Param\n\n\nJuMIT.Fdtd.Paramc\n\n\nJuMIT.Fdtd.Paramp\n\n\nJuMIT.Fdtd.Paramp\n\n\nJuMIT.Fdtd.Paramss\n\n\nJuMIT.Fdtd.Paramss\n\n\nJuMIT.Models.Seismic\n\n\nBase.LinAlg.dot\n\n\nBase.copy!\n\n\nBase.copy!\n\n\nBase.isapprox\n\n\nBase.isapprox\n\n\nBase.isequal\n\n\nBase.isequal\n\n\nBase.isequal\n\n\nBase.iszero\n\n\nBase.iszero\n\n\nBase.print\n\n\nBase.print\n\n\nBase.print\n\n\nBase.similar\n\n\nBase.var\n\n\nJuMIT.Acquisition.Geom_add!\n\n\nJuMIT.Acquisition.Geom_add!\n\n\nJuMIT.Acquisition.Geom_advance\n\n\nJuMIT.Acquisition.Geom_boundary\n\n\nJuMIT.Acquisition.Geom_check\n\n\nJuMIT.Acquisition.Geom_circ\n\n\nJuMIT.Acquisition.Geom_find\n\n\nJuMIT.Acquisition.Geom_fixed\n\n\nJuMIT.Acquisition.Geom_get\n\n\nJuMIT.Acquisition.Geom_getvec\n\n\nJuMIT.Acquisition.Geom_isfixed\n\n\nJuMIT.Acquisition.Src_fixed\n\n\nJuMIT.Acquisition.Src_fixed_mod\n\n\nJuMIT.Acquisition.Src_fixed_random\n\n\nJuMIT.Acquisition.Src_getvec\n\n\nJuMIT.Acquisition.Src_tr\n\n\nJuMIT.Acquisition.Src_uspos\n\n\nJuMIT.Acquisition.Src_zeros\n\n\nJuMIT.Acquisition.freqs\n\n\nJuMIT.Coupling.TD_delta\n\n\nJuMIT.Data.TD_normalize\n\n\nJuMIT.Data.TD_ones\n\n\nJuMIT.Data.TD_tr!\n\n\nJuMIT.Data.TD_urpos\n\n\nJuMIT.Data.TD_weight!\n\n\nJuMIT.Data.TD_zeros\n\n\nJuMIT.Data.TDcoup!\n\n\nJuMIT.Data.interp\n\n\nJuMIT.Data.interp_spray!\n\n\nJuMIT.Fdtd.get_rhovxI\n\n\nJuMIT.Fdtd.get_rhovzI\n\n\nJuMIT.Fdtd.mod!\n\n\nJuMIT.Fdtd.pml_variables\n\n\nJuMIT.Fdtd.update_model!\n\n\nJuMIT.Gallery.Geom\n\n\nJuMIT.Gallery.M1D\n\n\nJuMIT.Gallery.M2D\n\n\nJuMIT.Gallery.Seismic\n\n\nJuMIT.Gallery.Src\n\n\nJuMIT.Interferometry.TD_noise_corr\n\n\nJuMIT.Interferometry.TD_virtual_diff\n\n\nJuMIT.Models.Seismic_addon!\n\n\nJuMIT.Models.Seismic_chainrule!\n\n\nJuMIT.Models.Seismic_get!\n\n\nJuMIT.Models.Seismic_pml_pad_trun\n\n\nJuMIT.Models.Seismic_pml_pad_trun!\n\n\nJuMIT.Models.Seismic_reparameterize!\n\n\nJuMIT.Models.Seismic_smooth\n\n\nJuMIT.Models.Seismic_trun\n\n\nJuMIT.Models.Seismic_zeros\n\n\nJuMIT.Models.adjust_bounds!\n\n\nJuMIT.Models.bounds\n\n\nJuMIT.Models.interp_spray!\n\n\nJuMIT.Models.pml_pad_trun!\n\n\nJuMIT.Models.\u03c7\n\n\nJuMIT.Models.\u03c7g\n\n\nJuMIT.Poisson.solve\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe\n\n\nRecipesBase.apply_recipe",
            "title": "Reference"
        },
        {
            "location": "/#grid",
            "text": "```@autodocs\nModules = [JuMIT.Grid]\nOrder   = [:module, :type, :function]  <a id='Wavelets-1'> </ a >  #   Wavelets  ```@ autodocs  Modules   =   [ JuMIT . Wavelets ]  Order     =   [ : module ,   : type ,   : function ]",
            "title": "Grid"
        },
        {
            "location": "/#coupling",
            "text": "#  JuMIT.Coupling  \u2014  Module .  The data recorded at the receivers during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response. The source filter  ssf  takes into account  the effective wavelet present in the data.  Similarly, the receiver filter  rf  takes the receiver coupling into account. The Inversion module can can estimate both  ssf  and  rf  from the seismic data in order to achieve better data fitting. A base source wavelet  Src  is always used to model the data  before applying the time-domain filter data type  described in this module:   TD  : time domain filters for both source and receivers   source  #  JuMIT.Coupling.TD  \u2014  Type .  Time-domain source and receiver filters.  Fields   ssf::Array{Array{Float64,1},2}  : source filters for each supersource and recorded component  rf::Array{Array{Float64,2},2}  : receiver filters for each receiver, supersource and recorded component  fields::Vector{Symbol}  :  number of recorded components at receivers  tgridssf::Grid.M1D  : a  time grid for source filters with both positive and negative lags  tgridrf::Grid.M1D  : a  time grid for receiver filters with both positive and negative lags  acqgeom::Acquisition.Geom  : acquisition geometry   source  #  JuMIT.Coupling.TD_delta  \u2014  Method .  Initialize coupling filters  TD  with  delta functions.  Arguments   tgriddata  : time grid of the data  tlagssf_fracs::Vector{Real}  : +ve and -ve fractions of source filter  tlagrf_fracs::Vector{Real}  : +ve and -ve fractions for receiver filter  \u03b4t:Float64  : sampling interval in time  fields::Vector{Symbol}  : number of components  acqgeom::Acquisition.Geom  : acquisition geometry   Return   time-domain coupling filters as  TD   source",
            "title": "Coupling"
        },
        {
            "location": "/#acquisition",
            "text": "#  JuMIT.Acquisition  \u2014  Module .  This module defines the following data types:   Geom  : acquisition geometry, i.e., positions of supersources, sources and receivers  Src  : source related acquisition parameters, e.g., source wavelet   It also provides methods that either does operations on these data type or  help their construction.  source  #  JuMIT.Acquisition.Geom  \u2014  Type .  Acquisiton has supersources, sources and receivers. Each supersource has  ns  multiple sources that are  injected (or active) simultaneously. For each supersource, a set of  nr  receivers are  recording waves.  Fields   sx::Vector{Vector{Float64,1},1}  : $x$ positions of sources  sz::Vector{Vector{Float64,1},1}  : $z$ positions of sources  rx::Vector{Vector{Float64,1},1}  : $x$ positions of receivers  rz::Vector{Vector{Float64,1},1}  : $z$ positions of receivers  nss::Int64  : number of supersources  ns::Vector{Int64,1}  : number of sources for every supersource  nr::Vector{Int64,1}  : number of receivers for every supersource   source  #  JuMIT.Acquisition.Src  \u2014  Type .  Data type for the source related parameters during acquisiton.  Fields   nss::Int64  : number of supersources  ns::Array{Int64}  : number of sources for each supersource  fields::Vector{Symbol}  : number of fields  wav::Array{Float64}  : wavelets in time domain  tgrid::Grid.M1D  : time grid   source  #  Base.isequal  \u2014  Function .  Compare if two  TD 's  are equal  source  #  Base.print  \u2014  Function .  Priiiint information about  Src  source  #  Base.print  \u2014  Function .  Print information about  Geom  source  #  JuMIT.Acquisition.Geom_add!  \u2014  Method .  Adds input positions as either sources or receivers of every supershot.  source  #  JuMIT.Acquisition.Geom_add!  \u2014  Method .  Appends the input a vector of acquisition geometries.  source  #  JuMIT.Acquisition.Geom_advance  \u2014  Function .  Advance either source or receiver array in an acquisition geometry in horizontal or vertical directions.  Arguments   geom::Geom  : acquisition geometry that is updated  advances::Vector{Float64}=[[0.,0.], [0.,0.,]]  : source and receiver advancements   source  #  JuMIT.Acquisition.Geom_boundary  \u2014  Method .  Modify input  Geom  such that the output  Geom  has either sources or receivers on the boundary of   mgrid .  Arguments   acqgeom::Geom  : input geometry  mgrid::Grid.M2D  : grid to determine the boundary   attrib::Symbol  : decide return   =:srcborder  sources on boundary (useful for back propagation)  =:recborder  receivers on boundary     source  #  JuMIT.Acquisition.Geom_check  \u2014  Method .  Check if all the sources and receivers in  Geom  are within the model   Return   true  if all the positions within the model,  false  otherwise   source  #  JuMIT.Acquisition.Geom_circ  \u2014  Method .  Circular acquisition. The sources and receivers can also be placed on a circle of radius  rad . The origin of the circle is at  loc .  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by  \u03b8lim  Arguments   nss::Int64=10  : number of supersources  nr::Int64=10  : number receivers for each super source  loc::Vector{Float64}=[0.,0.]  : location of origin   rad::Vector{Float64}=[100.,100.]  : radius for source and receiver circles, for example,   =[0.,100.]  for sources at the center of circle  \u03b8lim::Vector{Float64}=[0.,\u03c0]  : acquisition is limited to these angular offsets between 0 and \u03c0     Return   a circular acquisition geometry  Geom   source  #  JuMIT.Acquisition.Geom_find  \u2014  Method .  Given receiver positions  rpos  and  rpos0 . Returns an array Int indices of the dimension of number of supersources with  true  at indices, if the waves due to that particular source are  recorded.  source  #  JuMIT.Acquisition.Geom_fixed  \u2014  Function .  A fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.  Arguments   ssmin::Float64  : minimum coordinate for sources  ssmax::Float64  : maximum coordinate for sources  ss0::Float64  : consant coordinate for sources  rmin::Float64  : minimum coordinate for receivers  rmax::Float64  : maximum coordinate for receivers  r0::Float64  : consant coordinate for receivers  nss::Int64  : number of supersources  nr::Int64  : number of receivers  ssattrib::Symbol=:horizontal  : supersource array kind  =:vertical  : vertical array of supersources  =:horizontal  horizontal array of supersources  rattrib::Symbol=:horizontal  : receiver array kind  =:vertical  : vertical array of receivers  =:horizontal  horizontal array of receivers  rand_flags::Vector{Bool}=[false, false]  : decide placement of supersources and receivers   =[true, false]  : randomly place supersources for regularly spaced receivers  =[true, true]  : randomly place supersources and receivers  =[false, false]  : regularly spaced supersources and receivers  =[false, true]  : randomly place receivers for regularly spaced supersources   Return   a fixed spread acquisition geometry  Geom   source  #  JuMIT.Acquisition.Geom_get  \u2014  Method .  Return some derived fields of  Geom  Arguments   acq::Vector{Geom}  : a vector of  Geom   attrib::Symbol  : attribute to determine the return object    =:nus  number of unique source positions in acquisition  =:nur  number of unique receiver positions in acquisition  =:uspos  a tuple of x and z positions of all the unique sources  =:urpos  a tuple of x and z position of all the unique receivers  =:geomurpos  a  Geom  vector as if all the unique receiver positions are used for each supersource  =:geomuspos  a  Geom  vector as if all the unique source positions are used for each supersource     source  #  JuMIT.Acquisition.Geom_getvec  \u2014  Method .  return a vector of the order   source  #  JuMIT.Acquisition.Geom_isfixed  \u2014  Method .  Check if the input acquisition geometry is fixed spread.  source  #  JuMIT.Acquisition.Src_fixed  \u2014  Method .  Constructor for  Src  data type. Uses same source wavelet, i.e.,  wav  for all sources and supersources  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of sources  fields::Vector{Symbol}  : number of fields the sources are exciting  wav::Array{Float64}  : a source wavelet that is used for all sources and supersources  tgrid::Grid.M1D  : time grid for the wavelet   source  #  JuMIT.Acquisition.Src_fixed_mod  \u2014  Method .  Constructor of  Src , which is typical for a input model such that  the model has  n\u03bb  wavelengths.  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of source per each supersource  fields::Vector{Symbol}  :   Keyword Arguments   mod::Models.Seismic  :  n\u03bb::Int64=10  : number of wavelengths in the mod  wav_func::Function=(fqdom, tgrid)->Signals.Wavelets.ricker(fqdom,tgrid)  : which wavelet to generate, see Signals.Wavelets.jl  tmaxfrac::Float64=1.0  : by default the maximum modelling time is computed using the average velocity and the diagonal distance of the model, use this fraction to increase of reduce the maximum time   source  #  JuMIT.Acquisition.Src_fixed_random  \u2014  Method .  Generate band-limited random source signals   source  #  JuMIT.Acquisition.Src_getvec  \u2014  Method .  return a vector of the order   source  #  JuMIT.Acquisition.Src_tr  \u2014  Method .  Function that returns Src after time reversal  source  #  JuMIT.Acquisition.Src_uspos  \u2014  Method .  Pad  Src   tgrids should be same in all Src  source  #  JuMIT.Acquisition.Src_zeros  \u2014  Method .  Allocate  Src  with zeros depending on the acquisition geometry.  source  #  JuMIT.Acquisition.freqs  \u2014  Method .  Return minimum, maximum and peak frequencies of  Src  source",
            "title": "Acquisition"
        },
        {
            "location": "/#interpolation",
            "text": "```@autodocs\nModules = [JuMIT.Interpolation]\nOrder   = [:module, :type, :function]  < a   id = 'Models-1' >< /a>  #   Models  < a   id = 'JuMIT.Models.Seismic'   href = '#JuMIT.Models.Seismic' > # < /a>  ** `JuMIT.Models.Seismic` **   & mdash ;   * Type * .  Data   type   fo   represent   a   seismic   model .   A   contrast   function   for   a   model   m   is   given   by   $\u03c7 ( m )   =  \f rac { m }{ m0 } - 1 $ .  ** Fields ** \n\n   *   `vp0::Vector{Float64}`   :   [ vpmin ,   vpmax ] \n   *   `vs0::Vector{Float64}`   :   [ vsmin ,   vsmax ] \n   *   `\u03c10::Vector{Float64}`   :   [ \u03c1 min ,   \u03c1 max ] \n   *   `\u03c7vp::Array{Float64,2}`   :   two - dimensional   contrast   model   ( \u03c7 )   for   vp ,   for   e . g .,   zeros ( mgrid . nz ,   mgrid . nx ) \n   *   `\u03c7vs::Array{Float64}`   :   two - dimensional   contrast   model   ( \u03c7 )   for   vs ,   for   e . g .,   zeros ( mgrid . nz ,   mgrid . nx ) \n   *   `\u03c7\u03c1::Array{Float64}`   :   two - dimensional   contrast   model   ( \u03c7 )   for   density ,   for   e . g .,   zeros ( mgrid . nz ,   mgrid . nx ) \n   *   `mgrid::Grid.M2D`   :   two - dimensional   grid   to   determine   the   dimensions   of   models  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L13-L26'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.copy!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'   href = '#Base.copy!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}' > # < /a>  ** `Base.copy!` **   & mdash ;   * Method * .  Copy   for   `Seismic`   models .   The   models   should   have   same   bounds   and   sizes .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L152-L154'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.isapprox-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'   href = '#Base.isapprox-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}' > # < /a>  ** `Base.isapprox` **   & mdash ;   * Method * .  Return   if   two   `Seismic`   models   have   same   dimensions   and   bounds .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L139-L141'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.isequal-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'   href = '#Base.isequal-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}' > # < /a>  ** `Base.isequal` **   & mdash ;   * Method * .  Compare   if   two   `Seismic`   models   are   equal  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L132'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.iszero-Tuple{JuMIT.Models.Seismic}'   href = '#Base.iszero-Tuple{JuMIT.Models.Seismic}' > # < /a>  ** `Base.iszero` **   & mdash ;   * Method * .  Return   true   if   a   `Seismic`   model   is   just   allocated   with   zeros .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L115-L117'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.print'   href = '#Base.print' > # < /a>  ** `Base.print` **   & mdash ;   * Function * .  Print   information   about   `Seismic`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L54-L56'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.similar-Tuple{JuMIT.Models.Seismic}'   href = '#Base.similar-Tuple{JuMIT.Models.Seismic}' > # < /a>  ** `Base.similar` **   & mdash ;   * Method * .  Return   a   similar   model   to   the   input   model ,   used   for   allocation .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L122-L124'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_addon!-Tuple{JuMIT.Models.Seismic}'   href = '#JuMIT.Models.Seismic_addon!-Tuple{JuMIT.Models.Seismic}' > # < /a>  ** `JuMIT.Models.Seismic_addon!` **   & mdash ;   * Method * .  Add   features   to   a   model .  ** Arguments ** \n\n   *   `mod::Seismic`   :   model   that   is   modified  ** Keyword   Arguments ** \n\n   *   `point_loc::Vector{Float64}=[0., 0.,]`   :   approx   location   of   point   pert . \n   *   `point_pert::Float64=0.0`   :   perturbation   at   the   point   scatterer \n   *   `ellip_loc::Vector{Float64}=nothing`   :   location   of   center   of   perturbation ,   [ z ,   x ] \n   *   `ellip_rad::Float64=0.0`   :   radius   of   circular   perturbation \n   *   `ellip_pert::Float64=0.1`   :   perturbation   inside   a   circle \n   *   `rect_loc::Array{Float64}=nothing`   :   rectangle   location ,   [ zmin ,   xmin ,   zmax ,   xmax ] \n   *   `rect_pert::Float64=0.1`   :   perturbation   in   a   rectangle \n   *   `randn_pert::Float64=0.0`   :   percentage   of   reference   values   for   additive   random   noise \n   *   `fields::Vector{Symbol}=[:\u03c7vp,:\u03c7\u03c1,:\u03c7vs]`   :   which   fields   are   to   be   modified ? \n   *   `onlyin`   :   `mod`   is   modified   only   when   field   values   are   in   these   ranges  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L471-L489'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_chainrule!'   href = '#JuMIT.Models.Seismic_chainrule!' > # < /a>  ** `JuMIT.Models.Seismic_chainrule!` **   & mdash ;   * Function * .  Use   chain   rule   to   output   gradients   with    respect   to   \u03c7 vp   and   \u03c7\u03c1   from    gradients    with   respect   to   KI   and   \u03c1 I .  ** Arguments ** \n\n   *   `gmod::Seismic`   :   gradient   model \n   *   `mod::Seismic`   :   model   required   for   chain   rule \n   *   `g1`   :   gradient   of   an   objective   function   with   respect   `attribs[1]` \n   *   `g2`   :   gradient   of   an   objective   function   with   respect   `attribs[2]` \n   *   `attribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]`   : \n   *   `flag::Int64=1`   : \n\n       *   `=1`   updates   `gmod`   using   `g1`   and   `g2` \n       *   `=-1`   updates   `g1`   and   `g2`   using   `gmod`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L305-L320'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_get!-Tuple{Array{Float64,2},JuMIT.Models.Seismic,Symbol}'   href = '#JuMIT.Models.Seismic_get!-Tuple{Array{Float64,2},JuMIT.Models.Seismic,Symbol}' > # < /a>  ** `JuMIT.Models.Seismic_get!` **   & mdash ;   * Method * .  Get   other   dependent   model   parameters   of   a   seismic   model   that   are   not   present   in   `Seismic` . \n\n   *   `:\u03c1I`   :   inverse   of   density \n   *   `:Zp`   :   P - wave   impedance  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L198-L204'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_pml_pad_trun!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}'   href = '#JuMIT.Models.Seismic_pml_pad_trun!-Tuple{JuMIT.Models.Seismic,JuMIT.Models.Seismic}' > # < /a>  ** `JuMIT.Models.Seismic_pml_pad_trun!` **   & mdash ;   * Method * .  only   padding   implemented  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L655'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_pml_pad_trun-Tuple{JuMIT.Models.Seismic}'   href = '#JuMIT.Models.Seismic_pml_pad_trun-Tuple{JuMIT.Models.Seismic}' > # < /a>  ** `JuMIT.Models.Seismic_pml_pad_trun` **   & mdash ;   * Method * .  Extend   a   seismic   model   into   PML   layers  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L642-L644'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_reparameterize!'   href = '#JuMIT.Models.Seismic_reparameterize!' > # < /a>  ** `JuMIT.Models.Seismic_reparameterize!` **   & mdash ;   * Function * .  Re - parameterization   routine    that   modifies   the   fields    `\u03c7vp`   and   `\u03c7\u03c1`   of   an   input   seismic   model   using   two   input   vectors .  ** Arguments ** \n\n   *   `mod::Seismic`   :   to   be   updated \n   *   `x1::Array{Float64,2}`   :   contrast   of   inverse   bulk   modulus \n   *   `x2::Array{Float64,2}`   :   contrast   of   inverse   density \n   *   `attribs:::Vector{Symbol}`   :   [ : \u03c7 KI ,   : \u03c7\u03c1 I ]  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L271-L283'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_smooth'   href = '#JuMIT.Models.Seismic_smooth' > # < /a>  ** `JuMIT.Models.Seismic_smooth` **   & mdash ;   * Function * .  Apply   smoothing   to   `Seismic`   using   a   Gaussian   filter   of   zwidth   and   xwidth  ** Arguments ** \n\n   *   `mod::Seismic`   :   argument   that   is   modified \n   *   `zperc::Real`   :   smoothing   percentage   in   z - direction \n   *   `xperc::Real=zperc`   :   smoothing   percentage   in   x - direction  ** Keyword   Arguments ** \n\n   *   `zmin::Real=mod.mgrid.z[1]`   : \n   *   `zmax::Real=mod.mgrid.z[end]`   : \n   *   `xmin::Real=mod.mgrid.x[1]`   : \n   *   `xmax::Real=mod.mgrid.x[end]`   : \n   *   `fields`   :   fields   of   seismic   model   that   are   to   be   smooth  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L557-L573'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_trun-Tuple{JuMIT.Models.Seismic}'   href = '#JuMIT.Models.Seismic_trun-Tuple{JuMIT.Models.Seismic}' > # < /a>  ** `JuMIT.Models.Seismic_trun` **   & mdash ;   * Method * .  Return   a   truncated   seismic   model   using   input   bounds .   Note   that   there   is   no   interpolation   going   on   here ,   but   only   truncation ,   so    the   input   bounds   cannot   be   strictly   imposed .  ** Arguments ** \n\n   *   `mod::Seismic`   :   model   that   is   truncated  ** Keyword   Arguments ** \n\n   *   `zmin::Float64=mod.mgrid.z[1]`   : \n   *   `zmax::Float64=mod.mgrid.z[end]`   : \n   *   `xmin::Float64=mod.mgrid.x[1]`   : \n   *   `xmax::Float64=mod.mgrid.x[end]`   :  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L598-L612'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.Seismic_zeros-Tuple{Grid.M2D}'   href = '#JuMIT.Models.Seismic_zeros-Tuple{Grid.M2D}' > # < /a>  ** `JuMIT.Models.Seismic_zeros` **   & mdash ;   * Method * .  Return   `Seismic`   with   zeros   everywhere ;   this   method   is   used   for   preallocation .  ** Arguments ** \n\n   *   `mgrid::Grid.M2D`   :   used   for   sizes   of   \u03c7   fields  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L96-L102'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.adjust_bounds!'   href = '#JuMIT.Models.adjust_bounds!' > # < /a>  ** `JuMIT.Models.adjust_bounds!` **   & mdash ;   * Function * .  Adjust   the   bounds   and   hence   the   reference   values .   Since   the   reference   values   are   adjust   the   \u03c7   fields   should   also   be   changed  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L80-L83'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.bounds'   href = '#JuMIT.Models.bounds' > # < /a>  ** `JuMIT.Models.bounds` **   & mdash ;   * Function * .  Return   medium   property   bounds   based   on   maximum   and   minimum   values   of   the   array   and   frac .   The   bounds   cannot   be   less   than   zero  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L67-L70'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.interp_spray!'   href = '#JuMIT.Models.interp_spray!' > # < /a>  ** `JuMIT.Models.interp_spray!` **   & mdash ;   * Function * .  function   to   resample   in   the   model   domain  ** Arguments ** \n\n   *   `mod::Seismic`   :   model \n   *   `modi::Seismic`   :   model   after   interpolation  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L718-L724'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.pml_pad_trun!'   href = '#JuMIT.Models.pml_pad_trun!' > # < /a>  ** `JuMIT.Models.pml_pad_trun!` **   & mdash ;   * Function * .  PML   Extend   a   model   on   all   four   sides  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L681-L683'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.\u03c7'   href = '#JuMIT.Models.\u03c7' > # < /a>  ** `JuMIT.Models.\u03c7` **   & mdash ;   * Function * .  Return   dimensionless   contrast   model   parameter   using   the   reference   value .  ** Arguments ** \n\n   *   `mod::Array{Float64}`   :   subsurface   parameter \n   *   `mod0::Vector{Float64}`   :   reference   value   is   mean   of   this   vector \n   *   `flag::Int64=1`   :  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L414-L422'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Models.\u03c7g'   href = '#JuMIT.Models.\u03c7g' > # < /a>  ** `JuMIT.Models.\u03c7g` **   & mdash ;   * Function * .  Gradients   Return   contrast   model   parameter   using   the   reference   value .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Models.jl#L448-L452'   class = 'documenter-source' > source < /a><br>  < a   id = 'Data-1' >< /a>  #   Data  < a   id = 'JuMIT.Data'   href = '#JuMIT.Data' > # < /a>  ** `JuMIT.Data` **   & mdash ;   * Module * .  This   module   defines   the   data   types   related   to   seismic   data : \n\n   *   `TD`   :   time   domain   representation  It   also   provides   methods   that   apply   source   and   receiver   filters   onto    seismic   data .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L3-L9'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.Param_error'   href = '#JuMIT.Data.Param_error' > # < /a>  ** `JuMIT.Data.Param_error` **   & mdash ;   * Type * .  Calculate   the   distance   between   the   observed   data   `y`   and   the   calculated   data   `x` .   The   time   grid   of   the   observed   data   can   be   different   from   that   of   the   modelled   data .   The   acqistion   geometry   of   both   the   data   sets   should   be   the   same .  If   `J`   is   the   distance ,   the   gradient   of   the   misfit   w . r . t   to   the   calculated   data   is   returned   as   `dJx` \n\n   *   `w`   used   for   data   preconditioning \n   *   `coupling`   source   and   receiver   coupling   functions  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L484-L492'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD'   href = '#JuMIT.Data.TD' > # < /a>  ** `JuMIT.Data.TD` **   & mdash ;   * Type * .  Time   domain   representation   of   Seismic   Data .  ** Fields ** \n\n   *   `d::Array{Array{Float64,2},2}`   :   data \n   *   `fields::Vector{Symbol}`   :   components   recorded   at   each   receiver \n   *   `tgrid::Grid.M1D`   :   grid   to   represent   time \n   *   `acqgeom::Acquisition.Geom`   :   acquisition   geometry   used   to   generate   the   data  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L22-L31'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.LinAlg.dot-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'   href = '#Base.LinAlg.dot-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}' > # < /a>  ** `Base.LinAlg.dot` **   & mdash ;   * Method * .  Returns   dot   product   of   data .  ** Arguments ** \n\n   *   `data1::TD`   :   data   1 \n   *   `data2::TD`   :   data   2  ** Return ** \n\n   *   dot   product   as   `Float64`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L248-L259'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.copy!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'   href = '#Base.copy!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}' > # < /a>  ** `Base.copy!` **   & mdash ;   * Method * .  Copy   `TD` 's, which are similar.  <a target=' _blank ' href=' https : //github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L71-L73' class='documenter-source'>source</a><br>  < a   id = 'Base.isapprox-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'   href = '#Base.isapprox-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}' > # < /a>  ** `Base.isapprox` **   & mdash ;   * Method * .  Return   if   two   `TD` 's have same dimensions and bounds.  <a target=' _blank ' href=' https : //github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L55-L57' class='documenter-source'>source</a><br>  < a   id = 'Base.isequal-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}'   href = '#Base.isequal-Tuple{JuMIT.Data.TD,JuMIT.Data.TD}' > # < /a>  ** `Base.isequal` **   & mdash ;   * Method * .  Compare   if   two   `TD` 's  are equal  <a target=' _blank ' href=' https : //github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L48' class='documenter-source'>source</a><br>  < a   id = 'Base.iszero-Tuple{JuMIT.Data.TD}'   href = '#Base.iszero-Tuple{JuMIT.Data.TD}' > # < /a>  ** `Base.iszero` **   & mdash ;   * Method * .  Returns   bool   depending   on   if   input   `data::TD`   has   all   zeros   or   not .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L182-L184'   class = 'documenter-source' > source < /a><br>  < a   id = 'Base.var-Tuple{JuMIT.Data.TD}'   href = '#Base.var-Tuple{JuMIT.Data.TD}' > # < /a>  ** `Base.var` **   & mdash ;   * Method * .  Returns   the   variance   of   data  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L201-L204'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_normalize'   href = '#JuMIT.Data.TD_normalize' > # < /a>  ** `JuMIT.Data.TD_normalize` **   & mdash ;   * Function * .  Normalize   time - domain   seismic   data .  ** Arguments ** \n\n   *   `data::TD`   :   input   data \n   *   `attrib::Symbol`   :   decide   kind   of   normalization \n\n       *   `=:recrms`   the   record   at   every   receiver   is   normalized   with   its   RMS   value \n       *   `=:recmax`   the   record   at   every   receiver   is   normalized   with   its   maximum   value  ** Return ** \n\n   *   normalized   data   as   `TD`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L275-L288'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_ones-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'   href = '#JuMIT.Data.TD_ones-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}' > # < /a>  ** `JuMIT.Data.TD_ones` **   & mdash ;   * Method * .  Same   as   `TD_zeros` ,   except   for   returning   ones  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L175'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_tr!-Tuple{JuMIT.Data.TD}'   href = '#JuMIT.Data.TD_tr!-Tuple{JuMIT.Data.TD}' > # < /a>  ** `JuMIT.Data.TD_tr!` **   & mdash ;   * Method * .  Time   reverse   the   records   of   each   receiver   in   `TD`   ** Arguments ** \n\n   *   `data::TD`   :   input   data   that   is   modified  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L189-L195'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_urpos-Tuple{Array{Float64,N} where N,Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom,Int64,Tuple{Array{Float64,1},Array{Float64,1}}}'   href = '#JuMIT.Data.TD_urpos-Tuple{Array{Float64,N} where N,Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom,Int64,Tuple{Array{Float64,1},Array{Float64,1}}}' > # < /a>  ** `JuMIT.Data.TD_urpos` **   & mdash ;   * Method * .  Construct   TD   using   data   at   all   the   unique   receiver   positions   for   all   supersources . \n\n   *   `d::Array{Float64}`   :   the   data   matrix   ordered   in   order   such   that   time - domain   modelling   schemes   are   fast ,   i . e .,   [ irec , ifield , it , nss ]  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L343-L349'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_weight!-Tuple{JuMIT.Data.TD}'   href = '#JuMIT.Data.TD_weight!-Tuple{JuMIT.Data.TD}' > # < /a>  ** `JuMIT.Data.TD_weight!` **   & mdash ;   * Method * .  Apply   different   weighting   functions   to   `TD` .   Use   this   method   to   create   a    data   preconditioning   matrix  ** Arguments   Modified ** \n\n   *   `dw::TD`   :  ** Keyword   Arguments ** \n\n   *   `offsetlim::Vector{Float64}=[-Inf,Inf]`   :   [ xoffsetlim ,   zoffsetlim ],   where   the   records   with   offsets   >   `offsetlim`   are   given   zero   weight \n   *   `tlim::Vector{Float64}=[dw.tgrid.x[1], dw.tgrid.x[end]]`   :   [ tminimum ,   tmaximum ],   time   mute   window \n   *   `offsetpow::Vector{Float64}=[0.0,0.0]`   : \n   *   `tpow::Float64=0.0`   : \n   *   `ttaperperc::Float64=0.`   :   taper   window   percentage   for   time   window \n   *   NOTE :  if   more   than   one   simultaneous   source   are   present ,   their   mean   position   is   considered   to   calculate   offset .  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L415-L432'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TD_zeros-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}'   href = '#JuMIT.Data.TD_zeros-Tuple{Array{Symbol,1},Grid.M1D,JuMIT.Acquisition.Geom}' > # < /a>  ** `JuMIT.Data.TD_zeros` **   & mdash ;   * Method * .  Method   used   to   preallocate   `TD`   with   zeros .  ** Arguments ** \n\n   *   `fields::Vector{Symbol}`   :   number   of   components \n   *   `tgrid::Grid.M1D`   :   time   domain   grid \n   *   `acqgeom::Acquisition.Geom`   :   acquisition   geometry  ** Return ** \n\n   *   data   with   zeros   as   `TD`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L147-L159'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.TDcoup!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD,JuMIT.Coupling.TD,Symbol}'   href = '#JuMIT.Data.TDcoup!-Tuple{JuMIT.Data.TD,JuMIT.Data.TD,JuMIT.Coupling.TD,Symbol}' > # < /a>  ** `JuMIT.Data.TDcoup!` **   & mdash ;   * Method * .  Apply   source   and   receiver   coupling   functions   to   TD .   Currently ,   only   source   filters   are   applied .  ** Arguments ** \n\n   *   `s::TD`   :   input   data \n   *   `r::TD`   :   input   data \n   *   `w::Coupling.TD`   :   input   source   and   receiver   filters \n   *   `attrib::Symbol`   :   attribute   to  \n\n       *   `=:s`   to   apply   `w`   to   `r`   and   modify   `s` \n       *   `=:r`   to   apply   adjoint   of   `w`   to   `s`   and   modify   `r` \n       *   `=:w`   modify   `w`   using   `r`   and   `s`  TODO :  need   to   work   on   parallelization   and   speed   up   here  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L372-L387'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.interp-Tuple{JuMIT.Data.TD,Grid.M1D}'   href = '#JuMIT.Data.interp-Tuple{JuMIT.Data.TD,Grid.M1D}' > # < /a>  ** `JuMIT.Data.interp` **   & mdash ;   * Method * .  Method   to   resample   data   in   time .  ** Arguments ** \n\n   *   `data::TD`   :   input   data   of   type   `TD` \n   *   `tgrid::Grid.M1D`   :   resampling   in   time   according   to   this   time   grid  ** Return ** \n\n   *   data   after   resampling   as   `TD`  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L91-L102'   class = 'documenter-source' > source < /a><br>  < a   id = 'JuMIT.Data.interp_spray!'   href = '#JuMIT.Data.interp_spray!' > # < /a>  ** `JuMIT.Data.interp_spray!` **   & mdash ;   * Function * .  Method   to   resample   data   in   time .   Can   reduce   allocations   =========  ** Arguments ** \n\n   *   `data::TD`   :   input   data   of   type   `TD` \n   *   `dataout::TD`   :   preallocated   data   of   type   `TD`   that   is   modified  < a   target = '_blank'   href = 'https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Data.jl#L116-L124'   class = 'documenter-source' > source < /a><br>  < a   id = 'Misfits-1' >< /a>  #   Misfits  ```@autodocs  Modules = [JuMIT.Misfits]  Order   = [:module, :type, :function]",
            "title": "Interpolation"
        },
        {
            "location": "/#gallery",
            "text": "#  JuMIT.Gallery.Geom  \u2014  Method .  Gallery of acquisition geometries  Geom  using an input mesh  M2D . The sources and receivers are not placed anywhere on the edges of the mesh.  Arguments   mgrid::Grid.M2D  : a 2-D mesh   attrib::Symbol  : attribute decides output   =:xwell  cross-well acquisition  =:surf  surface acquisition  =:vsp  vertical seismic profiling  =:rvsp   reverse vertical seismic profiling  =:downhole  downhole sources and receivers     Keyword Arguments   nss=2  : number of supersources  nr=2  : number of receivers per supersource  rand_flags::Vector{Bool}=[false, false]  : randomly or equally spaced supersources and receivers.   source  #  JuMIT.Gallery.M1D  \u2014  Method .  Gallery of  M1D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a time grid for with 1000 samples; maximum time is 2 s  attrib=:acou_homo1_long  : a time grid for with 1000 samples; maximum time is 4 s  attrib=:npow2samp1  : a sample npow2 grid with 16 samples   source  #  JuMIT.Gallery.M2D  \u2014  Method .  Gallery of  M2D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a square grid for with 201 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.   attrib=:acou_homo2  : a square grid for with 51 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.  source  #  JuMIT.Gallery.Seismic  \u2014  Function .  Gallery of  Seismic  models.  Arguments   attrib::Symbol  :   Outputs    attrib=:acou_homo1  : an homogeneous acoustic model with  vp0=2000  and  \u03c10=2000   attrib=:acou_homo2  : same as above, but with spatial sampling as 40 m (faster testing)  attrib=:seismic_marmousi2  : marmousi model with lower resolution; ideal for surface seismic experiments  attrib=:seismic_marmousi2_high_res  : marmousi model high resolution; slower to load  attrib=:seismic_marmousi2_xwell  : boxed marmousi model ideal for crosswell experiments  attrib=:seismic_marmousi2_surf  : boxed marmousi2 for surface seismic experiments  attrib=:seismic_marmousi2_downhole  : boxed marmousi2 for downhole seismic experiments     source  #  JuMIT.Gallery.Src  \u2014  Function .  Gallery of source signals  Src .  Arguments   attrib::Symbol  :  nss::Int64=1  : number of supersources   Outputs   attrib=:acou_homo1  :   source",
            "title": "Gallery"
        },
        {
            "location": "/#fdtd",
            "text": "#  JuMIT.Fdtd.Param  \u2014  Method .  Method to create  Fdtd  modeling parameters. The output of this method can be used as an input to  mod! , where the actual  finite-difference modeling is performed.  Keyword Arguments   npw::Int64=1  : number of independently propagating wavefields in  model  model::Models.Seismic=Gallery.Seismic(:acou_homo1)  : seismic medium parameters  model_pert::Models.Seismic=model  : perturbed model, i.e., model + \u03b4model, used only for Born modeling  tgridmod::Grid.M1D=Gallery.M1D(:acou_homo1)  : modeling time grid, maximum time in tgridmod should be greater than or equal to maximum source time, same sampling interval as the wavelet  tgrid::Grid.M1D=tgridmod  : output records are resampled on this time grid  acqgeom::Vector{Acquisition.Geom}=fill(Gallery.Geom(:acou_homo1),npw)  :  acquisition geometry for each independently propagating wavefield  acqsrc::Vector{Acquisition.Src}=fill(Gallery.Src(:acou_homo1),npw)  : source acquisition parameters for each independently propagating wavefield   sflags::Vector{Int64}=fill(2,npw)  : source related flags for each propagating wavefield   =[0]  inactive sources  =[1]  sources with injection rate  =[2]  volume injection sources  =[3]  sources input after time reversal (use only during backpropagation)   rflags::Vector{Int64}=fill(1,npw)  : receiver related flags for each propagating wavefield    =[0]  receivers do not record (or) inactive receivers   =[0,1]  receivers are active only for the second propagating wavefield  rfields::Vector{Symbol}=[:P]  : multi-component receiver flag; types fields the receivers record (to be changed later)   backprop_flag::Bool=Int64  : save final state variables and the boundary conditions for later use    =1  save boundary and final values in  boundary   =-1  use stored values in  boundary  for back propagation   abs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]  : use absorbing PML boundary conditions or not    =[:top, :bottom]  apply PML conditions only at the top and bottom of the model   =[:bottom, :right, :left]  top is reflecting  born_flag::Bool=false  : do only Born modeling instead of full wavefield modelling (to be updated soon)  gmodel_flag=false  : flag that is used to output gradient; there should be atleast two propagating wavefields in order to do so: 1) forward wavefield and 2) adjoint wavefield  illum_flag::Bool=false  : flag to output wavefield energy or source illumination; it can be used as preconditioner during inversion  tsnaps::Vector{Float64}=fill(0.5*(tgridmod.x[end]+tgridmod.x[1]),1)  : store snaps at these modelling times  snaps_flag::Bool=false  : return snaps or not  verbose::Bool=false  : verbose flag     Example  pa   =   JuMIT . Fdtd . Param ( acqgeom = acqgeom ,   acqsrc = acqsrc ,   model = model ,   tgridmod = tgridmod );  JuMIT . Fdtd . mod! ( pa );   Credits  Author: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)   original code in FORTRAN90: March 2013  modified: 11 Sept 2013  major update: 25 July 2014  code optimization with help from Jan Thorbecke: Dec 2015  rewritten in Julia: June 2017  added parrallelization over supersources in Julia: July 2017  efficient parrallelization using distributed arrays: Sept 2017  optimized memory allocation: Oct 2017   source  #  JuMIT.Fdtd.Paramc  \u2014  Type .  Modelling parameters common for all supersources  Keyword Arguments that are modified by the method (some of them are returned as well)   gmodel::Models.Seismic=Models.Seismic_zeros(model.mgrid)  : gradient model modified only if  gmodel_flag  TDout::Vector{Data.TD}=[Data.TD_zeros(rfields,tgridmod,acqgeom[ip]) for ip in 1:length(findn(rflags))]  illum::Array{Float64,2}=zeros(model.mgrid.nz, model.mgrid.nx)  : source energy if  illum_flag  boundary::Array{Array{Float64,4},1}  : stored boundary values for first propagating wavefield  snaps::Array{Float64,4}=zeros(model.mgrid.nz,model.mgrid.nx,length(tsnaps),acqgeom[1].nss)  :snapshots saved at  tsnaps   Return (in order)   modelled data for each propagating wavefield as  Vector{TD}  stored boundary values of the first propagating wavefield as  Array{Array{Float64,4},1}  (use for backpropagation)  final conditions of the first propagating wavefield as  Array{Float64,4}  (use for back propagation)  gradient model as  Seismic  stored snaps shots at tsnaps as Array{Float64,4}   source  #  JuMIT.Fdtd.Paramp  \u2014  Type .  Parameters per every worker, not necessarily for every supersource. Note that a single worker can take care of multiple supersources.  source  #  JuMIT.Fdtd.Paramp  \u2014  Method .  Create modeling parameters for each worker. Each worker performs the modeling of supersources in  sschunks . The parameters common to all workers are stored in  pac .  source  #  JuMIT.Fdtd.Paramss  \u2014  Type .  Modelling parameters per every supersource for each worker  source  #  JuMIT.Fdtd.Paramss  \u2014  Method .  Create modeling parameters for each supersource.  Every worker models one or more supersources.  source  #  JuMIT.Fdtd.get_rhovxI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  JuMIT.Fdtd.get_rhovzI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  JuMIT.Fdtd.mod!  \u2014  Function .  This method updated the input  Fdtd.Param  after the wave propagation.  Arguments   pa::Param  : modelling parameters   Useful fields in  pa  that are modified by the method   pa.c.TDout::Vector{Data.TD}  : seismic data at receivers after modeling, for each propagating wavefield  pa.c.snaps::Array{Float64,4}  : snaps with size  (nz,nx,length(tsnaps),nss)  saved at  tsnaps  pa.c.gmodel::Models.Seismic  : gradient model modified only if  gmodel_flag  pa.c.illum_stack::Array{Float64,2}  source energy of size  (nz,nx)  if  illum_flag   Example  JuMIT . Fdtd . mod! ( pa )   Credits  Author: Pawan Bharadwaj          (bharadwaj.pawan@gmail.com)  source  #  JuMIT.Fdtd.pml_variables  \u2014  Method .  Output vectors related to PML boundaries.  source  #  JuMIT.Fdtd.update_model!  \u2014  Function .  Update the  Seismic  models in  Paramc  without additional memory allocation. This routine is used during FWI, where medium parameters are itertively updated.   source",
            "title": "Fdtd"
        },
        {
            "location": "/#inversion",
            "text": "```@autodocs\nModules = [JuMIT.Inversion]\nOrder   = [:module, :type, :function]  <a id='Interferometry-1'> </ a >  #   Interferometry  <a id='JuMIT.Interferometry.TD_noise_corr-Tuple{JuMIT.Data.TD}' href='#JuMIT.Interferometry.TD_noise_corr-Tuple{JuMIT.Data.TD}'> # </ a >  ** ` JuMIT . Interferometry . TD_noise_corr ` **   & mdash ;   * Method * .  Correlating   noise   records   with   reference   records \n\n   *   ` irref `   :   reference   receiver  <a target='_blank' href='https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Interferometry.jl#L113-L116' class='documenter-source'> source </ a >< br >  <a id='JuMIT.Interferometry.TD_virtual_diff-Tuple{JuMIT.Data.TD}' href='#JuMIT.Interferometry.TD_virtual_diff-Tuple{JuMIT.Data.TD}'> # </ a >  ** ` JuMIT . Interferometry . TD_virtual_diff ` **   & mdash ;   * Method * .  enhance   diffractions   in   the   ` TD `  ** Keyword   Arguments **  ` \u03bbdom :: Float64 = 0.0 `   :   distance   between   receivers   must   be   greater   than   twice   central   wavelength ,   2 * \u03bbdom   ( Shapiro   2005 )   ` tlag :: Float64 = data . tgrid . x [ end ]- data . tgrid . x [ 1 ] `   :   maximum   lag   time   in   the   output   traces   <a target='_blank' href='https://github.com/pawbz/JuMIT.jl/blob/b64538648c84b1096e121bd925f9f366f6f44f87/src/Interferometry.jl#L11-L19' class='documenter-source'> source </ a >< br >  <a id='CICA-1'> </ a >  #   CICA  ```@ autodocs  Modules   =   [ JuMIT . CICA ]  Order     =   [ : module ,   : type ,   : function ]",
            "title": "Inversion"
        },
        {
            "location": "/#poisson",
            "text": "#  JuMIT.Poisson  \u2014  Module .  This module represents an explicit, direct sparse 2D finite-difference Poisson solver for heterogeneous media, i.e. media having spatially varying (space-dependent) medium parameters. The following functionality is currently available in this module:   'Forward' problem: given the source, and the conductivity distribution, solve for the electrical potential \u03c8:     Example   problem :   solve   A\u03c8 = \u2207\u22c5 j ;   A = \u2207\u22c5 ( \u03c3 ( x , z ) \u2207 ),   for   \u03c8 .    'Inverse' problem: given wave propagation related pore pressure, and mechanical medium properties, calculate the source term:     Example   problem :   solve   A\u03c8 = - \u2207\u22c5 j ;   A = \u2207\u22c5 ( [ Q * k / \u03b7 ] ( x , z ) \u2207 B * P ),   for   \u2207\u22c5 j ;    The Boundary Value Problem that is currently implemented assumes Neumann boundary conditions at all boundaries.   Developed by:\n Niels Grobbe, Massachusetts Institute of Technology, USA.\n In collaboration with: Aim\u00e9 Fournier & Laurent Demanet, Massachusetts Institute of Technology, USA.\n Date: October, 2017 \n Contact: ngrobbe@gmail.com  source  #  JuMIT.Poisson.solve  \u2014  Method .  Poisson.solve(field,mpars,solflag) solves the forward or inverse Poisson problem in a heterogeneous medium.  Function input arguments:   field  : either source term used in 'forward' mode to get field, or the field (e.g. pore pressure) used in 'inverse' mode to calculate source-term  mpars  : medium parameters for forward or inverse mode  solflag  : Solution flag determining whether to use forward (solflag=1) or inverse mode (solflag=-1) of Poisson solver.   source",
            "title": "Poisson"
        },
        {
            "location": "/#plots",
            "text": "#  RecipesBase.apply_recipe  \u2014  Method .  Plot acquisition geometry  Acquisition.Geom  on and model grid  M2D .  attrib::Symbol=:unique  : default; plots unique source and receiver positions  ssvec::Vector{Int64}  : plot source and receivers of only these supersources  source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot the velocity and density seismic models.  Arguments   model::Models.Seismic  : model that should be plotted   Keyword Arguments   xlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]  : minimum and maximum limits of the second dimension while plotting  zlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]  : minimum and maximum limits of the first dimension while plotting  fields::Vector{Symbol}=[:vp, :\u03c1]  : fields that are to be plotted, see Models.Seismic_get  contrast_flag=false  : plot only the edges of the model  use_bounds=false  : adjust  clim  to the bounds in the seismic model   source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot the source wavelet used for acquisition.  Arguments   acqsrc::Acquisition.Src  : source acquisition parameters   source  #  RecipesBase.apply_recipe  \u2014  Method .  Plot time-domain data of type  Data.TD  Arguments   td::Vector{Data.TD}  : time-domain data to be compared   Keyword Arguments   ssvec::Vector{Vector{Int64}}=fill([1], length(td))  : supersource vector to be plotted  fields::Vector{Int64}=[1]  : field vector to be plotted  tr_flag::Bool=false  : plot time-reversed data when true  attrib::Symbol=:wav  : specify type of plot   source  %## Another Section % @contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %  %  % @contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %",
            "title": "Plots"
        },
        {
            "location": "/#index",
            "text": "JuMIT.Acquisition  JuMIT.Coupling  JuMIT.Data  JuMIT.Poisson  JuMIT.Acquisition.Geom  JuMIT.Acquisition.Src  JuMIT.Coupling.TD  JuMIT.Data.Param_error  JuMIT.Data.TD  JuMIT.Fdtd.Param  JuMIT.Fdtd.Paramc  JuMIT.Fdtd.Paramp  JuMIT.Fdtd.Paramp  JuMIT.Fdtd.Paramss  JuMIT.Fdtd.Paramss  JuMIT.Models.Seismic  Base.LinAlg.dot  Base.copy!  Base.copy!  Base.isapprox  Base.isapprox  Base.isequal  Base.isequal  Base.isequal  Base.iszero  Base.iszero  Base.print  Base.print  Base.print  Base.similar  Base.var  JuMIT.Acquisition.Geom_add!  JuMIT.Acquisition.Geom_add!  JuMIT.Acquisition.Geom_advance  JuMIT.Acquisition.Geom_boundary  JuMIT.Acquisition.Geom_check  JuMIT.Acquisition.Geom_circ  JuMIT.Acquisition.Geom_find  JuMIT.Acquisition.Geom_fixed  JuMIT.Acquisition.Geom_get  JuMIT.Acquisition.Geom_getvec  JuMIT.Acquisition.Geom_isfixed  JuMIT.Acquisition.Src_fixed  JuMIT.Acquisition.Src_fixed_mod  JuMIT.Acquisition.Src_fixed_random  JuMIT.Acquisition.Src_getvec  JuMIT.Acquisition.Src_tr  JuMIT.Acquisition.Src_uspos  JuMIT.Acquisition.Src_zeros  JuMIT.Acquisition.freqs  JuMIT.Coupling.TD_delta  JuMIT.Data.TD_normalize  JuMIT.Data.TD_ones  JuMIT.Data.TD_tr!  JuMIT.Data.TD_urpos  JuMIT.Data.TD_weight!  JuMIT.Data.TD_zeros  JuMIT.Data.TDcoup!  JuMIT.Data.interp  JuMIT.Data.interp_spray!  JuMIT.Fdtd.get_rhovxI  JuMIT.Fdtd.get_rhovzI  JuMIT.Fdtd.mod!  JuMIT.Fdtd.pml_variables  JuMIT.Fdtd.update_model!  JuMIT.Gallery.Geom  JuMIT.Gallery.M1D  JuMIT.Gallery.M2D  JuMIT.Gallery.Seismic  JuMIT.Gallery.Src  JuMIT.Interferometry.TD_noise_corr  JuMIT.Interferometry.TD_virtual_diff  JuMIT.Models.Seismic_addon!  JuMIT.Models.Seismic_chainrule!  JuMIT.Models.Seismic_get!  JuMIT.Models.Seismic_pml_pad_trun  JuMIT.Models.Seismic_pml_pad_trun!  JuMIT.Models.Seismic_reparameterize!  JuMIT.Models.Seismic_smooth  JuMIT.Models.Seismic_trun  JuMIT.Models.Seismic_zeros  JuMIT.Models.adjust_bounds!  JuMIT.Models.bounds  JuMIT.Models.interp_spray!  JuMIT.Models.pml_pad_trun!  JuMIT.Models.\u03c7  JuMIT.Models.\u03c7g  JuMIT.Poisson.solve  RecipesBase.apply_recipe  RecipesBase.apply_recipe  RecipesBase.apply_recipe  RecipesBase.apply_recipe",
            "title": "Index"
        },
        {
            "location": "/tutorials/page1/",
            "text": "FFF FF",
            "title": "Title 1"
        },
        {
            "location": "/modeling/page1/",
            "text": "ff",
            "title": "Title 1"
        }
    ]
}