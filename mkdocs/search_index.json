{
    "docs": [
        {
            "location": "/",
            "text": "There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.\n\n\n\n\nGrids\n\n\n#\n\n\nSIT.Grid.M1D\n \u2014 \nType\n.\n\n\nData type to represent 1D grid.\n\n\nFields\n\n\n\n\nx\n : values\n\n\nnx\n : number of samples\n\n\n\u03b4x\n : sampling interval\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D\n \u2014 \nMethod\n.\n\n\nConstruct 1-D grid based on nx or \u03b4x\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D\n \u2014 \nType\n.\n\n\nData type to represent 2D grid.\n\n\nFields\n\n\n\n\nx\n : horizontal values\n\n\nz\n : vertical values\n\n\nnx\n : number of samples in horizontal direction\n\n\nnz\n : number of samples in vertical direction\n\n\n\u03b4x\n : sampling interval in horizontal direction\n\n\n\u03b4z\n : sampling interval in vertical direction\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nM1D\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_lag\n \u2014 \nMethod\n.\n\n\nGrid with both positive and negative samples for a given lag. Make sure that the number so samples is odd\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_npow2\n \u2014 \nMethod\n.\n\n\noutput an npow2grid of either time or frequency\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_npow2_tf\n \u2014 \nMethod\n.\n\n\nconvertion between time and frequency npow2 grids\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_resamp\n \u2014 \nMethod\n.\n\n\n1-D grid with a different sampling interval\n\n\n\n\nNot yet implemented for npow2 grids\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_truncate\n \u2014 \nMethod\n.\n\n\n1-D grid which is has a different size\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_boundary\n \u2014 \nMethod\n.\n\n\nReturn the X and Z positions of the boundary of mgrid attrib \n :inner \n :outer ** onlycount\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nM2D\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_pad_trun\n \u2014 \nMethod\n.\n\n\nExtend M2D by its npml grid points on all sides\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_resamp\n \u2014 \nMethod\n.\n\n\n2-D grid with a different sampling interval\n\n\nsource\n\n\n\n\nSource Wavelets\n\n\n#\n\n\nSIT.Wavelets.ormsby\n \u2014 \nMethod\n.\n\n\normbsy wavelet\n\n\nsource\n\n\n#\n\n\nSIT.Wavelets.ricker\n \u2014 \nMethod\n.\n\n\nGenerate a Ricker Wavelet\n\n\nArguments\n\n\n\n\nfqdom\n: dominant frequency\n\n\ntgrid\n: time-domain grid\n\n\ntpeak\n: the peak of the ricker in time\n\n\n``\n\n\n\n\nsource\n\n\n\n\nSource and Receiver Coupling\n\n\n#\n\n\nSIT.Coupling.TD\n \u2014 \nType\n.\n\n\nsource\n\n\n#\n\n\nSIT.Coupling.TD_delta\n \u2014 \nMethod\n.\n\n\nReturn delta functions\n\n\nsource\n\n\n\n\nAcquisition\n\n\n#\n\n\nSIT.Acquisition.Geom\n \u2014 \nType\n.\n\n\nAcquisiton of supersources, sources and receivers. Each supersource has multiple sources that are  injected (active) simultaneously. Each supersource  has a set of receivers that  record waves. \n\n\nFields\n\n\n\n\nsx::Vector{Vector{Float64,1},1}\n : $x$ positions of sources\n\n\nsz::Vector{Vector{Float64,1},1}\n : $z$ positions of sources\n\n\nrx::Vector{Vector{Float64,1},1}\n : $x$ positions of receivers\n\n\nrz::Vector{Vector{Float64,1},1}\n : $z$ positions of receivers\n\n\nnss::Int64\n : number of supersources\n\n\nns::Vector{Int64,1}\n : number of sources for every supersource\n\n\nnr::Vector{Int64,1}\n : number of receivers for every supersource\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src\n \u2014 \nType\n.\n\n\nData type for the sources used.\n\n\nFields\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Array{Int64}\n : number of sources for each supersource\n\n\nnfield::Int64\n : number of fields\n\n\nwav::Array{Float64}\n : wavelets in time domain\n\n\ntgrid::Grid.M1D\n : time grid\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_boundary\n \u2014 \nMethod\n.\n\n\nModify input \nGeom\n such that the output has either sources or receivers on the boundary of  \nmgrid\n.\n\n\nArguments\n\n\n\n\nacqgeom::Geom\n : input geometry\n\n\nmgrid::Grid.M2D\n : to determine the boundary\n\n\nattrib::Symbol\n : either \n:srcborder\n or \n:recborder\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_circ\n \u2014 \nMethod\n.\n\n\nCircular acquisition. The sources and receivers can also be placed on a circle of radius \nrad\n. The origin of the circle is at \nloc\n.  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by \n\u03b8lim\n\n\nArguments\n\n\nnss::Int64=10\n : number of supersources \nnr::Int64=10\n : number receivers for each super source \nloc::Vector{Float64}=[0.,0.]\n : location of origin \nrad::Float64=100.\n : radius \n\u03b8lim::Vector{Float64}=[0.,2*pi]\n : range of angular offset between source and receiver\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_find\n \u2014 \nMethod\n.\n\n\nGiven receiver positions \nrpos\n and \nrpos0\n. Returns an array Int indices of the dimension of number of supersources with \ntrue\n at indices, if the waves due to that particular source are  recorded.\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_fixed\n \u2014 \nFunction\n.\n\n\nReturn fixed spread acquisition geometry depending  on either horizontal or vertical array It has only one source for every supersource\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_get\n \u2014 \nMethod\n.\n\n\nReturn some derived fields of \nGeom\n\n\nOutputs\n\n\nattrib=:uspos\n : a tuple of x and z positions of unique sources \nattrib=:urpos\n : a tuple of x and z position of unique receivers \nattrib=:nus\n : number of unique source positions \nattrib=:nur\n : number of unique source positions\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_fixed\n \u2014 \nMethod\n.\n\n\nConstructor for \nSrc\n data type. repeat same source wavelet for all sources and supersources\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of sources\n\n\nwav::Array{Float64}\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_tr\n \u2014 \nMethod\n.\n\n\nFunction that returns Src after time reversal\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_uspos\n \u2014 \nMethod\n.\n\n\nPad \nSrc\n  tgrids should be same in all Src\n\n\nsource\n\n\n\n\nSpline Representations\n\n\n#\n\n\nSIT.Interpolation.indminn\n \u2014 \nMethod\n.\n\n\nTODO:\n\n\n\n\nadd dimension checks to interp_spray!\n\n\n\n\nReference: https://www.ibiblio.org/e-notes/Splines/bezier.html\n\n\nReturn n indices in order Cannot find a julia method which does, this. If a faster method is found, replace it later.\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.interp_B1_1D\n \u2014 \nMethod\n.\n\n\nthis subroutine interpolates or sprays bilinearly [one is adjoint of another] interpolation returns y using y1, y2 spraying returns y1, y2 using y\n\n\n                    +                      \n                    |                      \ny1= f(x1)           |      y2= f(x2)   \n  +-----------------x--------+             \n             y=f(x) |                      \n                    +\n\n\n\n\n\nbilinear interpolation Reference: http://www.ajdesigner.com/phpinterpolation/bilinear_interpolation_equation.php\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.interp_B2_1D\n \u2014 \nMethod\n.\n\n\nthis subroutine interpolates or sprays  using cubic bspline interpolation returns y using y1, y2, y3, y4 spraying returns y1, y2, y3, y4 using y\n\n\n                   +                      \n                   |\n\n\n\n\n\ny1      y2          |    y3       y4      +\u2013\u2013\u2013-+\u2013\u2013\u2013\u2013-x\u2013\u2013+\u2013\u2013\u2013\u2013+                              y=f(x) |                                              +                      \n\n\nsource\n\n\n\n\nModels\n\n\n#\n\n\nSIT.Models.Seismic\n \u2014 \nType\n.\n\n\nData type fo represent a seismic model.\n\n\nFields\n\n\n\n\nvp0::Vector{Float64}\n : [vpmin, vpmax]\n\n\nvs0::Vector{Float64}\n : [vsmin, vsmax]\n\n\n\u03c10::Vector{Float64}\n : [\u03c1min, \u03c1max]\n\n\n\u03c7vp::Array{Float64}\n :\n\n\n\u03c7vs::Array{Float64}\n :\n\n\n\u03c7\u03c1::Array{Float64}\n :\n\n\nmgrid::Grid.M2D\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_addon!\n \u2014 \nMethod\n.\n\n\nAdd features to a model.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model that is modified\n\n\n\n\nKeyword Arguments\n\n\n\n\ncirc_loc::Vector{Float64}=nothing\n : location of center of perturbation\n\n\ncirc_rad::Float64=0.0\n : radius of circular perturbation\n\n\ncirc_pert::Float64=0.1\n : perturbation inside a circle\n\n\nrect_loc::Array{Float64}=nothing\n : rectangle location\n\n\nrect_pert::Float64=0.1\n : perturbation in a rectangle\n\n\nrandn_pert::Float64=0.0\n : percentage of reference values for additive random noise\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_chainrule!\n \u2014 \nFunction\n.\n\n\nUse chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.\n\n\nArguments\n\n\n\n\ngmod::Seismic\n : gradient model\n\n\nmod::Seismic\n : model required for chain rule\n\n\ng1\n : gradient of an objective function with respect \nattribs[1]\n\n\ng2\n : gradient of an objective function with respect \nattribs[2]\n\n\nattribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]\n :\n\n\n\n\nflag::Int64=1\n :\n\n\n\n\n=1\n updates \ngmod\n using \ng1\n and \ng2\n\n\n=-1\n updates \ng1\n and \ng2\n using \ngmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_get\n \u2014 \nMethod\n.\n\n\nGet other dependent model parameters of a seismic model that are not present in \nSeismic\n.\n\n\n\n\n:\u03c1I\n : inverse of density\n\n\n:Zp\n : P-wave impedance\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_interp_spray!\n \u2014 \nMethod\n.\n\n\nfunction to resample in the model domain\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model\n\n\nmodi::Seismic\n : model after interpolation\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_issimilar\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_issimilar\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_pad_trun\n \u2014 \nMethod\n.\n\n\nExtend a seismic model into PML layers\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_reparameterize!\n \u2014 \nFunction\n.\n\n\nRe-parameterization routine  that modifies the fields  \n\u03c7vp\n and \n\u03c7\u03c1\n of an input seismic model using two input vectors.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : to be updated\n\n\nx1::Array{Float64,2}\n : contrast of inverse bulk modulus\n\n\nx2::Array{Float64,2}\n : contrast of inverse density\n\n\nattribs:::Vector{Symbol}\n : [:\u03c7KI, :\u03c7\u03c1I]\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_zeros\n \u2014 \nMethod\n.\n\n\nReturn \nSeismic\n with zeros everywhere; this method is used for preallocation.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : used for sizes of \u03c7 fields\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.pad_trun\n \u2014 \nFunction\n.\n\n\nExtend a model on all four sides\n\n\nsource\n\n\n#\n\n\nSIT.Models.\u03c7\n \u2014 \nFunction\n.\n\n\nReturn dimensionless contrast model parameter using the reference value.\n\n\nArguments\n\n\n\n\nmod::Array{Float64}\n : subsurface parameter\n\n\nmod0::Vector{Float64}\n : reference value is mean of this vector\n\n\nflag::Int64=1\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.\u03c7g\n \u2014 \nFunction\n.\n\n\nGradients Return contrast model parameter using the reference value.\n\n\nsource\n\n\n\n\nData\n\n\n#\n\n\nSIT.Data.TD\n \u2014 \nType\n.\n\n\nTime domain representation of Seismic Data. TODO: Also include acqsrc?\n\n\nFields\n\n\n\n\nd::Array{Array{Float64,2},2}\n : data\n\n\nnfield::Int64\n : number of components at each receiver\n\n\ntgrid::Grid.M1D\n : grid to represent time\n\n\nacqgeom::Acquisition.Geom\n : geometry used to generate the data\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_dot\n \u2014 \nMethod\n.\n\n\nReturns dot product of the data\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_iszero\n \u2014 \nMethod\n.\n\n\nReturn bool depending on if \nd\n in \nTD\n is all zero. \n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_normalize\n \u2014 \nMethod\n.\n\n\nnormalize time-domain seismic data\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_resamp\n \u2014 \nMethod\n.\n\n\nfunction to resample data in time domain\n\n\nArguments\n\n\n\n\ndata\n : input data of type \nTD\n\n\ntgrid\n : resampling in time according to this time grid\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_tr!\n \u2014 \nMethod\n.\n\n\nTime reverse the records of each receiver in \nTD\n \n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_urpos\n \u2014 \nMethod\n.\n\n\nConstruct TD using data at all the unique receiver positions for all supersources.\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_zeros\n \u2014 \nMethod\n.\n\n\nReturn zeros\n\n\nsource\n\n\n#\n\n\nSIT.Data.TDcoup!\n \u2014 \nMethod\n.\n\n\nApply coupling functions to TD\n\n\n\n\n:s means s is returned in the place of rs\n\n\n:w means\n\n\n\n\nsource\n\n\n\n\nData Misfits\n\n\n#\n\n\nSIT.Misfits.TD\n \u2014 \nMethod\n.\n\n\nInput the obeserved and modelled data to output the misfit and the adjoint sources TODO: \n\n\nsource\n\n\n#\n\n\nSIT.Misfits.error_after_scaling\n \u2014 \nMethod\n.\n\n\nNormalized least-squares error between two vectors after  estimating a scalar that best fits on to another. Return misfit and \u03b1 such that \u03b1x-y is minimum. Normalization is done with respect to the  norm of y.\n\n\nsource\n\n\n\n\nGallery\n\n\n#\n\n\nSIT.Gallery.Geom\n \u2014 \nMethod\n.\n\n\nGallery of acquisition geometries \nGeom\n based on input \nM2D\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:oneonev\n : one source at (xmin, mean(z)) and one receiver at (xmax, mean(z))\n\n\nattrib=:twotwov\n : two vertical wells, two sources at xmin and two receivers at xmax\n\n\nattrib=:tentenv\n : two vertical wells, two sources at xmin and two receivers at xmax\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.Geom\n \u2014 \nMethod\n.\n\n\nGallery of acquisition geometries \nGeom\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a simple one source and one receiver configuration\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.M1D\n \u2014 \nMethod\n.\n\n\nGallery of \nM1D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a time grid for with 1000 samples; maximum time is 2 s\n\n\nattrib=:acou_homo1_long\n : a time grid for with 1000 samples; maximum time is 4 s\n\n\nattrib=:npow2samp1\n : a sample npow2 grid with 16 samples\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.M2D\n \u2014 \nMethod\n.\n\n\nGallery of \nM2D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a square grid for with 201 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\n\n\nattrib=:acou_homo2\n : a square grid for with 51 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.Seismic\n \u2014 \nMethod\n.\n\n\nGallery of \nSeismic\n models.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : an homogeneous acoustic model with \nvp0=2000\n and \n\u03c10=2000\n\n\nattrib=:acou_homo2\n : same as above, but with spatial sampling as 40 m (faster testing)\n\n\nattrib=:seismic_marmousi2\n : marmousi model with lower resolution; ideal for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_high_res\n : marmousi model high resolution; slower to load\n\n\nattrib=:seismic_marmousi2_box1\n : 1x1 kilometer box of marmousi model; ideal for crosswell, borehole seismic studies\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.Src\n \u2014 \nFunction\n.\n\n\nGallery of source signals \nSrc\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\nnss::Int64=1\n : number of supersources\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n :\n\n\n\n\nsource\n\n\n\n\nFinite-difference Time-domain Modelling\n\n\n#\n\n\nSIT.Fdtd.get_rhovxI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.get_rhovzI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.mod!\n \u2014 \nMethod\n.\n\n\nAs forward modeling method, the  finite-difference method is employed.  It uses a discrete version of the two-dimensional isotropic acoustic wave equation. As shown in   Figure~ef{fdshmesh_acou}, a staggered-grid mesh is used \n\n\nKeyword Arguments\n\n\n\n\nnpropwav::Int64=1\n : number of independently propagating wavefields in \nmodel\n\n\nmodel::Models.Seismic\n : seismic medium parameters\n\n\nmodel_pert::Models.Seismic\n : perturbed model, i.e., model + \u03b4model, used for Born modeling\n\n\ntgridmod::Grid.M1D\n : modelling time vector\n\n\ntgrid::Grid.M1D\n : output records are interpolated on this time vector\n\n\nrecv_nfield::Int64=1\n : number of fields that receivers record\n\n\nboundary_save_flag::Bool=Int64\n : save final state variables and the boundary conditions for later use\n\n\nboundary_in::Any=[0]\n : input final state variables and boundary\n\n\nabs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]\n : PML boundary conditions\n\n\nborn_flag::Bool=false\n : Born modeling flag\n\n\ngrad_out_flag=false\n : output gradient or not\n\n\nverbose::Bool=false\n : verbose flag\n\n\n\n\nExample\n\n\njulia\n>\n \nrecords\n,\n \nboundary_save\n  \n=\n \nmod\n();\n\n\n\n\n\n\nCredits: Pawan Bharadwaj, 2017\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.pml_variables\n \u2014 \nMethod\n.\n\n\nsource\n\n\n\n\nInversion\n\n\n#\n\n\nSIT.Inversion.Param\n \u2014 \nType\n.\n\n\nInversion Parameters, i.e., factors that  are fixed throughout the inversion\n\n\nFields\n\n\n\n\nmgrid::Grid.M2D\n : modelling grid\n\n\nigrid::Grid.M2D\n : inversion grid\n\n\nacqsrc::Acquisition.Src\n : base source wavelet for modelling data\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\ntgrid::Grid.M1D\n :\n\n\nattrib_mod::Symbol\n\n\nmodel_obs\n : model used for generating observed data\n\n\nmodel0\n : background velocity model (only used during Born modeling and inversion)\n\n\nparameterization\n : a vector of Symbols specifying parameterization of the inversion vector\n\n\nverbose\n : print level\n\n\nattrib\n : synthetic or real\n\n\n\n\nTODO: add an extra attribute for coupling functions inversion and modelling\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Param\n \u2014 \nMethod\n.\n\n\nConstructor for \nParam\n\n\n\n\nmodel\n : initial model, the reference values are used from this\n\n\n\n\n\"Seismic model used to generate 'observed' synthetic data\" modm_obs::Models.Seismic\n\n\n\"source wavelet used to generate 'observed' synthetic data\" acqsrc_obs::Acquisition.Src\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.AdjGeom\n \u2014 \nMethod\n.\n\n\nModify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Coupling_x!\n \u2014 \nMethod\n.\n\n\nConvert coupling functions to x and vice versa\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_gx!\n \u2014 \nMethod\n.\n\n\nConvert gradient vector to \nSeismic\n type and vice versa This will be different from the previous one, once  the parameterizations come in\n\n\n\n\ngmodm::Models.Seismic\n : gradient model on the modelling grid\n\n\nmodm::Models.Seismic\n : model on the modelling grid\n\n\ngmodi::Models.Seismic\n : gradient model on the inversion grid\n\n\nmodi::Models.Seismic\n : model on the inversion grid\n\n\ngx::Vector{Float64}\n : gradient vector\n\n\npa::Param\n :\n\n\n\n\nflag::Int64\n :\n\n\n\n\n=1\n update the vector \ngx\n using \ngmod\n\n\n=-1\n update gmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_x!\n \u2014 \nMethod\n.\n\n\nConvert \nSeismic\n model to x and vice versa\n\n\n\n\nmodm::Models.Seismic\n : seismic model on modelling grid (input zeros to not use it)\n\n\nmodi::Models.Seismic\n : seismic model on inversion grid\n\n\nx::Vector{Float64}\n : inversion vector\n\n\npa::Param\n : fwi parameters\n\n\n\n\nflag::Int64\n : \n\n\n\n\n=1\n converts either modm or modi to x\n\n\n=-1\n updates both modm and modi using x\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_xbound!\n \u2014 \nMethod\n.\n\n\nReturn bound vectors for the \nSeismic\n model,  depeding on paramaterization\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.func_Coupling\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nSIT.Inversion.func_xfwi\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nSIT.Inversion.grad_Coupling!\n \u2014 \nMethod\n.\n\n\nThere is a bug in gradient computation\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.update_buffer!\n \u2014 \nFunction\n.\n\n\nUpdate the buffer, which consists of the modelled data and boundary values for adjoint calculation.\n\n\nArguments\n\n\n\n\nx::Vector{Float64}\n : inversion variable\n\n\nlast_x::Vector{Float64}\n : buffer is only updated when x!=last_x, and modified such that last_x=x\n\n\npa::Param\n : parameters that are constant during the inversion\n\n\nmodm::Models.Seismic\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.update_buffer_zeros\n \u2014 \nMethod\n.\n\n\nallocate buffer\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.wfwi!\n \u2014 \nMethod\n.\n\n\nUpdate pa.w\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.wfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables \nParam\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.xfwi!\n \u2014 \nMethod\n.\n\n\nFWI using Optim, updates pa.modm and pa.dcal\n\n\nArguments\n\n\n\n\nmodel:Models.Seismic\n : initial model and it is updated\n\n\ndobs::Data.TD=Data.TD_zeros(1,pa.dcal.tgrid,pa.acqgeom)\n : input observed data\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.xfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables \nParam\n\n\nsource\n\n\n\n\nInterferometry\n\n\n#\n\n\nSIT.Interferometry.TD_virtual_diff\n \u2014 \nMethod\n.\n\n\nenhance diffractions in the \nTD\n\n\nKeyword Arguments\n\n\n\u03bbdom::Float64=0.0\n : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005) \ntlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]\n : maximum lag time in the output traces \n\n\nsource\n\n\n\n\nIndependent Component Analysis for Convolutive Mixtures\n\n\n#\n\n\nSIT.CICA.bica\n \u2014 \nMethod\n.\n\n\nPerforms ICA for convolutive mixtures.\n\n\nArguments\n\n\n\n\nmagic_recv\n: a receiver index, where deblending is performed\n\n\nrecv_n\n: total number of receivers\n\n\nsrc_n\n: total number of sources\n\n\ngrid\n: \nM1D\n grid\n\n\nnband\n: number of frequency bins, where ICA is performed\n\n\nnsubfac\n: overlap factor (testing)\n\n\nX\n: blended data\n\n\n\n\nOutput\n\n\n\n\nY\n: deblended data at \nmagic_recv\n\n\n\n\nsource\n\n\n#\n\n\nSIT.CICA.exact_freq_mixing\n \u2014 \nMethod\n.\n\n\nConvolutive mixing in the frequency domain.\n\n\nArguments\n\n\n\n\nAs\n:\n\n\nAb\n:\n\n\nB\n:\n\n\nS\n:\n\n\nfgrid\n:\n\n\n\n\nOutputs\n\n\n\n\nD\n\n\nd\n\n\nDs\n\n\nds\n\n\nDb\n\n\ndb\n\n\n\n\nsource\n\n\n\n\nPlots\n\n\n#\n\n\nSIT.Plots.printfig\n \u2014 \nMethod\n.\n\n\nsave current fig using matlab2tikz\n\n\nsource\n\n\n#\n\n\nSIT.Plots.Geom\n \u2014 \nMethod\n.\n\n\nPlot acquisition geometry \nAcquisition.Geom\n on  and model grid \nM2D\n.\n\n\nattrib::Symbol=:unique\n : default; plots unique source and receiver positions \n\n\nsource\n\n\n#\n\n\nSIT.Plots.Seismic\n \u2014 \nMethod\n.\n\n\nPlot seismic model\n\n\nArguments\n\n\n\n\nmodel::Models.Seismic\n =\n\n\n\n\nKeyword Arguments\n\n\n\n\nxlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]\n :\n\n\nzlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Plots.Src\n \u2014 \nMethod\n.\n\n\nPlot acqsrc\n\n\nsource\n\n\n#\n\n\nSIT.Plots.TD\n \u2014 \nMethod\n.\n\n\nPlot time-domain data of type \nData.TD\n\n\nArguments\n\n\n\n\ntd::Data.TD\n :\n\n\n\n\nKeyword Arguments\n\n\n\n\nssvec::Vector{Int64}=[1]\n : supersource vector to be plotted\n\n\nfieldvec::Vector{Int64}=[1]\n : field vector to be plotted\n\n\ntr_flag::Bool=false\n : plot time-reversed data when true\n\n\nattrib::Symbol=:wav\n : specify type of plot\n\n\n\n\nsource\n\n\n%## Another Section %\n@contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %\n %  %\n@contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %\n\n\n\n\nIndex\n\n\n\n\nSIT.Acquisition.Geom\n\n\nSIT.Acquisition.Src\n\n\nSIT.Coupling.TD\n\n\nSIT.Data.TD\n\n\nSIT.Grid.M1D\n\n\nSIT.Grid.M1D\n\n\nSIT.Grid.M2D\n\n\nSIT.Inversion.Param\n\n\nSIT.Inversion.Param\n\n\nSIT.Models.Seismic\n\n\nSIT.Acquisition.Geom_boundary\n\n\nSIT.Acquisition.Geom_circ\n\n\nSIT.Acquisition.Geom_find\n\n\nSIT.Acquisition.Geom_fixed\n\n\nSIT.Acquisition.Geom_get\n\n\nSIT.Acquisition.Geom_getvec\n\n\nSIT.Acquisition.Src_fixed\n\n\nSIT.Acquisition.Src_getvec\n\n\nSIT.Acquisition.Src_tr\n\n\nSIT.Acquisition.Src_uspos\n\n\nSIT.CICA.bica\n\n\nSIT.CICA.exact_freq_mixing\n\n\nSIT.Coupling.TD_delta\n\n\nSIT.Data.TD_dot\n\n\nSIT.Data.TD_iszero\n\n\nSIT.Data.TD_normalize\n\n\nSIT.Data.TD_resamp\n\n\nSIT.Data.TD_tr!\n\n\nSIT.Data.TD_urpos\n\n\nSIT.Data.TD_zeros\n\n\nSIT.Data.TDcoup!\n\n\nSIT.Fdtd.get_rhovxI\n\n\nSIT.Fdtd.get_rhovzI\n\n\nSIT.Fdtd.mod!\n\n\nSIT.Fdtd.pml_variables\n\n\nSIT.Gallery.Geom\n\n\nSIT.Gallery.Geom\n\n\nSIT.Gallery.M1D\n\n\nSIT.Gallery.M2D\n\n\nSIT.Gallery.Seismic\n\n\nSIT.Gallery.Src\n\n\nSIT.Grid.M1D_isequal\n\n\nSIT.Grid.M1D_lag\n\n\nSIT.Grid.M1D_npow2\n\n\nSIT.Grid.M1D_npow2_tf\n\n\nSIT.Grid.M1D_resamp\n\n\nSIT.Grid.M1D_truncate\n\n\nSIT.Grid.M2D_boundary\n\n\nSIT.Grid.M2D_isequal\n\n\nSIT.Grid.M2D_pad_trun\n\n\nSIT.Grid.M2D_resamp\n\n\nSIT.Interferometry.TD_virtual_diff\n\n\nSIT.Interpolation.indminn\n\n\nSIT.Interpolation.interp_B1_1D\n\n\nSIT.Interpolation.interp_B2_1D\n\n\nSIT.Inversion.AdjGeom\n\n\nSIT.Inversion.Coupling_x!\n\n\nSIT.Inversion.Seismic_gx!\n\n\nSIT.Inversion.Seismic_x!\n\n\nSIT.Inversion.Seismic_xbound!\n\n\nSIT.Inversion.func_Coupling\n\n\nSIT.Inversion.func_xfwi\n\n\nSIT.Inversion.grad_Coupling!\n\n\nSIT.Inversion.update_buffer!\n\n\nSIT.Inversion.update_buffer_zeros\n\n\nSIT.Inversion.wfwi!\n\n\nSIT.Inversion.wfwi_ninv\n\n\nSIT.Inversion.xfwi!\n\n\nSIT.Inversion.xfwi_ninv\n\n\nSIT.Misfits.TD\n\n\nSIT.Misfits.error_after_scaling\n\n\nSIT.Models.Seismic_addon!\n\n\nSIT.Models.Seismic_chainrule!\n\n\nSIT.Models.Seismic_get\n\n\nSIT.Models.Seismic_interp_spray!\n\n\nSIT.Models.Seismic_isequal\n\n\nSIT.Models.Seismic_issimilar\n\n\nSIT.Models.Seismic_issimilar\n\n\nSIT.Models.Seismic_pad_trun\n\n\nSIT.Models.Seismic_reparameterize!\n\n\nSIT.Models.Seismic_zeros\n\n\nSIT.Models.pad_trun\n\n\nSIT.Models.\u03c7\n\n\nSIT.Models.\u03c7g\n\n\nSIT.Plots.Geom\n\n\nSIT.Plots.Seismic\n\n\nSIT.Plots.Src\n\n\nSIT.Plots.TD\n\n\nSIT.Plots.printfig\n\n\nSIT.Wavelets.ormsby\n\n\nSIT.Wavelets.ricker",
            "title": "Home"
        },
        {
            "location": "/#grids",
            "text": "#  SIT.Grid.M1D  \u2014  Type .  Data type to represent 1D grid.  Fields   x  : values  nx  : number of samples  \u03b4x  : sampling interval   source  #  SIT.Grid.M1D  \u2014  Method .  Construct 1-D grid based on nx or \u03b4x  source  #  SIT.Grid.M2D  \u2014  Type .  Data type to represent 2D grid.  Fields   x  : horizontal values  z  : vertical values  nx  : number of samples in horizontal direction  nz  : number of samples in vertical direction  \u03b4x  : sampling interval in horizontal direction  \u03b4z  : sampling interval in vertical direction   source  #  SIT.Grid.M1D_isequal  \u2014  Method .  Logical operation for  M1D  source  #  SIT.Grid.M1D_lag  \u2014  Method .  Grid with both positive and negative samples for a given lag. Make sure that the number so samples is odd  source  #  SIT.Grid.M1D_npow2  \u2014  Method .  output an npow2grid of either time or frequency  source  #  SIT.Grid.M1D_npow2_tf  \u2014  Method .  convertion between time and frequency npow2 grids  source  #  SIT.Grid.M1D_resamp  \u2014  Method .  1-D grid with a different sampling interval   Not yet implemented for npow2 grids   source  #  SIT.Grid.M1D_truncate  \u2014  Method .  1-D grid which is has a different size  source  #  SIT.Grid.M2D_boundary  \u2014  Method .  Return the X and Z positions of the boundary of mgrid attrib   :inner   :outer ** onlycount  source  #  SIT.Grid.M2D_isequal  \u2014  Method .  Logical operation for  M2D  source  #  SIT.Grid.M2D_pad_trun  \u2014  Method .  Extend M2D by its npml grid points on all sides  source  #  SIT.Grid.M2D_resamp  \u2014  Method .  2-D grid with a different sampling interval  source",
            "title": "Grids"
        },
        {
            "location": "/#source-wavelets",
            "text": "#  SIT.Wavelets.ormsby  \u2014  Method .  ormbsy wavelet  source  #  SIT.Wavelets.ricker  \u2014  Method .  Generate a Ricker Wavelet  Arguments   fqdom : dominant frequency  tgrid : time-domain grid  tpeak : the peak of the ricker in time  ``   source",
            "title": "Source Wavelets"
        },
        {
            "location": "/#source-and-receiver-coupling",
            "text": "#  SIT.Coupling.TD  \u2014  Type .  source  #  SIT.Coupling.TD_delta  \u2014  Method .  Return delta functions  source",
            "title": "Source and Receiver Coupling"
        },
        {
            "location": "/#acquisition",
            "text": "#  SIT.Acquisition.Geom  \u2014  Type .  Acquisiton of supersources, sources and receivers. Each supersource has multiple sources that are  injected (active) simultaneously. Each supersource  has a set of receivers that  record waves.   Fields   sx::Vector{Vector{Float64,1},1}  : $x$ positions of sources  sz::Vector{Vector{Float64,1},1}  : $z$ positions of sources  rx::Vector{Vector{Float64,1},1}  : $x$ positions of receivers  rz::Vector{Vector{Float64,1},1}  : $z$ positions of receivers  nss::Int64  : number of supersources  ns::Vector{Int64,1}  : number of sources for every supersource  nr::Vector{Int64,1}  : number of receivers for every supersource   source  #  SIT.Acquisition.Src  \u2014  Type .  Data type for the sources used.  Fields   nss::Int64  : number of supersources  ns::Array{Int64}  : number of sources for each supersource  nfield::Int64  : number of fields  wav::Array{Float64}  : wavelets in time domain  tgrid::Grid.M1D  : time grid   source  #  SIT.Acquisition.Geom_boundary  \u2014  Method .  Modify input  Geom  such that the output has either sources or receivers on the boundary of   mgrid .  Arguments   acqgeom::Geom  : input geometry  mgrid::Grid.M2D  : to determine the boundary  attrib::Symbol  : either  :srcborder  or  :recborder   source  #  SIT.Acquisition.Geom_circ  \u2014  Method .  Circular acquisition. The sources and receivers can also be placed on a circle of radius  rad . The origin of the circle is at  loc .  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by  \u03b8lim  Arguments  nss::Int64=10  : number of supersources  nr::Int64=10  : number receivers for each super source  loc::Vector{Float64}=[0.,0.]  : location of origin  rad::Float64=100.  : radius  \u03b8lim::Vector{Float64}=[0.,2*pi]  : range of angular offset between source and receiver  source  #  SIT.Acquisition.Geom_find  \u2014  Method .  Given receiver positions  rpos  and  rpos0 . Returns an array Int indices of the dimension of number of supersources with  true  at indices, if the waves due to that particular source are  recorded.  source  #  SIT.Acquisition.Geom_fixed  \u2014  Function .  Return fixed spread acquisition geometry depending  on either horizontal or vertical array It has only one source for every supersource  source  #  SIT.Acquisition.Geom_get  \u2014  Method .  Return some derived fields of  Geom  Outputs  attrib=:uspos  : a tuple of x and z positions of unique sources  attrib=:urpos  : a tuple of x and z position of unique receivers  attrib=:nus  : number of unique source positions  attrib=:nur  : number of unique source positions  source  #  SIT.Acquisition.Geom_getvec  \u2014  Method .  return a vector of the order   source  #  SIT.Acquisition.Src_fixed  \u2014  Method .  Constructor for  Src  data type. repeat same source wavelet for all sources and supersources  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of sources  wav::Array{Float64}   source  #  SIT.Acquisition.Src_getvec  \u2014  Method .  return a vector of the order   source  #  SIT.Acquisition.Src_tr  \u2014  Method .  Function that returns Src after time reversal  source  #  SIT.Acquisition.Src_uspos  \u2014  Method .  Pad  Src   tgrids should be same in all Src  source",
            "title": "Acquisition"
        },
        {
            "location": "/#spline-representations",
            "text": "#  SIT.Interpolation.indminn  \u2014  Method .  TODO:   add dimension checks to interp_spray!   Reference: https://www.ibiblio.org/e-notes/Splines/bezier.html  Return n indices in order Cannot find a julia method which does, this. If a faster method is found, replace it later.  source  #  SIT.Interpolation.interp_B1_1D  \u2014  Method .  this subroutine interpolates or sprays bilinearly [one is adjoint of another] interpolation returns y using y1, y2 spraying returns y1, y2 using y                      +                      \n                    |                      \ny1= f(x1)           |      y2= f(x2)   \n  +-----------------x--------+             \n             y=f(x) |                      \n                    +  bilinear interpolation Reference: http://www.ajdesigner.com/phpinterpolation/bilinear_interpolation_equation.php  source  #  SIT.Interpolation.interp_B2_1D  \u2014  Method .  this subroutine interpolates or sprays  using cubic bspline interpolation returns y using y1, y2, y3, y4 spraying returns y1, y2, y3, y4 using y                     +                      \n                   |  y1      y2          |    y3       y4      +\u2013\u2013\u2013-+\u2013\u2013\u2013\u2013-x\u2013\u2013+\u2013\u2013\u2013\u2013+                              y=f(x) |                                              +                        source",
            "title": "Spline Representations"
        },
        {
            "location": "/#models",
            "text": "#  SIT.Models.Seismic  \u2014  Type .  Data type fo represent a seismic model.  Fields   vp0::Vector{Float64}  : [vpmin, vpmax]  vs0::Vector{Float64}  : [vsmin, vsmax]  \u03c10::Vector{Float64}  : [\u03c1min, \u03c1max]  \u03c7vp::Array{Float64}  :  \u03c7vs::Array{Float64}  :  \u03c7\u03c1::Array{Float64}  :  mgrid::Grid.M2D  :   source  #  SIT.Models.Seismic_addon!  \u2014  Method .  Add features to a model.  Arguments   mod::Seismic  : model that is modified   Keyword Arguments   circ_loc::Vector{Float64}=nothing  : location of center of perturbation  circ_rad::Float64=0.0  : radius of circular perturbation  circ_pert::Float64=0.1  : perturbation inside a circle  rect_loc::Array{Float64}=nothing  : rectangle location  rect_pert::Float64=0.1  : perturbation in a rectangle  randn_pert::Float64=0.0  : percentage of reference values for additive random noise   source  #  SIT.Models.Seismic_chainrule!  \u2014  Function .  Use chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.  Arguments   gmod::Seismic  : gradient model  mod::Seismic  : model required for chain rule  g1  : gradient of an objective function with respect  attribs[1]  g2  : gradient of an objective function with respect  attribs[2]  attribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]  :   flag::Int64=1  :   =1  updates  gmod  using  g1  and  g2  =-1  updates  g1  and  g2  using  gmod     source  #  SIT.Models.Seismic_get  \u2014  Method .  Get other dependent model parameters of a seismic model that are not present in  Seismic .   :\u03c1I  : inverse of density  :Zp  : P-wave impedance   source  #  SIT.Models.Seismic_interp_spray!  \u2014  Method .  function to resample in the model domain  Arguments   mod::Seismic  : model  modi::Seismic  : model after interpolation   source  #  SIT.Models.Seismic_isequal  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_issimilar  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_issimilar  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_pad_trun  \u2014  Method .  Extend a seismic model into PML layers  source  #  SIT.Models.Seismic_reparameterize!  \u2014  Function .  Re-parameterization routine  that modifies the fields   \u03c7vp  and  \u03c7\u03c1  of an input seismic model using two input vectors.  Arguments   mod::Seismic  : to be updated  x1::Array{Float64,2}  : contrast of inverse bulk modulus  x2::Array{Float64,2}  : contrast of inverse density  attribs:::Vector{Symbol}  : [:\u03c7KI, :\u03c7\u03c1I]   source  #  SIT.Models.Seismic_zeros  \u2014  Method .  Return  Seismic  with zeros everywhere; this method is used for preallocation.  Arguments   mgrid::Grid.M2D  : used for sizes of \u03c7 fields   source  #  SIT.Models.pad_trun  \u2014  Function .  Extend a model on all four sides  source  #  SIT.Models.\u03c7  \u2014  Function .  Return dimensionless contrast model parameter using the reference value.  Arguments   mod::Array{Float64}  : subsurface parameter  mod0::Vector{Float64}  : reference value is mean of this vector  flag::Int64=1  :   source  #  SIT.Models.\u03c7g  \u2014  Function .  Gradients Return contrast model parameter using the reference value.  source",
            "title": "Models"
        },
        {
            "location": "/#data",
            "text": "#  SIT.Data.TD  \u2014  Type .  Time domain representation of Seismic Data. TODO: Also include acqsrc?  Fields   d::Array{Array{Float64,2},2}  : data  nfield::Int64  : number of components at each receiver  tgrid::Grid.M1D  : grid to represent time  acqgeom::Acquisition.Geom  : geometry used to generate the data   source  #  SIT.Data.TD_dot  \u2014  Method .  Returns dot product of the data  source  #  SIT.Data.TD_iszero  \u2014  Method .  Return bool depending on if  d  in  TD  is all zero.   source  #  SIT.Data.TD_normalize  \u2014  Method .  normalize time-domain seismic data  source  #  SIT.Data.TD_resamp  \u2014  Method .  function to resample data in time domain  Arguments   data  : input data of type  TD  tgrid  : resampling in time according to this time grid   source  #  SIT.Data.TD_tr!  \u2014  Method .  Time reverse the records of each receiver in  TD    source  #  SIT.Data.TD_urpos  \u2014  Method .  Construct TD using data at all the unique receiver positions for all supersources.  source  #  SIT.Data.TD_zeros  \u2014  Method .  Return zeros  source  #  SIT.Data.TDcoup!  \u2014  Method .  Apply coupling functions to TD   :s means s is returned in the place of rs  :w means   source",
            "title": "Data"
        },
        {
            "location": "/#data-misfits",
            "text": "#  SIT.Misfits.TD  \u2014  Method .  Input the obeserved and modelled data to output the misfit and the adjoint sources TODO:   source  #  SIT.Misfits.error_after_scaling  \u2014  Method .  Normalized least-squares error between two vectors after  estimating a scalar that best fits on to another. Return misfit and \u03b1 such that \u03b1x-y is minimum. Normalization is done with respect to the  norm of y.  source",
            "title": "Data Misfits"
        },
        {
            "location": "/#gallery",
            "text": "#  SIT.Gallery.Geom  \u2014  Method .  Gallery of acquisition geometries  Geom  based on input  M2D .  Arguments   attrib::Symbol  :   Outputs   attrib=:oneonev  : one source at (xmin, mean(z)) and one receiver at (xmax, mean(z))  attrib=:twotwov  : two vertical wells, two sources at xmin and two receivers at xmax  attrib=:tentenv  : two vertical wells, two sources at xmin and two receivers at xmax   source  #  SIT.Gallery.Geom  \u2014  Method .  Gallery of acquisition geometries  Geom .  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a simple one source and one receiver configuration   source  #  SIT.Gallery.M1D  \u2014  Method .  Gallery of  M1D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a time grid for with 1000 samples; maximum time is 2 s  attrib=:acou_homo1_long  : a time grid for with 1000 samples; maximum time is 4 s  attrib=:npow2samp1  : a sample npow2 grid with 16 samples   source  #  SIT.Gallery.M2D  \u2014  Method .  Gallery of  M2D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a square grid for with 201 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.   attrib=:acou_homo2  : a square grid for with 51 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.  source  #  SIT.Gallery.Seismic  \u2014  Method .  Gallery of  Seismic  models.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : an homogeneous acoustic model with  vp0=2000  and  \u03c10=2000  attrib=:acou_homo2  : same as above, but with spatial sampling as 40 m (faster testing)  attrib=:seismic_marmousi2  : marmousi model with lower resolution; ideal for surface seismic experiments  attrib=:seismic_marmousi2_high_res  : marmousi model high resolution; slower to load  attrib=:seismic_marmousi2_box1  : 1x1 kilometer box of marmousi model; ideal for crosswell, borehole seismic studies   source  #  SIT.Gallery.Src  \u2014  Function .  Gallery of source signals  Src .  Arguments   attrib::Symbol  :  nss::Int64=1  : number of supersources   Outputs   attrib=:acou_homo1  :   source",
            "title": "Gallery"
        },
        {
            "location": "/#finite-difference-time-domain-modelling",
            "text": "#  SIT.Fdtd.get_rhovxI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  SIT.Fdtd.get_rhovzI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  SIT.Fdtd.mod!  \u2014  Method .  As forward modeling method, the  finite-difference method is employed.  It uses a discrete version of the two-dimensional isotropic acoustic wave equation. As shown in   Figure~ef{fdshmesh_acou}, a staggered-grid mesh is used   Keyword Arguments   npropwav::Int64=1  : number of independently propagating wavefields in  model  model::Models.Seismic  : seismic medium parameters  model_pert::Models.Seismic  : perturbed model, i.e., model + \u03b4model, used for Born modeling  tgridmod::Grid.M1D  : modelling time vector  tgrid::Grid.M1D  : output records are interpolated on this time vector  recv_nfield::Int64=1  : number of fields that receivers record  boundary_save_flag::Bool=Int64  : save final state variables and the boundary conditions for later use  boundary_in::Any=[0]  : input final state variables and boundary  abs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]  : PML boundary conditions  born_flag::Bool=false  : Born modeling flag  grad_out_flag=false  : output gradient or not  verbose::Bool=false  : verbose flag   Example  julia >   records ,   boundary_save    =   mod ();   Credits: Pawan Bharadwaj, 2017  source  #  SIT.Fdtd.pml_variables  \u2014  Method .  source",
            "title": "Finite-difference Time-domain Modelling"
        },
        {
            "location": "/#inversion",
            "text": "#  SIT.Inversion.Param  \u2014  Type .  Inversion Parameters, i.e., factors that  are fixed throughout the inversion  Fields   mgrid::Grid.M2D  : modelling grid  igrid::Grid.M2D  : inversion grid  acqsrc::Acquisition.Src  : base source wavelet for modelling data  acqgeom::Acquisition.Geom  : acquisition geometry  tgrid::Grid.M1D  :  attrib_mod::Symbol  model_obs  : model used for generating observed data  model0  : background velocity model (only used during Born modeling and inversion)  parameterization  : a vector of Symbols specifying parameterization of the inversion vector  verbose  : print level  attrib  : synthetic or real   TODO: add an extra attribute for coupling functions inversion and modelling  source  #  SIT.Inversion.Param  \u2014  Method .  Constructor for  Param   model  : initial model, the reference values are used from this   \"Seismic model used to generate 'observed' synthetic data\" modm_obs::Models.Seismic  \"source wavelet used to generate 'observed' synthetic data\" acqsrc_obs::Acquisition.Src  source  #  SIT.Inversion.AdjGeom  \u2014  Method .  Modify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.  source  #  SIT.Inversion.Coupling_x!  \u2014  Method .  Convert coupling functions to x and vice versa  source  #  SIT.Inversion.Seismic_gx!  \u2014  Method .  Convert gradient vector to  Seismic  type and vice versa This will be different from the previous one, once  the parameterizations come in   gmodm::Models.Seismic  : gradient model on the modelling grid  modm::Models.Seismic  : model on the modelling grid  gmodi::Models.Seismic  : gradient model on the inversion grid  modi::Models.Seismic  : model on the inversion grid  gx::Vector{Float64}  : gradient vector  pa::Param  :   flag::Int64  :   =1  update the vector  gx  using  gmod  =-1  update gmod     source  #  SIT.Inversion.Seismic_x!  \u2014  Method .  Convert  Seismic  model to x and vice versa   modm::Models.Seismic  : seismic model on modelling grid (input zeros to not use it)  modi::Models.Seismic  : seismic model on inversion grid  x::Vector{Float64}  : inversion vector  pa::Param  : fwi parameters   flag::Int64  :    =1  converts either modm or modi to x  =-1  updates both modm and modi using x     source  #  SIT.Inversion.Seismic_xbound!  \u2014  Method .  Return bound vectors for the  Seismic  model,  depeding on paramaterization  source  #  SIT.Inversion.func_Coupling  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  SIT.Inversion.func_xfwi  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  SIT.Inversion.grad_Coupling!  \u2014  Method .  There is a bug in gradient computation  source  #  SIT.Inversion.update_buffer!  \u2014  Function .  Update the buffer, which consists of the modelled data and boundary values for adjoint calculation.  Arguments   x::Vector{Float64}  : inversion variable  last_x::Vector{Float64}  : buffer is only updated when x!=last_x, and modified such that last_x=x  pa::Param  : parameters that are constant during the inversion  modm::Models.Seismic  :   source  #  SIT.Inversion.update_buffer_zeros  \u2014  Method .  allocate buffer  source  #  SIT.Inversion.wfwi!  \u2014  Method .  Update pa.w  source  #  SIT.Inversion.wfwi_ninv  \u2014  Method .  Return the number of inversion variables  Param  source  #  SIT.Inversion.xfwi!  \u2014  Method .  FWI using Optim, updates pa.modm and pa.dcal  Arguments   model:Models.Seismic  : initial model and it is updated  dobs::Data.TD=Data.TD_zeros(1,pa.dcal.tgrid,pa.acqgeom)  : input observed data   source  #  SIT.Inversion.xfwi_ninv  \u2014  Method .  Return the number of inversion variables  Param  source",
            "title": "Inversion"
        },
        {
            "location": "/#interferometry",
            "text": "#  SIT.Interferometry.TD_virtual_diff  \u2014  Method .  enhance diffractions in the  TD  Keyword Arguments  \u03bbdom::Float64=0.0  : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005)  tlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]  : maximum lag time in the output traces   source",
            "title": "Interferometry"
        },
        {
            "location": "/#independent-component-analysis-for-convolutive-mixtures",
            "text": "#  SIT.CICA.bica  \u2014  Method .  Performs ICA for convolutive mixtures.  Arguments   magic_recv : a receiver index, where deblending is performed  recv_n : total number of receivers  src_n : total number of sources  grid :  M1D  grid  nband : number of frequency bins, where ICA is performed  nsubfac : overlap factor (testing)  X : blended data   Output   Y : deblended data at  magic_recv   source  #  SIT.CICA.exact_freq_mixing  \u2014  Method .  Convolutive mixing in the frequency domain.  Arguments   As :  Ab :  B :  S :  fgrid :   Outputs   D  d  Ds  ds  Db  db   source",
            "title": "Independent Component Analysis for Convolutive Mixtures"
        },
        {
            "location": "/#plots",
            "text": "#  SIT.Plots.printfig  \u2014  Method .  save current fig using matlab2tikz  source  #  SIT.Plots.Geom  \u2014  Method .  Plot acquisition geometry  Acquisition.Geom  on  and model grid  M2D .  attrib::Symbol=:unique  : default; plots unique source and receiver positions   source  #  SIT.Plots.Seismic  \u2014  Method .  Plot seismic model  Arguments   model::Models.Seismic  =   Keyword Arguments   xlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]  :  zlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]  :   source  #  SIT.Plots.Src  \u2014  Method .  Plot acqsrc  source  #  SIT.Plots.TD  \u2014  Method .  Plot time-domain data of type  Data.TD  Arguments   td::Data.TD  :   Keyword Arguments   ssvec::Vector{Int64}=[1]  : supersource vector to be plotted  fieldvec::Vector{Int64}=[1]  : field vector to be plotted  tr_flag::Bool=false  : plot time-reversed data when true  attrib::Symbol=:wav  : specify type of plot   source  %## Another Section % @contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %  %  % @contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %",
            "title": "Plots"
        },
        {
            "location": "/#index",
            "text": "SIT.Acquisition.Geom  SIT.Acquisition.Src  SIT.Coupling.TD  SIT.Data.TD  SIT.Grid.M1D  SIT.Grid.M1D  SIT.Grid.M2D  SIT.Inversion.Param  SIT.Inversion.Param  SIT.Models.Seismic  SIT.Acquisition.Geom_boundary  SIT.Acquisition.Geom_circ  SIT.Acquisition.Geom_find  SIT.Acquisition.Geom_fixed  SIT.Acquisition.Geom_get  SIT.Acquisition.Geom_getvec  SIT.Acquisition.Src_fixed  SIT.Acquisition.Src_getvec  SIT.Acquisition.Src_tr  SIT.Acquisition.Src_uspos  SIT.CICA.bica  SIT.CICA.exact_freq_mixing  SIT.Coupling.TD_delta  SIT.Data.TD_dot  SIT.Data.TD_iszero  SIT.Data.TD_normalize  SIT.Data.TD_resamp  SIT.Data.TD_tr!  SIT.Data.TD_urpos  SIT.Data.TD_zeros  SIT.Data.TDcoup!  SIT.Fdtd.get_rhovxI  SIT.Fdtd.get_rhovzI  SIT.Fdtd.mod!  SIT.Fdtd.pml_variables  SIT.Gallery.Geom  SIT.Gallery.Geom  SIT.Gallery.M1D  SIT.Gallery.M2D  SIT.Gallery.Seismic  SIT.Gallery.Src  SIT.Grid.M1D_isequal  SIT.Grid.M1D_lag  SIT.Grid.M1D_npow2  SIT.Grid.M1D_npow2_tf  SIT.Grid.M1D_resamp  SIT.Grid.M1D_truncate  SIT.Grid.M2D_boundary  SIT.Grid.M2D_isequal  SIT.Grid.M2D_pad_trun  SIT.Grid.M2D_resamp  SIT.Interferometry.TD_virtual_diff  SIT.Interpolation.indminn  SIT.Interpolation.interp_B1_1D  SIT.Interpolation.interp_B2_1D  SIT.Inversion.AdjGeom  SIT.Inversion.Coupling_x!  SIT.Inversion.Seismic_gx!  SIT.Inversion.Seismic_x!  SIT.Inversion.Seismic_xbound!  SIT.Inversion.func_Coupling  SIT.Inversion.func_xfwi  SIT.Inversion.grad_Coupling!  SIT.Inversion.update_buffer!  SIT.Inversion.update_buffer_zeros  SIT.Inversion.wfwi!  SIT.Inversion.wfwi_ninv  SIT.Inversion.xfwi!  SIT.Inversion.xfwi_ninv  SIT.Misfits.TD  SIT.Misfits.error_after_scaling  SIT.Models.Seismic_addon!  SIT.Models.Seismic_chainrule!  SIT.Models.Seismic_get  SIT.Models.Seismic_interp_spray!  SIT.Models.Seismic_isequal  SIT.Models.Seismic_issimilar  SIT.Models.Seismic_issimilar  SIT.Models.Seismic_pad_trun  SIT.Models.Seismic_reparameterize!  SIT.Models.Seismic_zeros  SIT.Models.pad_trun  SIT.Models.\u03c7  SIT.Models.\u03c7g  SIT.Plots.Geom  SIT.Plots.Seismic  SIT.Plots.Src  SIT.Plots.TD  SIT.Plots.printfig  SIT.Wavelets.ormsby  SIT.Wavelets.ricker",
            "title": "Index"
        },
        {
            "location": "/tutorials/page1/",
            "text": "FFF FF",
            "title": "Title 1"
        },
        {
            "location": "/modeling/page1/",
            "text": "ff",
            "title": "Title 1"
        }
    ]
}