{
    "docs": [
        {
            "location": "/home/",
            "text": "SeismicInversionToolbox\n\n\nThe main tasks of this software are:\n\n\n\n\nForward problem, where the seismic data are generated\n\n\n\n\nusing synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.\n\n\n\n\nCan perform inversion of synthetic scenarios.\n\n\n\n\nFirst, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.\n\n\n\n\nRead\n\n\n\n\nthe measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.\n\n\n\n\nCoding Conventions\n\n\n\n\nThis software is organised into various modules.\n\n\n\n\nEach module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation \n\n\n\n\nInstallation\n\n\n\n\nInput and Output Data Format\n\n\nIt is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format. \n\n\n\n\nDemos\n\n\nDemos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Home"
        },
        {
            "location": "/home/#seismicinversiontoolbox",
            "text": "The main tasks of this software are:   Forward problem, where the seismic data are generated   using synthetic Earth models and the acquisition parameters  corresponding to a seismic experiment. Forward modeling consists of a finite-difference simulation, followed by convolutions in the time domain using the source and receiver filters. The details about our finite-difference  scheme are given in XXX.  And the filters corresponding to  sources and receivers are described in XXX.   Can perform inversion of synthetic scenarios.   First, the seismic data are modeled as in the forward problem. Then the  data are used to perform full waveform inversion (FWI). The inverse  problem estimates the Earth models and the source and receiver filters  that resulted from the data. This task is necessary to test the performance of the inversion algorithm  in various geological scenarios using different acquisition parameters.   Read   the measured seismic field data and parameters from a seismic experiment  to perform inversion like in the previous task.  The data measured in the field are not in a suitable format  yet for this software.  Pre-processing is necessary before it can be used as described. Also, the acquisition parameters from the field should be  converted to suitable 2-D coordinates as described.",
            "title": "SeismicInversionToolbox"
        },
        {
            "location": "/home/#coding-conventions",
            "text": "This software is organised into various modules.   Each module has various type definitions and methods declared. Commenting is  done inside each module file to describe the purpose of the module and its usage. Most of the comments in the code are inline with the text in this documentation.  Within each module, variable naming is done  to reduce the effort needed to understand the source code. For example,  \\code{distance = velocity * time} is prefered over using  \\code{a = b * c} in most parts of the software. The code inside each method is properly intended using spaces to facilitate  redability. We followed this documentation",
            "title": "Coding Conventions"
        },
        {
            "location": "/home/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/home/#input-and-output-data-format",
            "text": "It is recomended that the  input seismic data is  in the Seismic Unix (SU) format. The SU file should contain all the necessary headers  related to acquisition geometry that will be discussed in Section~\\ref{sec:acq_geom}. Most of the seismic data pre-processing softwares  generate a SEGY file with headers.  We can use the following command to  convert an example SEGY file, \\fname{exp.sgy}, to SU format.",
            "title": "Input and Output Data Format"
        },
        {
            "location": "/home/#demos",
            "text": "Demos preforming some of the tasks are provided along with the software in \\fname{workdir/xfwi/demos/}. An example parameter file is also provided in Section~\\ref{sec:para_file} of this manual.",
            "title": "Demos"
        },
        {
            "location": "/",
            "text": "There are various modules in this toolbox. Most of the times, each module has  a type variable definition and methods  that either modify the type variable or construct them.\n\n\n\n\nGrid\n\n\n#\n\n\nSIT.Grid.M1D\n \u2014 \nType\n.\n\n\nData type to represent 1D grid.\n\n\nFields\n\n\n\n\nx\n : values\n\n\nnx\n : number of samples\n\n\n\u03b4x\n : sampling interval\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D\n \u2014 \nMethod\n.\n\n\nConstruct 1-D grid based on sampling interval.\n\n\nArguments\n\n\n\n\nxbeg::Float64\n : first value\n\n\nxend::Float64\n : last value\n\n\n\u03b4x::Float64\n : number of samples\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D\n \u2014 \nMethod\n.\n\n\nConstruct 1-D grid based on number of samples.\n\n\nArguments\n\n\n\n\nxbeg::Float64\n : first value\n\n\nxend::Float64\n : last value\n\n\nnx::Int64\n : number of samples\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D\n \u2014 \nType\n.\n\n\nData type to represent 2D grid.\n\n\nFields\n\n\n\n\nx\n : horizontal values\n\n\nz\n : vertical values\n\n\nnx\n : number of samples in horizontal direction\n\n\nnz\n : number of samples in vertical direction\n\n\n\u03b4x\n : sampling interval in horizontal direction\n\n\n\u03b4z\n : sampling interval in vertical direction\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nM1D\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_lag\n \u2014 \nMethod\n.\n\n\nGrid with both positive and negative samples for a given lag. Make sure that the number so samples is odd\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_npow2\n \u2014 \nMethod\n.\n\n\noutput an npow2grid of either time or frequency\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_npow2_tf\n \u2014 \nMethod\n.\n\n\nconvertion between time and frequency npow2 grids\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_resamp\n \u2014 \nMethod\n.\n\n\n1-D grid with a different sampling interval\n\n\n\n\nNot yet implemented for npow2 grids\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M1D_truncate\n \u2014 \nMethod\n.\n\n\n1-D grid which is has a different size\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_boundary\n \u2014 \nMethod\n.\n\n\nReturn the X and Z positions of the boundary of mgrid attrib \n :inner \n :outer ** onlycount\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nM2D\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_pad_trun\n \u2014 \nMethod\n.\n\n\nExtend M2D by its npml grid points on all sides\n\n\nsource\n\n\n#\n\n\nSIT.Grid.M2D_resamp\n \u2014 \nMethod\n.\n\n\n2-D grid with a different sampling interval\n\n\nsource\n\n\n\n\nWavelets\n\n\n#\n\n\nSIT.Wavelets.ormsby\n \u2014 \nMethod\n.\n\n\normbsy wavelet\n\n\nsource\n\n\n#\n\n\nSIT.Wavelets.ricker\n \u2014 \nMethod\n.\n\n\nGenerate a Ricker Wavelet. Reference: Frequencies of the Ricker wavelet, Yanghua Wang, GEOPHYSICS, VOL. 80, NO. 2\n\n\nKeyword Arguments\n\n\n\n\nfqdom::Float64\n: dominant frequency\n\n\ntgrid::Grid.M1D\n: time-domain grid\n\n\ntpeak::Float64=tgrid.x[1]+1.5/fqdom\n: the peak of the ricker in time (has a default)\n\n\n\n\nsource\n\n\n\n\nCoupling\n\n\n#\n\n\nSIT.Coupling\n \u2014 \nModule\n.\n\n\nThe data recorded at the receiver during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response as explained in the Section~ ef{sec:sdata}. The source filter, srcf, takes into account  the effective wavelet present in the data.  Similarly, the receiver filter,  ecf, takes the receiver coupling into account. \u000fwi can estimate both srcf and  ecf during the inversion. The base source wavelet, sfo, is always used to model the data  before applying the convolutional filters.  \u000fwi considers the source filter  only if the input to kword{WTD} contains  kwordi{[SRCF]}, as explained in Sub-section~ ef{subsec:tasks}. Similarly, for the receiver filter, kword{WTD} should contain kwordi{[RECF]}. subsection{Keywords} The keywords to input paramters related  to the source and receiver filters contain kword{[SF]} and are explained below. If the input is kwordi{0}, then the filter is a spike at    im=0, with unknown amplitude.   Which means, the filter only applies a scalar to the modelled data.\n\n\nsource\n\n\n#\n\n\nSIT.Coupling.TD_delta\n \u2014 \nMethod\n.\n\n\nReturn delta functions\n\n\nsource\n\n\n\n\nAcquisition\n\n\n#\n\n\nSIT.Acquisition\n \u2014 \nModule\n.\n\n\nThis module defines the following data types:\n\n\n\n\nGeom\n : acquisition geometry, i.e., positions of supersources, sources and receivers\n\n\nSrc\n : source related acquisition parameters, e.g., source wavelet\n\n\n\n\nIt also provides methods that either does operations on these data type or  help their construction.\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom\n \u2014 \nType\n.\n\n\nAcquisiton has supersources, sources and receivers. Each supersource has \nns\n multiple sources that are  injected (or active) simultaneously. For each supersource, a set of \nnr\n receivers are  recording waves.\n\n\nFields\n\n\n\n\nsx::Vector{Vector{Float64,1},1}\n : $x$ positions of sources\n\n\nsz::Vector{Vector{Float64,1},1}\n : $z$ positions of sources\n\n\nrx::Vector{Vector{Float64,1},1}\n : $x$ positions of receivers\n\n\nrz::Vector{Vector{Float64,1},1}\n : $z$ positions of receivers\n\n\nnss::Int64\n : number of supersources\n\n\nns::Vector{Int64,1}\n : number of sources for every supersource\n\n\nnr::Vector{Int64,1}\n : number of receivers for every supersource\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src\n \u2014 \nType\n.\n\n\nData type for the source related parameters during acquisiton.\n\n\nFields\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Array{Int64}\n : number of sources for each supersource\n\n\nnfield::Int64\n : number of fields\n\n\nwav::Array{Float64}\n : wavelets in time domain\n\n\ntgrid::Grid.M1D\n : time grid\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAdds input positions as either sources or receivers of every supershot.\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_add!\n \u2014 \nMethod\n.\n\n\nAppends the input a vector of acquisition geometries.\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_advance\n \u2014 \nFunction\n.\n\n\nAdvance either source or receiver array in an acquisition geometry in horizontal or vertical directions.\n\n\nArguments\n\n\n\n\ngeom::Geom\n : acquisition geometry that is updated\n\n\nadvances::Vector{Float64}=[[0.,0.], [0.,0.,]]\n : source and receiver advancements\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_boundary\n \u2014 \nMethod\n.\n\n\nModify input \nGeom\n such that the output \nGeom\n has either sources or receivers on the boundary of  \nmgrid\n.\n\n\nArguments\n\n\n\n\nacqgeom::Geom\n : input geometry\n\n\nmgrid::Grid.M2D\n : grid to determine the boundary\n\n\n\n\nattrib::Symbol\n : decide return\n\n\n\n\n=:srcborder\n sources on boundary (useful for back propagation)\n\n\n=:recborder\n receivers on boundary\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_circ\n \u2014 \nMethod\n.\n\n\nCircular acquisition. The sources and receivers can also be placed on a circle of radius \nrad\n. The origin of the circle is at \nloc\n.  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by \n\u03b8lim\n\n\nArguments\n\n\n\n\nnss::Int64=10\n : number of supersources\n\n\nnr::Int64=10\n : number receivers for each super source\n\n\nloc::Vector{Float64}=[0.,0.]\n : location of origin\n\n\nrad::Float64=100.\n : radius\n\n\n\u03b8lim::Vector{Float64}=[0.,2*pi]\n : range of angular offset between source and receiver\n\n\n\n\nReturn\n\n\n\n\na circular acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_find\n \u2014 \nMethod\n.\n\n\nGiven receiver positions \nrpos\n and \nrpos0\n. Returns an array Int indices of the dimension of number of supersources with \ntrue\n at indices, if the waves due to that particular source are  recorded.\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_fixed\n \u2014 \nFunction\n.\n\n\nA fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.\n\n\nArguments\n\n\n\n\nsmin::Float64\n : minimum coordinate for sources\n\n\nsmax::Float64\n : maximum coordinate for sources\n\n\ns0::Float64\n : consant coordinate for sources\n\n\nrmin::Float64\n : minimum coordinate for receivers\n\n\nrmax::Float64\n : maximum coordinate for receivers\n\n\nr0::Float64\n : consant coordinate for receivers\n\n\nnss::Int64\n : number of supersources\n\n\nnr::Int64\n : number of receivers\n\n\nsattrib::Symbol=:horizontal\n : supersource array kind \n=:vertical\n : vertical array of supersources \n=:horizontal\n horizontal array of supersources\n\n\nrattrib::Symbol=:horizontal\n : receiver array kind \n=:vertical\n : vertical array of receivers \n=:horizontal\n horizontal array of receivers\n\n\nrand_flags::Vector{Bool}=[false, false]\n : decide placement of supersources and receivers  \n=[true, false]\n : randomly place supersources for regularly spaced receivers \n=[true, true]\n : randomly place supersources and receivers \n=[false, false]\n : regularly spaced supersources and receivers \n=[false, true]\n : randomly place receivers for regularly spaced supersources\n\n\n\n\nReturn\n\n\n\n\na fixed spread acquisition geometry \nGeom\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_get\n \u2014 \nMethod\n.\n\n\nReturn some derived fields of \nGeom\n\n\nArguments\n\n\n\n\nacq::Vector{Geom}\n : a vector of \nGeom\n\n\n\n\nattrib::Symbol\n : attribute to determine the return object \n\n\n\n\n=:nus\n number of unique source positions in acquisition\n\n\n=:nur\n number of unique receiver positions in acquisition\n\n\n=:uspos\n a tuple of x and z positions of all the unique sources\n\n\n=:urpos\n a tuple of x and z position of all the unique receivers\n\n\n=:geomurpos\n a \nGeom\n vector as if all the unique receiver positions are used for each supersource\n\n\n=:geomuspos\n a \nGeom\n vector as if all the unique source positions are used for each supersource\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Geom_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_fixed\n \u2014 \nMethod\n.\n\n\nConstructor for \nSrc\n data type. Uses same source wavelet, i.e., \nwav\n for all sources and supersources\n\n\nArguments\n\n\n\n\nnss::Int64\n : number of supersources\n\n\nns::Int64\n : number of sources\n\n\nnfield::Int64\n : number of fields the sources are exciting\n\n\nwav::Array{Float64}\n : a source wavelet that is used for all sources and supersources\n\n\ntgrid::Grid.M1D\n : time grid for the wavelet\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_fixed_mod\n \u2014 \nFunction\n.\n\n\nConstructor of \nSrc\n, which is typical for a input model such that  the model has \nnwav\n wavelengths.\n\n\n\n\nnwav::Int64=10\n : number of wavelenghts in the model\n\n\n\n\nnwav\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_getvec\n \u2014 \nMethod\n.\n\n\nreturn a vector of the order \n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_tr\n \u2014 \nMethod\n.\n\n\nFunction that returns Src after time reversal\n\n\nsource\n\n\n#\n\n\nSIT.Acquisition.Src_uspos\n \u2014 \nMethod\n.\n\n\nPad \nSrc\n  tgrids should be same in all Src\n\n\nsource\n\n\n\n\nInterpolation\n\n\n#\n\n\nSIT.Interpolation.get_interpolate_weights!\n \u2014 \nMethod\n.\n\n\nget interpolation weights\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.get_spray_weights!\n \u2014 \nMethod\n.\n\n\nget source spray weights\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.indminn\n \u2014 \nMethod\n.\n\n\nTODO:\n\n\n\n\nadd dimension checks to interp_spray!\n\n\n\n\nReference: https://www.ibiblio.org/e-notes/Splines/bezier.html\n\n\nReturn n indices in order Cannot find a julia method which does, this. If a faster method is found, replace it later.\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.interp_B1_1D\n \u2014 \nMethod\n.\n\n\nthis subroutine interpolates or sprays bilinearly [one is adjoint of another] interpolation returns y using y1, y2 spraying returns y1, y2 using y\n\n\n                    +                      \n                    |                      \ny1= f(x1)           |      y2= f(x2)   \n  +-----------------x--------+             \n             y=f(x) |                      \n                    +\n\n\n\n\n\nbilinear interpolation Reference: http://www.ajdesigner.com/phpinterpolation/bilinear_interpolation_equation.php\n\n\nsource\n\n\n#\n\n\nSIT.Interpolation.interp_B2_1D\n \u2014 \nMethod\n.\n\n\nthis subroutine interpolates or sprays  using cubic bspline interpolation returns y using y1, y2, y3, y4 spraying returns y1, y2, y3, y4 using y\n\n\n                   +                      \n                   |\n\n\n\n\n\ny1      y2          |    y3       y4      +\u2013\u2013\u2013-+\u2013\u2013\u2013\u2013-x\u2013\u2013+\u2013\u2013\u2013\u2013+                              y=f(x) |                                              +                      \n\n\nsource\n\n\n\n\nModels\n\n\n#\n\n\nSIT.Models.Seismic\n \u2014 \nType\n.\n\n\nData type fo represent a seismic model.\n\n\nFields\n\n\n\n\nvp0::Vector{Float64}\n : [vpmin, vpmax]\n\n\nvs0::Vector{Float64}\n : [vsmin, vsmax]\n\n\n\u03c10::Vector{Float64}\n : [\u03c1min, \u03c1max]\n\n\n\u03c7vp::Array{Float64}\n :\n\n\n\u03c7vs::Array{Float64}\n :\n\n\n\u03c7\u03c1::Array{Float64}\n :\n\n\nmgrid::Grid.M2D\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_addon!\n \u2014 \nMethod\n.\n\n\nAdd features to a model.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model that is modified\n\n\n\n\nKeyword Arguments\n\n\n\n\ncirc_loc::Vector{Float64}=nothing\n : location of center of perturbation\n\n\ncirc_rad::Float64=0.0\n : radius of circular perturbation\n\n\ncirc_pert::Float64=0.1\n : perturbation inside a circle\n\n\nrect_loc::Array{Float64}=nothing\n : rectangle location\n\n\nrect_pert::Float64=0.1\n : perturbation in a rectangle\n\n\nrandn_pert::Float64=0.0\n : percentage of reference values for additive random noise\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_chainrule!\n \u2014 \nFunction\n.\n\n\nUse chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.\n\n\nArguments\n\n\n\n\ngmod::Seismic\n : gradient model\n\n\nmod::Seismic\n : model required for chain rule\n\n\ng1\n : gradient of an objective function with respect \nattribs[1]\n\n\ng2\n : gradient of an objective function with respect \nattribs[2]\n\n\nattribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]\n :\n\n\n\n\nflag::Int64=1\n :\n\n\n\n\n=1\n updates \ngmod\n using \ng1\n and \ng2\n\n\n=-1\n updates \ng1\n and \ng2\n using \ngmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_get\n \u2014 \nMethod\n.\n\n\nGet other dependent model parameters of a seismic model that are not present in \nSeismic\n.\n\n\n\n\n:\u03c1I\n : inverse of density\n\n\n:Zp\n : P-wave impedance\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_interp_spray!\n \u2014 \nMethod\n.\n\n\nfunction to resample in the model domain\n\n\nArguments\n\n\n\n\nmod::Seismic\n : model\n\n\nmodi::Seismic\n : model after interpolation\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_isequal\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_issimilar\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_issimilar\n \u2014 \nMethod\n.\n\n\nLogical operation for \nSeismic\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_pad_trun\n \u2014 \nMethod\n.\n\n\nExtend a seismic model into PML layers\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_reparameterize!\n \u2014 \nFunction\n.\n\n\nRe-parameterization routine  that modifies the fields  \n\u03c7vp\n and \n\u03c7\u03c1\n of an input seismic model using two input vectors.\n\n\nArguments\n\n\n\n\nmod::Seismic\n : to be updated\n\n\nx1::Array{Float64,2}\n : contrast of inverse bulk modulus\n\n\nx2::Array{Float64,2}\n : contrast of inverse density\n\n\nattribs:::Vector{Symbol}\n : [:\u03c7KI, :\u03c7\u03c1I]\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_smooth!\n \u2014 \nFunction\n.\n\n\nApply smoothing to \nSeismic\n using a Gaussian filter of zwidth and xwidth\n\n\nsource\n\n\n#\n\n\nSIT.Models.Seismic_zeros\n \u2014 \nMethod\n.\n\n\nReturn \nSeismic\n with zeros everywhere; this method is used for preallocation.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : used for sizes of \u03c7 fields\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.pad_trun\n \u2014 \nFunction\n.\n\n\nExtend a model on all four sides\n\n\nsource\n\n\n#\n\n\nSIT.Models.\u03c7\n \u2014 \nFunction\n.\n\n\nReturn dimensionless contrast model parameter using the reference value.\n\n\nArguments\n\n\n\n\nmod::Array{Float64}\n : subsurface parameter\n\n\nmod0::Vector{Float64}\n : reference value is mean of this vector\n\n\nflag::Int64=1\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Models.\u03c7g\n \u2014 \nFunction\n.\n\n\nGradients Return contrast model parameter using the reference value.\n\n\nsource\n\n\n\n\nData\n\n\n#\n\n\nSIT.Data\n \u2014 \nModule\n.\n\n\nThis module defines the data types related to seismic data:\n\n\n\n\nTD\n : time domain representation\n\n\n\n\nIt also provides methods that apply source and receiver filters onto  seismic data.\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD\n \u2014 \nType\n.\n\n\nTime domain representation of Seismic Data.\n\n\nFields\n\n\n\n\nd::Array{Array{Float64,2},2}\n : data\n\n\nnfield::Int64\n : number of components recorded at each receiver\n\n\ntgrid::Grid.M1D\n : grid to represent time\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry used to generate the data\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_dot\n \u2014 \nMethod\n.\n\n\nReturns dot product of data.\n\n\nArguments\n\n\n\n\ndata1::TD\n : data 1\n\n\ndata2::TD\n : data 2\n\n\n\n\nReturn\n\n\n\n\ndot product as \nFloat64\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_iszero\n \u2014 \nMethod\n.\n\n\nReturns bool depending on if input \ndata::TD\n has all zeros or not.\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_normalize\n \u2014 \nMethod\n.\n\n\nNormalize time-domain seismic data.\n\n\nArguments\n\n\n\n\ndata::TD\n : input data\n\n\n\n\nattrib::Symbol\n : decide kind of normalization\n\n\n\n\n=:recrms\n the record at every receiver is normalized with its RMS value\n\n\n=:recmax\n the record at every receiver is normalized with its maximum value\n\n\n\n\n\n\n\n\nReturn\n\n\n\n\nnormalized data as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_resamp!\n \u2014 \nMethod\n.\n\n\nMethod to resample data in time.\n\n\nArguments\n\n\n\n\ndata::TD\n : input data of type \nTD\n\n\ndataout::TD\n : preallocated data of type \nTD\n that is modified\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_resamp\n \u2014 \nMethod\n.\n\n\nMethod to resample data in time.\n\n\nArguments\n\n\n\n\ndata::TD\n : input data of type \nTD\n\n\ntgrid::Grid.M1D\n : resampling in time according to this time grid\n\n\n\n\nReturn\n\n\n\n\ndata after resampling as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_tr!\n \u2014 \nMethod\n.\n\n\nTime reverse the records of each receiver in \nTD\n \n\n\nArguments\n\n\n\n\ndata::TD\n : input data that is modified\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_urpos\n \u2014 \nMethod\n.\n\n\nConstruct TD using data at all the unique receiver positions for all supersources.\n\n\nsource\n\n\n#\n\n\nSIT.Data.TD_zeros\n \u2014 \nMethod\n.\n\n\nMethod used to preallocate \nTD\n with zeros.\n\n\nArguments\n\n\n\n\nnfield::Int64\n : number of components\n\n\ntgrid::Grid.M1D\n : time domain grid\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\n\n\nReturn\n\n\n\n\ndata with zeros as \nTD\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Data.TDcoup!\n \u2014 \nMethod\n.\n\n\nApply source and receiver coupling functions to TD. Currently, only source filters are applied.\n\n\nArguments\n\n\n\n\ns::TD\n : input data\n\n\nr::TD\n : input data\n\n\nw::Coupling.TD\n : input source and receiver filters\n\n\n\n\nattrib::Symbol\n : attribute to \n\n\n\n\n=:s\n to apply \nw\n to \nr\n and modify \ns\n\n\n=:r\n to apply adjoint of \nw\n to \ns\n and modify \nr\n\n\n=:w\n modify \nw\n using \nr\n and \ns\n\n\n\n\n\n\n\n\nsource\n\n\n\n\nMisfits\n\n\n#\n\n\nSIT.Misfits.TD\n \u2014 \nMethod\n.\n\n\nInput the obeserved and modelled data to output the misfit and the adjoint sources TODO: \n\n\nsource\n\n\n#\n\n\nSIT.Misfits.error_after_scaling\n \u2014 \nMethod\n.\n\n\nNormalized least-squares error between two vectors after  estimating a scalar that best fits on to another. Return misfit and \u03b1 such that \u03b1x-y is minimum. Normalization is done with respect to the  norm of y.\n\n\nsource\n\n\n\n\nGallery\n\n\n#\n\n\nSIT.Gallery.Geom\n \u2014 \nMethod\n.\n\n\nGallery of acquisition geometries \nGeom\n using an input mesh \nM2D\n. The sources and receivers are not placed anywhere on the edges of the mesh.\n\n\nArguments\n\n\n\n\nmgrid::Grid.M2D\n : a 2-D mesh\n\n\n\n\nattrib::Symbol\n : attribute decides output\n\n\n\n\n=:xwell\n cross-well acquisition\n\n\n=:surf\n cross-well; but sources and receivers at unequal depths\n\n\n=:vsp\n vertical seismic profiling\n\n\n=:rvsp\n  reverse vertical seismic profiling\n\n\n=:downhole\n downhole sources and receivers\n\n\nrand_flags::Vector{Bool}=[false, false]\n : randomly or equally spaced?\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.M1D\n \u2014 \nMethod\n.\n\n\nGallery of \nM1D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a time grid for with 1000 samples; maximum time is 2 s\n\n\nattrib=:acou_homo1_long\n : a time grid for with 1000 samples; maximum time is 4 s\n\n\nattrib=:npow2samp1\n : a sample npow2 grid with 16 samples\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.M2D\n \u2014 \nMethod\n.\n\n\nGallery of \nM2D\n grids.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n : a square grid for with 201 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\n\n\nattrib=:acou_homo2\n : a square grid for with 51 samples in each dimension, with 50 PML\n\n\n\n\n    points; both X and Z vary from -1000 to 1000.\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.Seismic\n \u2014 \nFunction\n.\n\n\nGallery of \nSeismic\n models.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\n\n\nOutputs\n\n\n\n\n\n\nattrib=:acou_homo1\n : an homogeneous acoustic model with \nvp0=2000\n and \n\u03c10=2000\n\n\n\n\nattrib=:acou_homo2\n : same as above, but with spatial sampling as 40 m (faster testing)\n\n\nattrib=:seismic_marmousi2\n : marmousi model with lower resolution; ideal for surface seismic experiments\n\n\nattrib=:seismic_marmousi2_high_res\n : marmousi model high resolution; slower to load\n\n\nattrib=:seismic_marmousi2_box1\n : 1x1 kilometer box of marmousi model; ideal for crosswell, borehole seismic studies\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Gallery.Src\n \u2014 \nFunction\n.\n\n\nGallery of source signals \nSrc\n.\n\n\nArguments\n\n\n\n\nattrib::Symbol\n :\n\n\nnss::Int64=1\n : number of supersources\n\n\n\n\nOutputs\n\n\n\n\nattrib=:acou_homo1\n :\n\n\n\n\nsource\n\n\n\n\nFdtd\n\n\n#\n\n\nSIT.Fdtd.compute_illum!\n \u2014 \nMethod\n.\n\n\nNeed illumination to estimate the approximate diagonal of Hessian\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.get_rhovxI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.get_rhovzI\n \u2014 \nMethod\n.\n\n\nProject density on to a staggerred grid using simple interpolation\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.mod!\n \u2014 \nMethod\n.\n\n\nAs forward modeling method, the  finite-difference method is employed.  It uses a discrete version of the two-dimensional isotropic acoustic wave equation. As shown in  \n\n\n$$\npp[ zero] - pp[ mo] = dt mB left({partial_x\u000bx}[ mh]\n + partial_z \u000bz[    mh]  + dtsum_{0}^{  mo}sfo\night)\n \nmath\npp[ po] - pp[   zero] = dt mB left(partial_x \u000bx[    ph]\n + {partial_z \u000bz}[  ph]  + dtsum_{0}^{  zero}sfo\night)\n ```\n\n\nFigure~ef{fdshmesh_acou}, a staggered-grid mesh is used \n\n\nKeyword Arguments\n\n\n\n\nnpropwav::Int64=1\n : number of independently propagating wavefields in \nmodel\n\n\nmodel::Models.Seismic\n : seismic medium parameters \n\n\nmodel_pert::Models.Seismic\n : perturbed model, i.e., model + \u03b4model, used for Born modeling \n\n\ntgridmod::Grid.M1D\n : modelling time vector\n\n\ntgrid::Grid.M1D\n : output records are interpolated on this time vector\n\n\nrecv_nfield::Int64=1\n : number of fields that receivers record \n\n\nbackprop_flag::Bool=Int64\n : save final state variables and the boundary conditions for later use\n\n\nboundary_in::Any=[0]\n : input final state variables and boundary\n\n\nabs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]\n : PML boundary conditions \n\n\nborn_flag::Bool=false\n : Born modeling flag\n\n\ngmodel_flag=false\n : output gradient or not\n\n\nillum_flag::Bool=false\n : output wavefield energy or source illumination to use as preconditioner later\n\n\nillum_out::Array{Float64}\n : source energy with same dimensions as model.mgrid\n\n\nverbose::Bool=false\n : verbose flag\n\n\n\n\nExample\n\n\n$$\n\n\njulia julia> records,   = mod(); ``` Credits: Pawan Bharadwaj, 2017\n\n\nsource\n\n\n#\n\n\nSIT.Fdtd.pml_variables\n \u2014 \nMethod\n.\n\n\nOutput vectors related to PML boundaries.\n\n\nsource\n\n\n\n\nInversion\n\n\n#\n\n\nSIT.Inversion.Param\n \u2014 \nType\n.\n\n\nInversion Parameters, i.e., factors that  are fixed throughout the inversion\n\n\nFields\n\n\n\n\nmgrid::Grid.M2D\n : modelling grid\n\n\nigrid::Grid.M2D\n : inversion grid\n\n\nacqsrc::Acquisition.Src\n : base source wavelet for modelling data\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\ntgrid::Grid.M1D\n :\n\n\nattrib_mod::Symbol\n\n\nmodel_obs\n : model used for generating observed data\n\n\nmodel0\n : background velocity model (only used during Born modeling and inversion)\n\n\nparameterization\n : a vector of Symbols specifying parameterization of the inversion vector\n\n\nverbose\n : print level on STOUT\n\n\nattrib\n : synthetic or real\n\n\n\n\nTODO: add an extra attribute for coupling functions inversion and modelling\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Param\n \u2014 \nMethod\n.\n\n\nConstructor for \nParam\n\n\nArguments\n\n\n\n\nacqsrc::Acquisition.Src\n : source time functions\n\n\nacqgeom::Acquisition.Geom\n : acquisition geometry\n\n\ntgrid::Grid.M1D\n : modelling time grid\n\n\nattrib_mod::Symbol\n : modelling attribute\n\n\nattrib_inv::Symbol\n : inversion attribute\n\n\nmodm::Models.Seismic\n : seismic model on modelling mesh\n\n\n\n\nOptional Arguments\n\n\n\n\nigrid::Grid.M2D=modm.mgrid\n : inversion grid if different from the modelling grid, i.e., \nmodm.mgrid\n\n\nmprecon_flag::Bool=false\n : flag to use a model preconditioner\n\n\ndobs::Data.TD\n : observed data\n\n\ntlagssf::Float64=0.0\n : maximum lagtime of unknown source filter\n\n\ntlagrf::Float64=0.0\n : maximum lagtime of unknown receiver filter\n\n\nacqsrc_obs::Acquisition.Src=acqsrc\n : source wavelets to generate \nobserved data\n; can be different from \nacqsrc\n\n\nmodm_obs::Models.Seismic=modm\n : actual seismic model to generate \nobserved data\n\n\nmodm0::Models.Seismic=modm\n : background seismic model for Born modelling and inversion (still being tested)\n\n\nmod_inv_parameterization::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]\n : subsurface parameterization\n\n\nverbose::Bool=false\n : print level on STDOUT during inversion\n\n\n\n\nattrib::Symbol=:synthetic\n : an attribute to control class\n\n\n\n\n=:synthetic\n synthetic data inversion\n\n\n=:field\n field data inversion\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.AdjGeom\n \u2014 \nMethod\n.\n\n\nModify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Coupling_x!\n \u2014 \nMethod\n.\n\n\nConvert coupling functions to x and vice versa\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_gx!\n \u2014 \nMethod\n.\n\n\nConvert gradient vector to \nSeismic\n type and vice versa This will be different from the previous one, once  the parameterizations come in\n\n\n\n\ngmodm::Models.Seismic\n : gradient model on the modelling grid\n\n\nmodm::Models.Seismic\n : model on the modelling grid\n\n\ngmodi::Models.Seismic\n : gradient model on the inversion grid\n\n\nmodi::Models.Seismic\n : model on the inversion grid\n\n\ngx::Vector{Float64}\n : gradient vector\n\n\npa::Param\n :\n\n\n\n\nflag::Int64\n :\n\n\n\n\n=1\n update the vector \ngx\n using \ngmod\n\n\n=-1\n update gmod\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_x!\n \u2014 \nMethod\n.\n\n\nConvert \nSeismic\n model to x and vice versa\n\n\n\n\nmodm::Models.Seismic\n : seismic model on modelling grid (input zeros to not use it)\n\n\nmodi::Models.Seismic\n : seismic model on inversion grid\n\n\nx::Vector{Float64}\n : inversion vector\n\n\npa::Param\n : fwi parameters\n\n\n\n\nflag::Int64\n : \n\n\n\n\n=1\n converts either modm or modi to x\n\n\n=-1\n updates both modm and modi using x\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.Seismic_xbound!\n \u2014 \nMethod\n.\n\n\nReturn bound vectors for the \nSeismic\n model,  depeding on paramaterization\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.func_Coupling\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nSIT.Inversion.func_xfwi\n \u2014 \nMethod\n.\n\n\nReturn functional and gradient of the CLS objective \n\n\nsource\n\n\n#\n\n\nSIT.Inversion.grad_Coupling!\n \u2014 \nMethod\n.\n\n\nThere is a bug in gradient computation\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.update_buffer!\n \u2014 \nFunction\n.\n\n\nUpdate the buffer, which consists of the modelled data and boundary values for adjoint calculation.\n\n\nArguments\n\n\n\n\nx::Vector{Float64}\n : inversion variable\n\n\nlast_x::Vector{Float64}\n : buffer is only updated when x!=last_x, and modified such that last_x=x\n\n\npa::Param\n : parameters that are constant during the inversion\n\n\nmodm::Models.Seismic\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.update_buffer_zeros\n \u2014 \nMethod\n.\n\n\nallocate buffer\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.wfwi!\n \u2014 \nMethod\n.\n\n\nUpdate pa.w\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.wfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables for source and receiver filter inversion  corresponding to \nParam\n. This number depends on the maximum lagtimes of the filters. \n\n\nsource\n\n\n#\n\n\nSIT.Inversion.xfwi!\n \u2014 \nMethod\n.\n\n\nFull Waveform Inversion using \nOptim\n. This method updates \npa.modm\n and \npa.dcal\n. More details about the optional parameters can be found in the documentation of the \nOptim\n  package.\n\n\nArguments that are modified\n\n\n\n\npa::Param\n : inversion parameters\n\n\n\n\nOptional Arguments\n\n\n\n\nextended_trace::Bool=true\n : save extended trace\n\n\ntime_limit=Float64=2.0*60.\n : time limit for inversion (testing)\n\n\niterations::Int64=5\n : maximum number of iterations\n\n\nf_tol::Float64=1e-3\n : functional tolerance\n\n\ng_tol::Float64=1e-3\n : gradient tolerance\n\n\nx_tol::Float64=1e-3\n : model tolerance\n\n\n\n\nOutputs\n\n\n\n\n\n\ndepending on  \npa.attrib_inv\n\n\n\n\n=:cls\n classic least-squares inversion using adjoint state method\n\n\n=:migr\n return gradient at the first iteration, i.e., a migration image\n\n\n=:migr_finite_difference\n same as above but \nnot\n using adjoint state method; time consuming; only for testing, TODO: implement autodiff here\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Inversion.xfwi_ninv\n \u2014 \nMethod\n.\n\n\nReturn the number of inversion variables for FWI corresponding to \nParam\n. This number of inversion variables depend on the size of inversion mesh.\n\n\nsource\n\n\n\n\nInterferometry\n\n\n#\n\n\nSIT.Interferometry.TD_virtual_diff\n \u2014 \nMethod\n.\n\n\nenhance diffractions in the \nTD\n\n\nKeyword Arguments\n\n\n\u03bbdom::Float64=0.0\n : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005) \ntlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]\n : maximum lag time in the output traces \n\n\nsource\n\n\n\n\nCICA\n\n\n#\n\n\nSIT.CICA\n \u2014 \nModule\n.\n\n\nIndependent Component Analysis for Convolutive Mixtures\n\n\nsource\n\n\n#\n\n\nSIT.CICA.bica\n \u2014 \nMethod\n.\n\n\nPerforms ICA for convolutive mixtures.\n\n\nArguments\n\n\n\n\nmagic_recv\n: a receiver index, where deblending is performed\n\n\nrecv_n\n: total number of receivers\n\n\nsrc_n\n: total number of sources\n\n\ngrid\n: \nM1D\n grid\n\n\nnband\n: number of frequency bins, where ICA is performed\n\n\nnsubfac\n: overlap factor (testing)\n\n\nX\n: blended data\n\n\n\n\nOutput\n\n\n\n\nY\n: deblended data at \nmagic_recv\n\n\n\n\nsource\n\n\n#\n\n\nSIT.CICA.exact_freq_mixing\n \u2014 \nMethod\n.\n\n\nConvolutive mixing in the frequency domain.\n\n\nArguments\n\n\n\n\nAs\n:\n\n\nAb\n:\n\n\nB\n:\n\n\nS\n:\n\n\nfgrid\n:\n\n\n\n\nOutputs\n\n\n\n\nD\n\n\nd\n\n\nDs\n\n\nds\n\n\nDb\n\n\ndb\n\n\n\n\nsource\n\n\n\n\nPlots\n\n\n#\n\n\nSIT.Plots.printfig\n \u2014 \nMethod\n.\n\n\nsave current fig using matlab2tikz\n\n\nsource\n\n\n#\n\n\nSIT.Plots.Geom\n \u2014 \nMethod\n.\n\n\nPlot acquisition geometry \nAcquisition.Geom\n on  and model grid \nM2D\n.\n\n\nattrib::Symbol=:unique\n : default; plots unique source and receiver positions \n\n\nsource\n\n\n#\n\n\nSIT.Plots.Seismic\n \u2014 \nMethod\n.\n\n\nPlot seismic model\n\n\nArguments\n\n\n\n\nmodel::Models.Seismic\n =\n\n\n\n\nKeyword Arguments\n\n\n\n\nxlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]\n :\n\n\nzlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]\n :\n\n\n\n\nsource\n\n\n#\n\n\nSIT.Plots.Src\n \u2014 \nMethod\n.\n\n\nPlot acqsrc\n\n\nsource\n\n\n#\n\n\nSIT.Plots.TD\n \u2014 \nMethod\n.\n\n\nPlot time-domain data of type \nData.TD\n\n\nArguments\n\n\n\n\ntd::Data.TD\n :\n\n\n\n\nKeyword Arguments\n\n\n\n\nssvec::Vector{Int64}=[1]\n : supersource vector to be plotted\n\n\nfieldvec::Vector{Int64}=[1]\n : field vector to be plotted\n\n\ntr_flag::Bool=false\n : plot time-reversed data when true\n\n\nattrib::Symbol=:wav\n : specify type of plot\n\n\n\n\nsource\n\n\n%## Another Section %\n@contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %\n %  %\n@contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %\n\n\n\n\nIndex\n\n\n\n\nSIT.Acquisition\n\n\nSIT.CICA\n\n\nSIT.Coupling\n\n\nSIT.Data\n\n\nSIT.Acquisition.Geom\n\n\nSIT.Acquisition.Src\n\n\nSIT.Data.TD\n\n\nSIT.Grid.M1D\n\n\nSIT.Grid.M1D\n\n\nSIT.Grid.M1D\n\n\nSIT.Grid.M2D\n\n\nSIT.Inversion.Param\n\n\nSIT.Inversion.Param\n\n\nSIT.Models.Seismic\n\n\nSIT.Acquisition.Geom_add!\n\n\nSIT.Acquisition.Geom_add!\n\n\nSIT.Acquisition.Geom_advance\n\n\nSIT.Acquisition.Geom_boundary\n\n\nSIT.Acquisition.Geom_circ\n\n\nSIT.Acquisition.Geom_find\n\n\nSIT.Acquisition.Geom_fixed\n\n\nSIT.Acquisition.Geom_get\n\n\nSIT.Acquisition.Geom_getvec\n\n\nSIT.Acquisition.Src_fixed\n\n\nSIT.Acquisition.Src_fixed_mod\n\n\nSIT.Acquisition.Src_getvec\n\n\nSIT.Acquisition.Src_tr\n\n\nSIT.Acquisition.Src_uspos\n\n\nSIT.CICA.bica\n\n\nSIT.CICA.exact_freq_mixing\n\n\nSIT.Coupling.TD_delta\n\n\nSIT.Data.TD_dot\n\n\nSIT.Data.TD_iszero\n\n\nSIT.Data.TD_normalize\n\n\nSIT.Data.TD_resamp\n\n\nSIT.Data.TD_resamp!\n\n\nSIT.Data.TD_tr!\n\n\nSIT.Data.TD_urpos\n\n\nSIT.Data.TD_zeros\n\n\nSIT.Data.TDcoup!\n\n\nSIT.Fdtd.compute_illum!\n\n\nSIT.Fdtd.get_rhovxI\n\n\nSIT.Fdtd.get_rhovzI\n\n\nSIT.Fdtd.mod!\n\n\nSIT.Fdtd.pml_variables\n\n\nSIT.Gallery.Geom\n\n\nSIT.Gallery.M1D\n\n\nSIT.Gallery.M2D\n\n\nSIT.Gallery.Seismic\n\n\nSIT.Gallery.Src\n\n\nSIT.Grid.M1D_isequal\n\n\nSIT.Grid.M1D_lag\n\n\nSIT.Grid.M1D_npow2\n\n\nSIT.Grid.M1D_npow2_tf\n\n\nSIT.Grid.M1D_resamp\n\n\nSIT.Grid.M1D_truncate\n\n\nSIT.Grid.M2D_boundary\n\n\nSIT.Grid.M2D_isequal\n\n\nSIT.Grid.M2D_pad_trun\n\n\nSIT.Grid.M2D_resamp\n\n\nSIT.Interferometry.TD_virtual_diff\n\n\nSIT.Interpolation.get_interpolate_weights!\n\n\nSIT.Interpolation.get_spray_weights!\n\n\nSIT.Interpolation.indminn\n\n\nSIT.Interpolation.interp_B1_1D\n\n\nSIT.Interpolation.interp_B2_1D\n\n\nSIT.Inversion.AdjGeom\n\n\nSIT.Inversion.Coupling_x!\n\n\nSIT.Inversion.Seismic_gx!\n\n\nSIT.Inversion.Seismic_x!\n\n\nSIT.Inversion.Seismic_xbound!\n\n\nSIT.Inversion.func_Coupling\n\n\nSIT.Inversion.func_xfwi\n\n\nSIT.Inversion.grad_Coupling!\n\n\nSIT.Inversion.update_buffer!\n\n\nSIT.Inversion.update_buffer_zeros\n\n\nSIT.Inversion.wfwi!\n\n\nSIT.Inversion.wfwi_ninv\n\n\nSIT.Inversion.xfwi!\n\n\nSIT.Inversion.xfwi_ninv\n\n\nSIT.Misfits.TD\n\n\nSIT.Misfits.error_after_scaling\n\n\nSIT.Models.Seismic_addon!\n\n\nSIT.Models.Seismic_chainrule!\n\n\nSIT.Models.Seismic_get\n\n\nSIT.Models.Seismic_interp_spray!\n\n\nSIT.Models.Seismic_isequal\n\n\nSIT.Models.Seismic_issimilar\n\n\nSIT.Models.Seismic_issimilar\n\n\nSIT.Models.Seismic_pad_trun\n\n\nSIT.Models.Seismic_reparameterize!\n\n\nSIT.Models.Seismic_smooth!\n\n\nSIT.Models.Seismic_zeros\n\n\nSIT.Models.pad_trun\n\n\nSIT.Models.\u03c7\n\n\nSIT.Models.\u03c7g\n\n\nSIT.Plots.Geom\n\n\nSIT.Plots.Seismic\n\n\nSIT.Plots.Src\n\n\nSIT.Plots.TD\n\n\nSIT.Plots.printfig\n\n\nSIT.Wavelets.ormsby\n\n\nSIT.Wavelets.ricker",
            "title": "Reference"
        },
        {
            "location": "/#grid",
            "text": "#  SIT.Grid.M1D  \u2014  Type .  Data type to represent 1D grid.  Fields   x  : values  nx  : number of samples  \u03b4x  : sampling interval   source  #  SIT.Grid.M1D  \u2014  Method .  Construct 1-D grid based on sampling interval.  Arguments   xbeg::Float64  : first value  xend::Float64  : last value  \u03b4x::Float64  : number of samples   source  #  SIT.Grid.M1D  \u2014  Method .  Construct 1-D grid based on number of samples.  Arguments   xbeg::Float64  : first value  xend::Float64  : last value  nx::Int64  : number of samples   source  #  SIT.Grid.M2D  \u2014  Type .  Data type to represent 2D grid.  Fields   x  : horizontal values  z  : vertical values  nx  : number of samples in horizontal direction  nz  : number of samples in vertical direction  \u03b4x  : sampling interval in horizontal direction  \u03b4z  : sampling interval in vertical direction   source  #  SIT.Grid.M1D_isequal  \u2014  Method .  Logical operation for  M1D  source  #  SIT.Grid.M1D_lag  \u2014  Method .  Grid with both positive and negative samples for a given lag. Make sure that the number so samples is odd  source  #  SIT.Grid.M1D_npow2  \u2014  Method .  output an npow2grid of either time or frequency  source  #  SIT.Grid.M1D_npow2_tf  \u2014  Method .  convertion between time and frequency npow2 grids  source  #  SIT.Grid.M1D_resamp  \u2014  Method .  1-D grid with a different sampling interval   Not yet implemented for npow2 grids   source  #  SIT.Grid.M1D_truncate  \u2014  Method .  1-D grid which is has a different size  source  #  SIT.Grid.M2D_boundary  \u2014  Method .  Return the X and Z positions of the boundary of mgrid attrib   :inner   :outer ** onlycount  source  #  SIT.Grid.M2D_isequal  \u2014  Method .  Logical operation for  M2D  source  #  SIT.Grid.M2D_pad_trun  \u2014  Method .  Extend M2D by its npml grid points on all sides  source  #  SIT.Grid.M2D_resamp  \u2014  Method .  2-D grid with a different sampling interval  source",
            "title": "Grid"
        },
        {
            "location": "/#wavelets",
            "text": "#  SIT.Wavelets.ormsby  \u2014  Method .  ormbsy wavelet  source  #  SIT.Wavelets.ricker  \u2014  Method .  Generate a Ricker Wavelet. Reference: Frequencies of the Ricker wavelet, Yanghua Wang, GEOPHYSICS, VOL. 80, NO. 2  Keyword Arguments   fqdom::Float64 : dominant frequency  tgrid::Grid.M1D : time-domain grid  tpeak::Float64=tgrid.x[1]+1.5/fqdom : the peak of the ricker in time (has a default)   source",
            "title": "Wavelets"
        },
        {
            "location": "/#coupling",
            "text": "#  SIT.Coupling  \u2014  Module .  The data recorded at the receiver during a seismic experiment  is a convolution of the Green's function, the source signature and the receiver instrument response as explained in the Section~ ef{sec:sdata}. The source filter, srcf, takes into account  the effective wavelet present in the data.  Similarly, the receiver filter,  ecf, takes the receiver coupling into account. \u000fwi can estimate both srcf and  ecf during the inversion. The base source wavelet, sfo, is always used to model the data  before applying the convolutional filters.  \u000fwi considers the source filter  only if the input to kword{WTD} contains  kwordi{[SRCF]}, as explained in Sub-section~ ef{subsec:tasks}. Similarly, for the receiver filter, kword{WTD} should contain kwordi{[RECF]}. subsection{Keywords} The keywords to input paramters related  to the source and receiver filters contain kword{[SF]} and are explained below. If the input is kwordi{0}, then the filter is a spike at    im=0, with unknown amplitude.   Which means, the filter only applies a scalar to the modelled data.  source  #  SIT.Coupling.TD_delta  \u2014  Method .  Return delta functions  source",
            "title": "Coupling"
        },
        {
            "location": "/#acquisition",
            "text": "#  SIT.Acquisition  \u2014  Module .  This module defines the following data types:   Geom  : acquisition geometry, i.e., positions of supersources, sources and receivers  Src  : source related acquisition parameters, e.g., source wavelet   It also provides methods that either does operations on these data type or  help their construction.  source  #  SIT.Acquisition.Geom  \u2014  Type .  Acquisiton has supersources, sources and receivers. Each supersource has  ns  multiple sources that are  injected (or active) simultaneously. For each supersource, a set of  nr  receivers are  recording waves.  Fields   sx::Vector{Vector{Float64,1},1}  : $x$ positions of sources  sz::Vector{Vector{Float64,1},1}  : $z$ positions of sources  rx::Vector{Vector{Float64,1},1}  : $x$ positions of receivers  rz::Vector{Vector{Float64,1},1}  : $z$ positions of receivers  nss::Int64  : number of supersources  ns::Vector{Int64,1}  : number of sources for every supersource  nr::Vector{Int64,1}  : number of receivers for every supersource   source  #  SIT.Acquisition.Src  \u2014  Type .  Data type for the source related parameters during acquisiton.  Fields   nss::Int64  : number of supersources  ns::Array{Int64}  : number of sources for each supersource  nfield::Int64  : number of fields  wav::Array{Float64}  : wavelets in time domain  tgrid::Grid.M1D  : time grid   source  #  SIT.Acquisition.Geom_add!  \u2014  Method .  Adds input positions as either sources or receivers of every supershot.  source  #  SIT.Acquisition.Geom_add!  \u2014  Method .  Appends the input a vector of acquisition geometries.  source  #  SIT.Acquisition.Geom_advance  \u2014  Function .  Advance either source or receiver array in an acquisition geometry in horizontal or vertical directions.  Arguments   geom::Geom  : acquisition geometry that is updated  advances::Vector{Float64}=[[0.,0.], [0.,0.,]]  : source and receiver advancements   source  #  SIT.Acquisition.Geom_boundary  \u2014  Method .  Modify input  Geom  such that the output  Geom  has either sources or receivers on the boundary of   mgrid .  Arguments   acqgeom::Geom  : input geometry  mgrid::Grid.M2D  : grid to determine the boundary   attrib::Symbol  : decide return   =:srcborder  sources on boundary (useful for back propagation)  =:recborder  receivers on boundary     source  #  SIT.Acquisition.Geom_circ  \u2014  Method .  Circular acquisition. The sources and receivers can also be placed on a circle of radius  rad . The origin of the circle is at  loc .  This geometry is unrealistic, but useful for testing. Receivers are placed such that the limits  of the angular offset are given by  \u03b8lim  Arguments   nss::Int64=10  : number of supersources  nr::Int64=10  : number receivers for each super source  loc::Vector{Float64}=[0.,0.]  : location of origin  rad::Float64=100.  : radius  \u03b8lim::Vector{Float64}=[0.,2*pi]  : range of angular offset between source and receiver   Return   a circular acquisition geometry  Geom   source  #  SIT.Acquisition.Geom_find  \u2014  Method .  Given receiver positions  rpos  and  rpos0 . Returns an array Int indices of the dimension of number of supersources with  true  at indices, if the waves due to that particular source are  recorded.  source  #  SIT.Acquisition.Geom_fixed  \u2014  Function .  A fixed spread acquisition has same set of sources and  receivers for each supersource. This method constructs a  fixed spread acquisition geometry using either a horizontal or vertical array of supersources/ receivers. Current implementation has only one source for every supersource.  Arguments   smin::Float64  : minimum coordinate for sources  smax::Float64  : maximum coordinate for sources  s0::Float64  : consant coordinate for sources  rmin::Float64  : minimum coordinate for receivers  rmax::Float64  : maximum coordinate for receivers  r0::Float64  : consant coordinate for receivers  nss::Int64  : number of supersources  nr::Int64  : number of receivers  sattrib::Symbol=:horizontal  : supersource array kind  =:vertical  : vertical array of supersources  =:horizontal  horizontal array of supersources  rattrib::Symbol=:horizontal  : receiver array kind  =:vertical  : vertical array of receivers  =:horizontal  horizontal array of receivers  rand_flags::Vector{Bool}=[false, false]  : decide placement of supersources and receivers   =[true, false]  : randomly place supersources for regularly spaced receivers  =[true, true]  : randomly place supersources and receivers  =[false, false]  : regularly spaced supersources and receivers  =[false, true]  : randomly place receivers for regularly spaced supersources   Return   a fixed spread acquisition geometry  Geom   source  #  SIT.Acquisition.Geom_get  \u2014  Method .  Return some derived fields of  Geom  Arguments   acq::Vector{Geom}  : a vector of  Geom   attrib::Symbol  : attribute to determine the return object    =:nus  number of unique source positions in acquisition  =:nur  number of unique receiver positions in acquisition  =:uspos  a tuple of x and z positions of all the unique sources  =:urpos  a tuple of x and z position of all the unique receivers  =:geomurpos  a  Geom  vector as if all the unique receiver positions are used for each supersource  =:geomuspos  a  Geom  vector as if all the unique source positions are used for each supersource     source  #  SIT.Acquisition.Geom_getvec  \u2014  Method .  return a vector of the order   source  #  SIT.Acquisition.Src_fixed  \u2014  Method .  Constructor for  Src  data type. Uses same source wavelet, i.e.,  wav  for all sources and supersources  Arguments   nss::Int64  : number of supersources  ns::Int64  : number of sources  nfield::Int64  : number of fields the sources are exciting  wav::Array{Float64}  : a source wavelet that is used for all sources and supersources  tgrid::Grid.M1D  : time grid for the wavelet   source  #  SIT.Acquisition.Src_fixed_mod  \u2014  Function .  Constructor of  Src , which is typical for a input model such that  the model has  nwav  wavelengths.   nwav::Int64=10  : number of wavelenghts in the model   nwav  source  #  SIT.Acquisition.Src_getvec  \u2014  Method .  return a vector of the order   source  #  SIT.Acquisition.Src_tr  \u2014  Method .  Function that returns Src after time reversal  source  #  SIT.Acquisition.Src_uspos  \u2014  Method .  Pad  Src   tgrids should be same in all Src  source",
            "title": "Acquisition"
        },
        {
            "location": "/#interpolation",
            "text": "#  SIT.Interpolation.get_interpolate_weights!  \u2014  Method .  get interpolation weights  source  #  SIT.Interpolation.get_spray_weights!  \u2014  Method .  get source spray weights  source  #  SIT.Interpolation.indminn  \u2014  Method .  TODO:   add dimension checks to interp_spray!   Reference: https://www.ibiblio.org/e-notes/Splines/bezier.html  Return n indices in order Cannot find a julia method which does, this. If a faster method is found, replace it later.  source  #  SIT.Interpolation.interp_B1_1D  \u2014  Method .  this subroutine interpolates or sprays bilinearly [one is adjoint of another] interpolation returns y using y1, y2 spraying returns y1, y2 using y                      +                      \n                    |                      \ny1= f(x1)           |      y2= f(x2)   \n  +-----------------x--------+             \n             y=f(x) |                      \n                    +  bilinear interpolation Reference: http://www.ajdesigner.com/phpinterpolation/bilinear_interpolation_equation.php  source  #  SIT.Interpolation.interp_B2_1D  \u2014  Method .  this subroutine interpolates or sprays  using cubic bspline interpolation returns y using y1, y2, y3, y4 spraying returns y1, y2, y3, y4 using y                     +                      \n                   |  y1      y2          |    y3       y4      +\u2013\u2013\u2013-+\u2013\u2013\u2013\u2013-x\u2013\u2013+\u2013\u2013\u2013\u2013+                              y=f(x) |                                              +                        source",
            "title": "Interpolation"
        },
        {
            "location": "/#models",
            "text": "#  SIT.Models.Seismic  \u2014  Type .  Data type fo represent a seismic model.  Fields   vp0::Vector{Float64}  : [vpmin, vpmax]  vs0::Vector{Float64}  : [vsmin, vsmax]  \u03c10::Vector{Float64}  : [\u03c1min, \u03c1max]  \u03c7vp::Array{Float64}  :  \u03c7vs::Array{Float64}  :  \u03c7\u03c1::Array{Float64}  :  mgrid::Grid.M2D  :   source  #  SIT.Models.Seismic_addon!  \u2014  Method .  Add features to a model.  Arguments   mod::Seismic  : model that is modified   Keyword Arguments   circ_loc::Vector{Float64}=nothing  : location of center of perturbation  circ_rad::Float64=0.0  : radius of circular perturbation  circ_pert::Float64=0.1  : perturbation inside a circle  rect_loc::Array{Float64}=nothing  : rectangle location  rect_pert::Float64=0.1  : perturbation in a rectangle  randn_pert::Float64=0.0  : percentage of reference values for additive random noise   source  #  SIT.Models.Seismic_chainrule!  \u2014  Function .  Use chain rule to output gradients with  respect to \u03c7vp and \u03c7\u03c1 from  gradients  with respect to KI and \u03c1I.  Arguments   gmod::Seismic  : gradient model  mod::Seismic  : model required for chain rule  g1  : gradient of an objective function with respect  attribs[1]  g2  : gradient of an objective function with respect  attribs[2]  attribs::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]  :   flag::Int64=1  :   =1  updates  gmod  using  g1  and  g2  =-1  updates  g1  and  g2  using  gmod     source  #  SIT.Models.Seismic_get  \u2014  Method .  Get other dependent model parameters of a seismic model that are not present in  Seismic .   :\u03c1I  : inverse of density  :Zp  : P-wave impedance   source  #  SIT.Models.Seismic_interp_spray!  \u2014  Method .  function to resample in the model domain  Arguments   mod::Seismic  : model  modi::Seismic  : model after interpolation   source  #  SIT.Models.Seismic_isequal  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_issimilar  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_issimilar  \u2014  Method .  Logical operation for  Seismic  source  #  SIT.Models.Seismic_pad_trun  \u2014  Method .  Extend a seismic model into PML layers  source  #  SIT.Models.Seismic_reparameterize!  \u2014  Function .  Re-parameterization routine  that modifies the fields   \u03c7vp  and  \u03c7\u03c1  of an input seismic model using two input vectors.  Arguments   mod::Seismic  : to be updated  x1::Array{Float64,2}  : contrast of inverse bulk modulus  x2::Array{Float64,2}  : contrast of inverse density  attribs:::Vector{Symbol}  : [:\u03c7KI, :\u03c7\u03c1I]   source  #  SIT.Models.Seismic_smooth!  \u2014  Function .  Apply smoothing to  Seismic  using a Gaussian filter of zwidth and xwidth  source  #  SIT.Models.Seismic_zeros  \u2014  Method .  Return  Seismic  with zeros everywhere; this method is used for preallocation.  Arguments   mgrid::Grid.M2D  : used for sizes of \u03c7 fields   source  #  SIT.Models.pad_trun  \u2014  Function .  Extend a model on all four sides  source  #  SIT.Models.\u03c7  \u2014  Function .  Return dimensionless contrast model parameter using the reference value.  Arguments   mod::Array{Float64}  : subsurface parameter  mod0::Vector{Float64}  : reference value is mean of this vector  flag::Int64=1  :   source  #  SIT.Models.\u03c7g  \u2014  Function .  Gradients Return contrast model parameter using the reference value.  source",
            "title": "Models"
        },
        {
            "location": "/#data",
            "text": "#  SIT.Data  \u2014  Module .  This module defines the data types related to seismic data:   TD  : time domain representation   It also provides methods that apply source and receiver filters onto  seismic data.  source  #  SIT.Data.TD  \u2014  Type .  Time domain representation of Seismic Data.  Fields   d::Array{Array{Float64,2},2}  : data  nfield::Int64  : number of components recorded at each receiver  tgrid::Grid.M1D  : grid to represent time  acqgeom::Acquisition.Geom  : acquisition geometry used to generate the data   source  #  SIT.Data.TD_dot  \u2014  Method .  Returns dot product of data.  Arguments   data1::TD  : data 1  data2::TD  : data 2   Return   dot product as  Float64   source  #  SIT.Data.TD_iszero  \u2014  Method .  Returns bool depending on if input  data::TD  has all zeros or not.  source  #  SIT.Data.TD_normalize  \u2014  Method .  Normalize time-domain seismic data.  Arguments   data::TD  : input data   attrib::Symbol  : decide kind of normalization   =:recrms  the record at every receiver is normalized with its RMS value  =:recmax  the record at every receiver is normalized with its maximum value     Return   normalized data as  TD   source  #  SIT.Data.TD_resamp!  \u2014  Method .  Method to resample data in time.  Arguments   data::TD  : input data of type  TD  dataout::TD  : preallocated data of type  TD  that is modified   source  #  SIT.Data.TD_resamp  \u2014  Method .  Method to resample data in time.  Arguments   data::TD  : input data of type  TD  tgrid::Grid.M1D  : resampling in time according to this time grid   Return   data after resampling as  TD   source  #  SIT.Data.TD_tr!  \u2014  Method .  Time reverse the records of each receiver in  TD    Arguments   data::TD  : input data that is modified   source  #  SIT.Data.TD_urpos  \u2014  Method .  Construct TD using data at all the unique receiver positions for all supersources.  source  #  SIT.Data.TD_zeros  \u2014  Method .  Method used to preallocate  TD  with zeros.  Arguments   nfield::Int64  : number of components  tgrid::Grid.M1D  : time domain grid  acqgeom::Acquisition.Geom  : acquisition geometry   Return   data with zeros as  TD   source  #  SIT.Data.TDcoup!  \u2014  Method .  Apply source and receiver coupling functions to TD. Currently, only source filters are applied.  Arguments   s::TD  : input data  r::TD  : input data  w::Coupling.TD  : input source and receiver filters   attrib::Symbol  : attribute to    =:s  to apply  w  to  r  and modify  s  =:r  to apply adjoint of  w  to  s  and modify  r  =:w  modify  w  using  r  and  s     source",
            "title": "Data"
        },
        {
            "location": "/#misfits",
            "text": "#  SIT.Misfits.TD  \u2014  Method .  Input the obeserved and modelled data to output the misfit and the adjoint sources TODO:   source  #  SIT.Misfits.error_after_scaling  \u2014  Method .  Normalized least-squares error between two vectors after  estimating a scalar that best fits on to another. Return misfit and \u03b1 such that \u03b1x-y is minimum. Normalization is done with respect to the  norm of y.  source",
            "title": "Misfits"
        },
        {
            "location": "/#gallery",
            "text": "#  SIT.Gallery.Geom  \u2014  Method .  Gallery of acquisition geometries  Geom  using an input mesh  M2D . The sources and receivers are not placed anywhere on the edges of the mesh.  Arguments   mgrid::Grid.M2D  : a 2-D mesh   attrib::Symbol  : attribute decides output   =:xwell  cross-well acquisition  =:surf  cross-well; but sources and receivers at unequal depths  =:vsp  vertical seismic profiling  =:rvsp   reverse vertical seismic profiling  =:downhole  downhole sources and receivers  rand_flags::Vector{Bool}=[false, false]  : randomly or equally spaced?     source  #  SIT.Gallery.M1D  \u2014  Method .  Gallery of  M1D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a time grid for with 1000 samples; maximum time is 2 s  attrib=:acou_homo1_long  : a time grid for with 1000 samples; maximum time is 4 s  attrib=:npow2samp1  : a sample npow2 grid with 16 samples   source  #  SIT.Gallery.M2D  \u2014  Method .  Gallery of  M2D  grids.  Arguments   attrib::Symbol  :   Outputs   attrib=:acou_homo1  : a square grid for with 201 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.   attrib=:acou_homo2  : a square grid for with 51 samples in each dimension, with 50 PML       points; both X and Z vary from -1000 to 1000.  source  #  SIT.Gallery.Seismic  \u2014  Function .  Gallery of  Seismic  models.  Arguments   attrib::Symbol  :   Outputs    attrib=:acou_homo1  : an homogeneous acoustic model with  vp0=2000  and  \u03c10=2000   attrib=:acou_homo2  : same as above, but with spatial sampling as 40 m (faster testing)  attrib=:seismic_marmousi2  : marmousi model with lower resolution; ideal for surface seismic experiments  attrib=:seismic_marmousi2_high_res  : marmousi model high resolution; slower to load  attrib=:seismic_marmousi2_box1  : 1x1 kilometer box of marmousi model; ideal for crosswell, borehole seismic studies     source  #  SIT.Gallery.Src  \u2014  Function .  Gallery of source signals  Src .  Arguments   attrib::Symbol  :  nss::Int64=1  : number of supersources   Outputs   attrib=:acou_homo1  :   source",
            "title": "Gallery"
        },
        {
            "location": "/#fdtd",
            "text": "#  SIT.Fdtd.compute_illum!  \u2014  Method .  Need illumination to estimate the approximate diagonal of Hessian  source  #  SIT.Fdtd.get_rhovxI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  SIT.Fdtd.get_rhovzI  \u2014  Method .  Project density on to a staggerred grid using simple interpolation  source  #  SIT.Fdtd.mod!  \u2014  Method .  As forward modeling method, the  finite-difference method is employed.  It uses a discrete version of the two-dimensional isotropic acoustic wave equation. As shown in    $$\npp[ zero] - pp[ mo] = dt mB left({partial_x\u000bx}[ mh]\n + partial_z \u000bz[    mh]  + dtsum_{0}^{  mo}sfo\night)\n  math\npp[ po] - pp[   zero] = dt mB left(partial_x \u000bx[    ph]\n + {partial_z \u000bz}[  ph]  + dtsum_{0}^{  zero}sfo\night)\n ```  Figure~ef{fdshmesh_acou}, a staggered-grid mesh is used",
            "title": "Fdtd"
        },
        {
            "location": "/#keyword-arguments",
            "text": "npropwav::Int64=1  : number of independently propagating wavefields in  model  model::Models.Seismic  : seismic medium parameters   model_pert::Models.Seismic  : perturbed model, i.e., model + \u03b4model, used for Born modeling   tgridmod::Grid.M1D  : modelling time vector  tgrid::Grid.M1D  : output records are interpolated on this time vector  recv_nfield::Int64=1  : number of fields that receivers record   backprop_flag::Bool=Int64  : save final state variables and the boundary conditions for later use  boundary_in::Any=[0]  : input final state variables and boundary  abs_trbl::Vector{Symbol}=[:top, :bottom, :right, :left]  : PML boundary conditions   born_flag::Bool=false  : Born modeling flag  gmodel_flag=false  : output gradient or not  illum_flag::Bool=false  : output wavefield energy or source illumination to use as preconditioner later  illum_out::Array{Float64}  : source energy with same dimensions as model.mgrid  verbose::Bool=false  : verbose flag",
            "title": "Keyword Arguments"
        },
        {
            "location": "/#example",
            "text": "$$  julia julia> records,   = mod(); ``` Credits: Pawan Bharadwaj, 2017  source  #  SIT.Fdtd.pml_variables  \u2014  Method .  Output vectors related to PML boundaries.  source",
            "title": "Example"
        },
        {
            "location": "/#inversion",
            "text": "#  SIT.Inversion.Param  \u2014  Type .  Inversion Parameters, i.e., factors that  are fixed throughout the inversion  Fields   mgrid::Grid.M2D  : modelling grid  igrid::Grid.M2D  : inversion grid  acqsrc::Acquisition.Src  : base source wavelet for modelling data  acqgeom::Acquisition.Geom  : acquisition geometry  tgrid::Grid.M1D  :  attrib_mod::Symbol  model_obs  : model used for generating observed data  model0  : background velocity model (only used during Born modeling and inversion)  parameterization  : a vector of Symbols specifying parameterization of the inversion vector  verbose  : print level on STOUT  attrib  : synthetic or real   TODO: add an extra attribute for coupling functions inversion and modelling  source  #  SIT.Inversion.Param  \u2014  Method .  Constructor for  Param  Arguments   acqsrc::Acquisition.Src  : source time functions  acqgeom::Acquisition.Geom  : acquisition geometry  tgrid::Grid.M1D  : modelling time grid  attrib_mod::Symbol  : modelling attribute  attrib_inv::Symbol  : inversion attribute  modm::Models.Seismic  : seismic model on modelling mesh   Optional Arguments   igrid::Grid.M2D=modm.mgrid  : inversion grid if different from the modelling grid, i.e.,  modm.mgrid  mprecon_flag::Bool=false  : flag to use a model preconditioner  dobs::Data.TD  : observed data  tlagssf::Float64=0.0  : maximum lagtime of unknown source filter  tlagrf::Float64=0.0  : maximum lagtime of unknown receiver filter  acqsrc_obs::Acquisition.Src=acqsrc  : source wavelets to generate  observed data ; can be different from  acqsrc  modm_obs::Models.Seismic=modm  : actual seismic model to generate  observed data  modm0::Models.Seismic=modm  : background seismic model for Born modelling and inversion (still being tested)  mod_inv_parameterization::Vector{Symbol}=[:\u03c7KI, :\u03c7\u03c1I]  : subsurface parameterization  verbose::Bool=false  : print level on STDOUT during inversion   attrib::Symbol=:synthetic  : an attribute to control class   =:synthetic  synthetic data inversion  =:field  field data inversion     source  #  SIT.Inversion.AdjGeom  \u2014  Method .  Modify the input acquisition geometry  such that the adjoint source time functions can  be propagated from the receiver positions. The number of supersources will remain the same. All the recievers will be fired as simultaneous sources.  source  #  SIT.Inversion.Coupling_x!  \u2014  Method .  Convert coupling functions to x and vice versa  source  #  SIT.Inversion.Seismic_gx!  \u2014  Method .  Convert gradient vector to  Seismic  type and vice versa This will be different from the previous one, once  the parameterizations come in   gmodm::Models.Seismic  : gradient model on the modelling grid  modm::Models.Seismic  : model on the modelling grid  gmodi::Models.Seismic  : gradient model on the inversion grid  modi::Models.Seismic  : model on the inversion grid  gx::Vector{Float64}  : gradient vector  pa::Param  :   flag::Int64  :   =1  update the vector  gx  using  gmod  =-1  update gmod     source  #  SIT.Inversion.Seismic_x!  \u2014  Method .  Convert  Seismic  model to x and vice versa   modm::Models.Seismic  : seismic model on modelling grid (input zeros to not use it)  modi::Models.Seismic  : seismic model on inversion grid  x::Vector{Float64}  : inversion vector  pa::Param  : fwi parameters   flag::Int64  :    =1  converts either modm or modi to x  =-1  updates both modm and modi using x     source  #  SIT.Inversion.Seismic_xbound!  \u2014  Method .  Return bound vectors for the  Seismic  model,  depeding on paramaterization  source  #  SIT.Inversion.func_Coupling  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  SIT.Inversion.func_xfwi  \u2014  Method .  Return functional and gradient of the CLS objective   source  #  SIT.Inversion.grad_Coupling!  \u2014  Method .  There is a bug in gradient computation  source  #  SIT.Inversion.update_buffer!  \u2014  Function .  Update the buffer, which consists of the modelled data and boundary values for adjoint calculation.  Arguments   x::Vector{Float64}  : inversion variable  last_x::Vector{Float64}  : buffer is only updated when x!=last_x, and modified such that last_x=x  pa::Param  : parameters that are constant during the inversion  modm::Models.Seismic  :   source  #  SIT.Inversion.update_buffer_zeros  \u2014  Method .  allocate buffer  source  #  SIT.Inversion.wfwi!  \u2014  Method .  Update pa.w  source  #  SIT.Inversion.wfwi_ninv  \u2014  Method .  Return the number of inversion variables for source and receiver filter inversion  corresponding to  Param . This number depends on the maximum lagtimes of the filters.   source  #  SIT.Inversion.xfwi!  \u2014  Method .  Full Waveform Inversion using  Optim . This method updates  pa.modm  and  pa.dcal . More details about the optional parameters can be found in the documentation of the  Optim   package.  Arguments that are modified   pa::Param  : inversion parameters   Optional Arguments   extended_trace::Bool=true  : save extended trace  time_limit=Float64=2.0*60.  : time limit for inversion (testing)  iterations::Int64=5  : maximum number of iterations  f_tol::Float64=1e-3  : functional tolerance  g_tol::Float64=1e-3  : gradient tolerance  x_tol::Float64=1e-3  : model tolerance   Outputs    depending on   pa.attrib_inv   =:cls  classic least-squares inversion using adjoint state method  =:migr  return gradient at the first iteration, i.e., a migration image  =:migr_finite_difference  same as above but  not  using adjoint state method; time consuming; only for testing, TODO: implement autodiff here     source  #  SIT.Inversion.xfwi_ninv  \u2014  Method .  Return the number of inversion variables for FWI corresponding to  Param . This number of inversion variables depend on the size of inversion mesh.  source",
            "title": "Inversion"
        },
        {
            "location": "/#interferometry",
            "text": "#  SIT.Interferometry.TD_virtual_diff  \u2014  Method .  enhance diffractions in the  TD  Keyword Arguments  \u03bbdom::Float64=0.0  : distance between receivers must be greater than twice central wavelength, 2*\u03bbdom (Shapiro 2005)  tlag::Float64=data.tgrid.x[end]-data.tgrid.x[1]  : maximum lag time in the output traces   source",
            "title": "Interferometry"
        },
        {
            "location": "/#cica",
            "text": "#  SIT.CICA  \u2014  Module .  Independent Component Analysis for Convolutive Mixtures  source  #  SIT.CICA.bica  \u2014  Method .  Performs ICA for convolutive mixtures.  Arguments   magic_recv : a receiver index, where deblending is performed  recv_n : total number of receivers  src_n : total number of sources  grid :  M1D  grid  nband : number of frequency bins, where ICA is performed  nsubfac : overlap factor (testing)  X : blended data   Output   Y : deblended data at  magic_recv   source  #  SIT.CICA.exact_freq_mixing  \u2014  Method .  Convolutive mixing in the frequency domain.  Arguments   As :  Ab :  B :  S :  fgrid :   Outputs   D  d  Ds  ds  Db  db   source",
            "title": "CICA"
        },
        {
            "location": "/#plots",
            "text": "#  SIT.Plots.printfig  \u2014  Method .  save current fig using matlab2tikz  source  #  SIT.Plots.Geom  \u2014  Method .  Plot acquisition geometry  Acquisition.Geom  on  and model grid  M2D .  attrib::Symbol=:unique  : default; plots unique source and receiver positions   source  #  SIT.Plots.Seismic  \u2014  Method .  Plot seismic model  Arguments   model::Models.Seismic  =   Keyword Arguments   xlim::Vector{Float64}=[model.mgrid.x[1],model.mgrid.x[end]]  :  zlim::Vector{Float64}=[model.mgrid.z[1],model.mgrid.z[end]]  :   source  #  SIT.Plots.Src  \u2014  Method .  Plot acqsrc  source  #  SIT.Plots.TD  \u2014  Method .  Plot time-domain data of type  Data.TD  Arguments   td::Data.TD  :   Keyword Arguments   ssvec::Vector{Int64}=[1]  : supersource vector to be plotted  fieldvec::Vector{Int64}=[1]  : field vector to be plotted  tr_flag::Bool=false  : plot time-reversed data when true  attrib::Symbol=:wav  : specify type of plot   source  %## Another Section % @contents %Pages = [ %    \"modeling/page1.md\"  %    ] %Depth = 2 %  %  % @contents %Pages = [ %    \"tutorials/page1.md\", %    ] %Depth = 2 %",
            "title": "Plots"
        },
        {
            "location": "/#index",
            "text": "SIT.Acquisition  SIT.CICA  SIT.Coupling  SIT.Data  SIT.Acquisition.Geom  SIT.Acquisition.Src  SIT.Data.TD  SIT.Grid.M1D  SIT.Grid.M1D  SIT.Grid.M1D  SIT.Grid.M2D  SIT.Inversion.Param  SIT.Inversion.Param  SIT.Models.Seismic  SIT.Acquisition.Geom_add!  SIT.Acquisition.Geom_add!  SIT.Acquisition.Geom_advance  SIT.Acquisition.Geom_boundary  SIT.Acquisition.Geom_circ  SIT.Acquisition.Geom_find  SIT.Acquisition.Geom_fixed  SIT.Acquisition.Geom_get  SIT.Acquisition.Geom_getvec  SIT.Acquisition.Src_fixed  SIT.Acquisition.Src_fixed_mod  SIT.Acquisition.Src_getvec  SIT.Acquisition.Src_tr  SIT.Acquisition.Src_uspos  SIT.CICA.bica  SIT.CICA.exact_freq_mixing  SIT.Coupling.TD_delta  SIT.Data.TD_dot  SIT.Data.TD_iszero  SIT.Data.TD_normalize  SIT.Data.TD_resamp  SIT.Data.TD_resamp!  SIT.Data.TD_tr!  SIT.Data.TD_urpos  SIT.Data.TD_zeros  SIT.Data.TDcoup!  SIT.Fdtd.compute_illum!  SIT.Fdtd.get_rhovxI  SIT.Fdtd.get_rhovzI  SIT.Fdtd.mod!  SIT.Fdtd.pml_variables  SIT.Gallery.Geom  SIT.Gallery.M1D  SIT.Gallery.M2D  SIT.Gallery.Seismic  SIT.Gallery.Src  SIT.Grid.M1D_isequal  SIT.Grid.M1D_lag  SIT.Grid.M1D_npow2  SIT.Grid.M1D_npow2_tf  SIT.Grid.M1D_resamp  SIT.Grid.M1D_truncate  SIT.Grid.M2D_boundary  SIT.Grid.M2D_isequal  SIT.Grid.M2D_pad_trun  SIT.Grid.M2D_resamp  SIT.Interferometry.TD_virtual_diff  SIT.Interpolation.get_interpolate_weights!  SIT.Interpolation.get_spray_weights!  SIT.Interpolation.indminn  SIT.Interpolation.interp_B1_1D  SIT.Interpolation.interp_B2_1D  SIT.Inversion.AdjGeom  SIT.Inversion.Coupling_x!  SIT.Inversion.Seismic_gx!  SIT.Inversion.Seismic_x!  SIT.Inversion.Seismic_xbound!  SIT.Inversion.func_Coupling  SIT.Inversion.func_xfwi  SIT.Inversion.grad_Coupling!  SIT.Inversion.update_buffer!  SIT.Inversion.update_buffer_zeros  SIT.Inversion.wfwi!  SIT.Inversion.wfwi_ninv  SIT.Inversion.xfwi!  SIT.Inversion.xfwi_ninv  SIT.Misfits.TD  SIT.Misfits.error_after_scaling  SIT.Models.Seismic_addon!  SIT.Models.Seismic_chainrule!  SIT.Models.Seismic_get  SIT.Models.Seismic_interp_spray!  SIT.Models.Seismic_isequal  SIT.Models.Seismic_issimilar  SIT.Models.Seismic_issimilar  SIT.Models.Seismic_pad_trun  SIT.Models.Seismic_reparameterize!  SIT.Models.Seismic_smooth!  SIT.Models.Seismic_zeros  SIT.Models.pad_trun  SIT.Models.\u03c7  SIT.Models.\u03c7g  SIT.Plots.Geom  SIT.Plots.Seismic  SIT.Plots.Src  SIT.Plots.TD  SIT.Plots.printfig  SIT.Wavelets.ormsby  SIT.Wavelets.ricker",
            "title": "Index"
        },
        {
            "location": "/tutorials/page1/",
            "text": "FFF FF",
            "title": "Title 1"
        },
        {
            "location": "/modeling/page1/",
            "text": "ff",
            "title": "Title 1"
        }
    ]
}